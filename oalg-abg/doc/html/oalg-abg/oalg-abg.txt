-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Finitely generated abelian groups.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/zErichGut/oalg-abg#readme</a>
@package oalg-abg
@version 1.0.0.0


-- | basic algorithms for the integers <a>Z</a>.
module OAlg.AbelianGroup.Euclid

-- | greatest common divisor.
--   
--   <b>Properties</b> For all <tt>a</tt> and <tt>b</tt> in <a>N</a> holds:
--   
--   <ol>
--   <li><tt>gcd a b <a>==</a> gcd b a</tt>.</li>
--   <li><tt>gcd a b <a>==</a> 0</tt> if and only if <tt>a <a>==</a> 0</tt>
--   and <tt>b <a>==</a> 0</tt>.</li>
--   <li><tt>gcd a 0 <a>==</a> a</tt>.</li>
--   <li><tt>gcd a 1 <a>==</a> 1</tt>.</li>
--   <li><tt>gcd a b <a>*</a> <a>lcm</a> a b <a>==</a> a <a>*</a>
--   b</tt>.</li>
--   </ol>
gcd :: N -> N -> N

-- | greatest common divisor of the given list.
--   
--   <b>Note</b> <tt>gcds [] <a>==</a> 0</tt>.
gcds :: [N] -> N

-- | least common multiple.
--   
--   <b>Properties</b> For all <tt>a</tt> and <tt>b</tt> in <a>N</a> holds:
--   
--   <ol>
--   <li><tt>lcm a b <a>==</a> lcm b a</tt>.</li>
--   <li><tt>lcm a b <a>==</a> 1</tt> if and only if <tt>a <a>==</a> 1</tt>
--   and <tt>b <a>==</a> 1</tt>.</li>
--   <li><tt>lcm a 0 <a>==</a> 0</tt>.</li>
--   <li><tt>lcm a 1 <a>==</a> a</tt>.</li>
--   <li><tt><a>gcd</a> a b <a>*</a> lcm a b <a>==</a> a <a>*</a>
--   b</tt>.</li>
--   </ol>
lcm :: N -> N -> N

-- | least common multiple of the given list.
--   
--   <b>Property</b> <tt><a>lcms</a> [] <a>==</a> 1</tt>.
lcms :: [N] -> N

-- | extended euclidean algorithm to determine the greatest cowmon divisor.
--   
--   <b>Properties</b> <tt>(g,s,t) = <a>euclid</a> a b</tt> then
--   
--   <ol>
--   <li><tt>g</tt> is the greatest common divisor of <tt>a</tt> and
--   <tt>b</tt>.</li>
--   <li><tt>g <a>==</a> s <a>*</a> a <a>+</a> t <a>*</a> b</tt>.</li>
--   </ol>
euclid :: Z -> Z -> (N, Z, Z)

-- | extended modulo in <a>Z</a> according to <a>N</a>.
--   
--   <b>Property</b> For all <tt>z</tt> and <tt>n</tt> holds
--   
--   <ol>
--   <li><tt><a>mod0</a> z 0 <a>==</a> z</tt>.</li>
--   <li>if <tt>0 &lt; n</tt> than <tt><a>mod0</a> z n <a>==</a> <a>mod</a>
--   z (<a>inj</a> n)</tt>.</li>
--   </ol>
mod0 :: Z -> N -> Z

-- | extended division in <a>Z</a> by a dividend in <a>N</a>.
--   
--   <b>Properties</b> For all <tt>z</tt> and <tt>n</tt> holds:
--   
--   <ol>
--   <li><tt>0 // 0 <a>==</a> 1</tt>.</li>
--   <li>if <tt>z <a>/=</a> 0</tt> then <tt>z // 0 <a>==</a> 0</tt>.</li>
--   <li>if <tt>0 <a>&lt;</a> n</tt> then <tt>z // n <a>==</a> <a>div</a> z
--   n</tt>.</li>
--   <li><tt>z <a>==</a> (z // n) <a>*</a> <a>inj</a> n <a>+</a>
--   <a>mod0</a> z n</tt>.</li>
--   </ol>
(//) :: Z -> N -> Z
infix 7 //


-- | diagonal and Smith Normal Form for <a>Z</a>-matrices.
module OAlg.AbelianGroup.Free.SmithNormalForm

-- | transforming a matrix over Z to a diagonal matrix by applying elements
--   of <tt><a>GLT</a> <a>Z</a></tt>.
zmxDiagonalForm :: Matrix Z -> DiagonalForm Z

-- | Smith Normal Form of a matrix.
--   
--   <b>Property</b> Let <tt>m</tt> be in <tt><a>Matrix</a> <a>Z</a></tt>
--   and <tt>'SmithNormalForm o ds a b = <a>smithNormalForm</a> m</tt>,
--   then holds: <tt>(a <a>*&gt;</a> m) <a>&lt;*</a> b <a>==</a>
--   <a>diagonal</a> (<a>rows</a> m) (<a>cols</a> m) ds</tt> where <tt>ds =
--   (<a>takeN</a> o <a>$</a> <a>repeat</a> 1) <a>++</a> ds'</tt>.
smithNormalForm :: Matrix Z -> SmithNormalForm Z

-- | Smith Normal Form of a diagonal matrix over <a>Z</a> with strict
--   positive entries.
--   
--   <b>Property</b> Let <tt>d = <a>DiagonalFormStrictPositive</a> d'
--   (<a>DiagonalForm</a> ds a b)</tt> be in
--   <tt><a>DiagonalFormStrictPositive</a> <a>Z</a></tt>, <tt>m =
--   <a>dgfMatrix</a> d'</tt> and <tt>s = <a>smithNormalForm'</a> d</tt>,
--   then holds: <tt>m <a>==</a> <a>dgfMatrix</a> (<a>snfDiagonalForm</a>
--   s)</tt>.
smithNormalForm' :: DiagonalFormStrictPositive Z -> SmithNormalForm Z

-- | transforming a matrix over Z to a diagonal matrix with strict positive
--   entries by applying elements of <tt><a>GLT</a> <a>Z</a></tt>.
--   
--   <b>Property</b> Let <tt>m</tt> be in <tt><a>Matrix</a> Z</tt> and
--   <tt><a>DiagonalFormStrictPositive</a> d =
--   <a>zmxDiagonalFormStrictPositive</a> m</tt>, then holds: <tt>(a
--   <a>*&gt;</a> m) <a>&lt;*</a> b <a>==</a> <a>diagonal</a> (<a>rows</a>
--   m) (<a>cols</a> m) ds</tt> where <tt><a>DiagonalForm</a> ds a b =
--   d</tt>.
--   
--   <b>Note</b> The entries of the diagonal may not be successively
--   divisible, as such it is a pre-form of the Smith Normal Form.
zmxDiagonalFormStrictPositive :: Matrix Z -> DiagonalFormStrictPositive Z

-- | the smith normal form.
--   
--   <b>Properties</b> Let <tt>s = <a>SmithNormalForm</a> o ds a b</tt> be
--   in <tt><a>SmithNormalForm</a> <a>Z</a></tt>, then holds:
--   
--   <ol>
--   <li><tt><a>snfDiagonalForm</a> s</tt> is <a>valid</a>.</li>
--   <li>For all <tt>k</tt> in <tt>ks</tt> holds: <tt>0 &lt; k</tt>.</li>
--   <li>For all <tt>..k<tt>:</tt>k'..</tt> in <tt>ks</tt> holds:
--   <tt><a>mod</a> k' k <a>==</a> 0</tt>.</li>
--   </ol>
data SmithNormalForm k
SmithNormalForm :: N -> [k] -> RowTrafo k -> ColTrafo k -> SmithNormalForm k

-- | the underlying diagonal form.
snfDiagonalForm :: Semiring k => SmithNormalForm k -> DiagonalForm k

-- | validating diagonal and Smith Normal form for <a>Z</a>-matrices.
prpDiagonalFormZ :: N -> Q -> Statement
instance OAlg.Structure.Oriented.Definition.Oriented k => GHC.Classes.Eq (OAlg.AbelianGroup.Free.SmithNormalForm.SmithNormalForm k)
instance OAlg.Structure.Oriented.Definition.Oriented k => GHC.Show.Show (OAlg.AbelianGroup.Free.SmithNormalForm.SmithNormalForm k)
instance OAlg.Data.Validable.Validable (OAlg.AbelianGroup.Free.SmithNormalForm.SmithNormalForm OAlg.Data.Number.Z)
instance OAlg.Entity.Definition.Entity (OAlg.AbelianGroup.Free.SmithNormalForm.SmithNormalForm OAlg.Data.Number.Z)


-- | limits for <a>Z</a>-matrices.
module OAlg.AbelianGroup.Free.Limes

-- | kernels for <a>Z</a>-matrices.
zmxKernels :: Kernels n (Matrix Z)

-- | pullbacks for <a>Z</a>-matrices.
zmxPullbacks :: Pullbacks n (Matrix Z)


-- | homomorphisms between free abelian groups which are represented by
--   <a>Z</a>-matrices.
module OAlg.AbelianGroup.Free


-- | Homomorphisms between cyclic groups.
--   
--   A group is called <b><i>cyclic</i></b> if it is generated by one
--   element. Such a group <tt>G</tt> is obviously abelian and isomorphic
--   to <tt><a>Z</a>/n<a>Z</a></tt> for some <tt>n :: <a>N</a></tt>, which
--   is called its <b><i>order</i></b>. The group homomorphisms between
--   cyclic groups form a <a>Z</a>-algebraic structure which is presented
--   here.
module OAlg.AbelianGroup.ZMod

-- | cyclic group <tt><a>Z</a>/n</tt>, i.e. the quotient group of <a>Z</a>
--   <i>divided</i> by <tt>n<a>Z</a></tt>.
newtype ZMod
ZMod :: N -> ZMod

-- | order of the cyclic group.
zmOrd :: ZMod -> N

-- | additive homomorphisms between cyclic groups <a>ZMod</a> constructable
--   via <a>zmh</a>.
--   
--   <b>Note</b> The homomorphisms between two cyclic groups <tt>a</tt> and
--   <tt>b</tt> form again a cyclic group which will be denoted by
--   <tt><a>ZModHom</a> (a<a>:&gt;</a>b)</tt> (see <a>zmhGenOrd</a>).
data ZModHom

-- | the underlying integer.
toZ :: ZModHom -> Z

-- | the endomorphism in <tt><a>ZMod</a> 0</tt> given by the integer, i.e.
--   the inverse of <a>toZ</a>.
fromZ :: Z -> ZModHom

-- | the induced homomorphism.
--   
--   <b>Property</b> Let <tt>a</tt>, <tt>b</tt> be in <a>ZMod</a> and
--   <tt>r</tt> in <a>Z</a> then holds:
--   
--   <ol>
--   <li><tt><a>zmh</a> a b r</tt> is <a>valid</a> if and only if
--   <tt><a>zmhEligible</a> a b r</tt> is true.</li>
--   <li>If <tt><a>zmhEligible</a> a b r</tt> is false then the evaluation
--   of <tt><a>zmh</a> a b r</tt> will end up by throwing a
--   <a>NotEligible</a>-exception.</li>
--   </ol>
zmh :: Orientation ZMod -> Z -> ZModHom

-- | predicate to determine the eligibility of a value in <a>Z</a> to
--   induce a homomorphism between the given cyclic groups.
--   
--   <b>Property</b> Let <tt>a = <a>ZMod</a> a'</tt>, <tt>b = <a>ZMod</a>
--   b'</tt> be in <a>ZMod</a> and <tt>r</tt> in <a>Z</a>, then holds:
--   <tt><a>zmhEligible</a> a b r</tt> is true if and only if
--   <tt><a>mod0</a> (r <a>*</a> <a>inj</a> a') b' <a>==</a> 0</tt>.
zmhEligible :: ZMod -> ZMod -> Z -> Bool

-- | <tt>zmhGenOrd (a<a>:&gt;</a>b) = (r,o)</tt> where <tt>r</tt> is a
--   generator for <tt><a>ZModHom</a>(a<a>:&gt;</a>b)</tt> with order
--   <tt>o</tt>.
--   
--   <b>Note</b> It follows that <tt><a>inj</a> o <a>!</a> r <a>==</a>
--   <a>zero</a> (a<a>:&gt;</a>b)</tt> and
--   <tt><a>ZModHom</a>(a<a>:&gt;</a>b)</tt> is isomorphic to
--   <tt><a>Z</a>/o</tt> which is represented by <tt><a>ZMod</a> o</tt>.
zmhGenOrd :: Orientation ZMod -> (ZModHom, N)

-- | <tt>zmhGenerator (a:&gt;b) = h</tt> is a generator for the abelian
--   group <tt><a>ZModHom</a>(a<a>:&gt;</a>b)</tt>.
zmhGenerator :: Orientation ZMod -> ZModHom

-- | random variable for homomorphisms for the given orientation of
--   <a>ZMod</a>.
xZModHom :: X Z -> Orientation ZMod -> X ZModHom

-- | random variable for homomorphisms based on <a>xZModTo</a>.
xZModHomTo :: N -> X Z -> X ZMod -> XOrtSite To ZModHom

-- | random variable for homomorphisms based on <a>xZModFrom</a>.
xZModHomFrom :: N -> X Z -> X ZMod -> XOrtSite From ZModHom

-- | random variable of cyclic groups admitting nontrivial homomorphisms to
--   the given group.
xZModTo :: N -> ZMod -> X ZMod

-- | random variable of cyclic groups admitting non trivial homomorphisms
--   from the given one.
xZModFrom :: N -> ZMod -> X ZMod

-- | validity of the <a>Z</a>-algebraic structure of <a>ZModHom</a>.
prpZModHom :: Statement

-- | exceptions for cyclic groups which are sub exceptions from
--   <a>SomeOAlgException</a>.
data ZModException
NotEligible :: String -> ZModException
instance GHC.Show.Show OAlg.AbelianGroup.ZMod.ZModException
instance GHC.Classes.Eq OAlg.AbelianGroup.ZMod.ZModException
instance OAlg.Entity.Definition.Entity OAlg.AbelianGroup.ZMod.ZMod
instance OAlg.Data.Validable.Validable OAlg.AbelianGroup.ZMod.ZMod
instance GHC.Classes.Ord OAlg.AbelianGroup.ZMod.ZMod
instance GHC.Classes.Eq OAlg.AbelianGroup.ZMod.ZMod
instance GHC.Classes.Ord OAlg.AbelianGroup.ZMod.ZModHom
instance GHC.Classes.Eq OAlg.AbelianGroup.ZMod.ZModHom
instance GHC.Show.Show OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Data.Validable.Validable OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Entity.Definition.Entity OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Oriented.Definition.Oriented OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Multiplicative.Definition.Multiplicative OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Multiplicative.Definition.Commutative OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Multiplicative.Definition.Invertible OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Fibred.Definition.Fibred OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Fibred.Definition.FibredOriented OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Additive.Definition.Additive OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Additive.Definition.Abelian OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Vectorial.Definition.Vectorial OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Distributive.Definition.Distributive OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Algebraic.Definition.Algebraic OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To OAlg.AbelianGroup.ZMod.ZModHom
instance OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From OAlg.AbelianGroup.ZMod.ZModHom
instance GHC.Show.Show OAlg.AbelianGroup.ZMod.ZMod
instance OAlg.Data.Validable.XStandard OAlg.AbelianGroup.ZMod.ZMod
instance GHC.Exception.Type.Exception OAlg.AbelianGroup.ZMod.ZModException


-- | homomorphisms between finitely generated abelian groups.
module OAlg.AbelianGroup.Definition

-- | finitely generate abelian group, i.e. the cartesian product of cyclic
--   groups <tt><a>Z</a>/n</tt> and are represented as a formal product
--   with symbols in <a>ZMod</a>.
--   
--   <b>Definition</b> Let <tt>g</tt> be in <a>AbGroup</a>. We call
--   <tt>g</tt> <b><i>smith normal</i></b> if and only if there exists a
--   sequence <tt>n 0, n 1 .. n (k-1)</tt> in <a>N</a> with length
--   <tt>k</tt> and a exponent <tt>r</tt> in <a>N</a> such that:
--   
--   <ol>
--   <li><tt>2 <a>&lt;=</a> n i</tt> for all <tt>0 <a>&lt;=</a> i &lt;
--   k</tt>.</li>
--   <li><tt>n (i <a>+</a> 1) <a>mod</a> n i <a>==</a> 0</tt> for all
--   <tt>i</tt> in <tt>0 <a>&lt;=</a> i &lt; k-1</tt>.</li>
--   <li><tt>g <a>==</a> <a>abg</a> (n 0) <a>*</a> <a>abg</a> (n 1)
--   <a>*</a> .. <a>*</a> <a>abg</a> (n (k-1)) <a>*</a> <a>abg</a> 0
--   <a>^</a> r</tt>.</li>
--   </ol>
--   
--   <b>Theorem</b> Every finitely generated abelian group is isomorphic to
--   a group in smith normal form. This isomorphism is given by
--   <a>isoSmithNormal</a>.
--   
--   <b>Examples</b> Finitely generated abelian groups constructed via
--   <a>abg</a> and its multiplicative structure:
--   
--   <pre>
--   &gt;&gt;&gt; abg 12
--   AbGroup[Z/12]
--   </pre>
--   
--   represents the cyclic group <tt><a>Z</a>/12</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; abg 2 * abg 3
--   AbGroup[Z/2*Z/3]
--   </pre>
--   
--   represents the cartesian product of the groups <tt><a>Z</a>/2</tt> and
--   <tt><a>Z</a>/3</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; abg 6 * abg 4 * abg 4
--   AbGroup[Z/6*Z/4^2]
--   </pre>
--   
--   represents the cartesian product of the groups <tt><a>Z</a>/6</tt>,
--   <tt><a>Z</a>/4</tt> and <tt><a>Z</a>/4</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; abg 0 ^ 6
--   AbGroup[Z^6]
--   </pre>
--   
--   represents the free abelian group <tt><a>Z</a> <a>^</a> 6</tt> of
--   <i>dimension</i> 6.
--   
--   <pre>
--   &gt;&gt;&gt; one () :: AbGroup
--   AbGroup[]
--   </pre>
--   
--   represents the cartesian product of zero cyclic groups and
--   
--   <pre>
--   &gt;&gt;&gt; one () * abg 4 * abg 6 == abg 4 * abg 6
--   True
--   </pre>
--   
--   <b>Examples</b> Checking for smith normal via <a>isSmithNormal</a>:
--   
--   <pre>
--   &gt;&gt;&gt; isSmithNormal (abg 4)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSmithNormal (abg 2 * abg 2)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSmithNormal (abg 17 * abg 51)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSmithNormal (abg 2 * abg 4 * abg 0 ^ 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSmithNormal (abg 5 * abg 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSmithNormal (abg 0 * abg 3 * abg 6)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSmithNormal (abg 1 * abg 4)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isSmithNormal (one ())
--   True
--   </pre>
--   
--   <b>Examples</b> The associated isomorphism in <a>AbHom</a> of a
--   finitely generated abelian group given by <a>isoSmithNormal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; end (isoSmithNormal (abg 3 * abg 5))
--   AbGroup[Z/15]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; end (isoSmithNormal (abg 2 * abg 4 * abg 2))
--   AbGroup[Z/2^2*Z/4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; end (isoSmithNormal (abg 4 * abg 6))
--   AbGroup[Z/2*Z/12]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; end (isoSmithNormal (abg 1))
--   AbGroup[]
--   </pre>
newtype AbGroup
AbGroup :: ProductSymbol ZMod -> AbGroup

-- | the cyclic group of the given order as a finitely generated abelian
--   group.
abg :: N -> AbGroup

-- | checks if the given group is smith normal (see definition
--   <a>AbGroup</a>).
isSmithNormal :: AbGroup -> Bool

-- | the associated dimension for matrices of <a>ZModHom</a>.
abgDim :: AbGroup -> Dim' ZModHom

-- | additive homomorphism between finitely generated abelian groups which
--   are represented by matrices over <a>ZModHom</a>.
newtype AbHom
AbHom :: Matrix ZModHom -> AbHom

-- | the additive homomorphism with the given orientation and
--   <a>ZModHom</a>-entries.
abh :: Orientation AbGroup -> [(ZModHom, N, N)] -> AbHom

-- | the additive homomorphism with the given orientation and
--   <a>Z</a>-entries.
abh' :: Orientation AbGroup -> [(Z, N, N)] -> AbHom

-- | the underlying <a>Z</a>-matrix.
abhz :: AbHom -> Matrix Z

-- | the associated homomorphism between products of <tt><a>abg</a> 0</tt>
--   given by the column - respectively row - length.
zabh :: Matrix Z -> AbHom

-- | the projection <a>AbHomFree</a> as left adjoint.
abhFreeAdjunction :: Adjunction AbHomFree (Matrix Z) AbHom

-- | projection homomorphisms to <tt><a>Matrix</a> <a>Z</a></tt>.
data AbHomFree x y
[AbHomFree] :: AbHomFree AbHom (Matrix Z)
[FreeAbHom] :: AbHomFree (Matrix Z) AbHom

-- | products for <a>AbHom</a>.
abhProducts :: Products n AbHom

-- | sums for <a>AbHom</a>.
abhSums :: Sums n AbHom

-- | the generator for a finitely generated abelian group.
--   
--   <b>Property</b> Let <tt>a</tt> be in <a>AbGroup</a>, then holds <tt>a
--   <a>==</a> g</tt> where <tt><a>Generator</a> (<a>DiagramChainTo</a> g
--   _) _ _ _ _ = <a>abgGeneratorTo</a> a</tt>.
abgGeneratorTo :: AbGroup -> Generator To AbHom

-- | random variable for <a>AbHom</a> given by a density and an
--   orientation.
xAbHom :: Q -> Orientation AbGroup -> X AbHom

-- | random variable of homomorphisms between abelian groups with
--   <a>end</a> equal to the given one.
--   
--   <pre>
--    r s t
--   [f    ] a
--   [     ] b
--   [g h  ] c
--   </pre>
xAbHomTo :: Q -> N -> N -> N -> AbGroup -> X AbHom

-- | random variable of homomorphisms between abelian groups with
--   <a>start</a> equal to the given one.
--   
--   <pre>
--    a b c
--   [f    ] r
--   [g   l] s
--   [h    ] t
--   </pre>
xAbHomFrom :: Q -> N -> N -> N -> AbGroup -> X AbHom

-- | the maximal length of abelian groups for the standard random variable
--   of type <tt><a>X</a> <a>AbGroup</a></tt>.
--   
--   <b>Property</b> <tt>1 <a>&lt;=</a> <a>stdMaxDim</a></tt>.
stdMaxDim :: N

-- | validity of the algebraic structure of <a>AbHom</a>.
prpAbHom :: Statement
instance OAlg.Structure.Multiplicative.Definition.Multiplicative OAlg.AbelianGroup.Definition.AbGroup
instance OAlg.Entity.Definition.Entity OAlg.AbelianGroup.Definition.AbGroup
instance OAlg.Data.Validable.Validable OAlg.AbelianGroup.Definition.AbGroup
instance OAlg.Data.Number.LengthN OAlg.AbelianGroup.Definition.AbGroup
instance GHC.Classes.Ord OAlg.AbelianGroup.Definition.AbGroup
instance GHC.Classes.Eq OAlg.AbelianGroup.Definition.AbGroup
instance OAlg.Entity.Definition.Entity OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Data.Validable.Validable OAlg.AbelianGroup.Definition.AbHom
instance GHC.Classes.Eq OAlg.AbelianGroup.Definition.AbHom
instance GHC.Show.Show OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Entity.Definition.Entity2 OAlg.AbelianGroup.Definition.IsoAbHomMap
instance (Data.Typeable.Internal.Typeable x, Data.Typeable.Internal.Typeable y) => OAlg.Entity.Definition.Entity (OAlg.AbelianGroup.Definition.IsoAbHomMap x y)
instance OAlg.Data.Equal.Eq2 OAlg.AbelianGroup.Definition.IsoAbHomMap
instance GHC.Classes.Eq (OAlg.AbelianGroup.Definition.IsoAbHomMap x y)
instance OAlg.Data.Validable.Validable2 OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Data.Validable.Validable (OAlg.AbelianGroup.Definition.IsoAbHomMap x y)
instance OAlg.Data.Show.Show2 OAlg.AbelianGroup.Definition.IsoAbHomMap
instance GHC.Show.Show (OAlg.AbelianGroup.Definition.IsoAbHomMap x y)
instance GHC.Show.Show (OAlg.AbelianGroup.Definition.AbHomMap x y)
instance GHC.Classes.Eq (OAlg.AbelianGroup.Definition.AbHomMap x y)
instance GHC.Show.Show (OAlg.AbelianGroup.Definition.AbHomFree x y)
instance GHC.Classes.Eq (OAlg.AbelianGroup.Definition.AbHomFree x y)
instance OAlg.Data.Show.Show2 OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Data.Equal.Eq2 OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Data.Validable.Validable (OAlg.AbelianGroup.Definition.AbHomFree x y)
instance OAlg.Data.Validable.Validable2 OAlg.AbelianGroup.Definition.AbHomFree
instance (Data.Typeable.Internal.Typeable x, Data.Typeable.Internal.Typeable y) => OAlg.Entity.Definition.Entity (OAlg.AbelianGroup.Definition.AbHomFree x y)
instance OAlg.Entity.Definition.Entity2 OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Category.Definition.Morphism OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomFree OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomFree OAlg.Structure.Definition.Typ
instance OAlg.Category.Definition.EmbeddableMorphismTyp OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Category.Applicative.Applicative OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Hom.Oriented.Definition.HomOriented OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomFree OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Hom.Multiplicative.Definition.HomMultiplicative OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomFree OAlg.Structure.Fibred.Definition.Fbr
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomFree OAlg.Structure.Fibred.Definition.FbrOrt
instance OAlg.Hom.Fibred.HomFibred OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Hom.Fibred.HomFibredOriented OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomFree OAlg.Structure.Additive.Definition.Add
instance OAlg.Hom.Additive.HomAdditive OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomFree OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Hom.Distributive.HomDistributive OAlg.AbelianGroup.Definition.AbHomFree
instance OAlg.Data.Constructable.Exposable (OAlg.AbelianGroup.Definition.IsoAbHomMap x y)
instance OAlg.Data.Constructable.Constructable (OAlg.AbelianGroup.Definition.IsoAbHomMap x y)
instance OAlg.Category.Definition.Morphism OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Category.Definition.Category OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Category.Definition.Cayleyan2 OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Category.Applicative.Applicative OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.IsoAbHomMap OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.IsoAbHomMap OAlg.Structure.Definition.Typ
instance OAlg.Category.Definition.EmbeddableMorphismTyp OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Hom.Oriented.Definition.HomOriented OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.IsoAbHomMap OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Hom.Multiplicative.Definition.HomMultiplicative OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Category.Definition.Functorial OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Hom.Oriented.Definition.FunctorialHomOriented OAlg.AbelianGroup.Definition.IsoAbHomMap
instance OAlg.Data.Reducible.Reducible (OAlg.AbelianGroup.Definition.PathAbHomMap x y)
instance OAlg.Data.Show.Show2 OAlg.AbelianGroup.Definition.AbHomMap
instance OAlg.Data.Equal.Eq2 OAlg.AbelianGroup.Definition.AbHomMap
instance OAlg.Data.Validable.Validable (OAlg.AbelianGroup.Definition.AbHomMap x y)
instance OAlg.Data.Validable.Validable2 OAlg.AbelianGroup.Definition.AbHomMap
instance (Data.Typeable.Internal.Typeable x, Data.Typeable.Internal.Typeable y) => OAlg.Entity.Definition.Entity (OAlg.AbelianGroup.Definition.AbHomMap x y)
instance OAlg.Entity.Definition.Entity2 OAlg.AbelianGroup.Definition.AbHomMap
instance OAlg.Category.Definition.Morphism OAlg.AbelianGroup.Definition.AbHomMap
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomMap OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomMap OAlg.Structure.Definition.Typ
instance OAlg.Category.Definition.EmbeddableMorphismTyp OAlg.AbelianGroup.Definition.AbHomMap
instance OAlg.Category.Applicative.Applicative OAlg.AbelianGroup.Definition.AbHomMap
instance OAlg.Hom.Oriented.Definition.HomOriented OAlg.AbelianGroup.Definition.AbHomMap
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.AbelianGroup.Definition.AbHomMap OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Hom.Multiplicative.Definition.HomMultiplicative OAlg.AbelianGroup.Definition.AbHomMap
instance OAlg.Structure.Oriented.Definition.Oriented OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Multiplicative.Definition.Multiplicative OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Fibred.Definition.Fibred OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Additive.Definition.Additive OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Additive.Definition.Abelian OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Vectorial.Definition.Vectorial OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Fibred.Definition.FibredOriented OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Distributive.Definition.Distributive OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Algebraic.Definition.Algebraic OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Entity.Natural.Attestable k => OAlg.Entity.Slice.Definition.Sliced (OAlg.Entity.Slice.Free.Free k) OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Data.Generator.XStandardSomeFreeSliceFromLiftable OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Oriented.Definition.XStandardPoint OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Oriented.Definition.XStandardOrtSiteTo OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Oriented.Definition.XStandardOrtSiteFrom OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Structure.Oriented.Definition.XStandardOrtOrientation OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Data.Validable.XStandard OAlg.AbelianGroup.Definition.AbHom
instance GHC.Show.Show OAlg.AbelianGroup.Definition.AbGroup
instance OAlg.Structure.Oriented.Definition.Oriented OAlg.AbelianGroup.Definition.AbGroup
instance OAlg.Structure.Exponential.Exponential OAlg.AbelianGroup.Definition.AbGroup
instance OAlg.Data.Validable.XStandard OAlg.AbelianGroup.Definition.AbGroup


-- | <a>Kernels</a> and <a>Cokernels</a> for homomorphisms between finitely
--   generated abelian groups.
module OAlg.AbelianGroup.KernelsAndCokernels

-- | kernels for <a>AbHom</a>.
abhKernels :: Kernels N1 AbHom

-- | cokernels for <a>AbHom</a>.
abhCokernels :: Cokernels N1 AbHom

-- | isomorphism to its smith normal group.
--   
--   <b>Properties</b> Let <tt>g</tt> be in <a>AbGroup</a>, then holds:
--   
--   <ol>
--   <li><tt><a>start</a> (<a>isoSmithNormal</a> g) <a>==</a> g</tt>.</li>
--   <li><tt><a>end</a> (<a>isoSmithNormal</a> g)</tt> is smith normal (see
--   definition <a>AbGroup</a>).</li>
--   </ol>
isoSmithNormal :: AbGroup -> Inv AbHom

-- | the cokernel-kernel adjunction for a given <tt><a>Free</a>
--   <b>k</b></tt>.
abhSliceFreeAdjunction :: Attestable k => Free k AbHom -> Adjunction (SliceCokernelKernel (Free k) AbHom) (SliceFactor From (Free k) AbHom) (SliceFactor To (Free k) AbHom)
instance OAlg.Entity.Natural.Attestable k => OAlg.Entity.Slice.Adjunction.SliceCokernelTo (OAlg.Entity.Slice.Free.Free k) OAlg.AbelianGroup.Definition.AbHom
instance OAlg.Entity.Natural.Attestable k => OAlg.Entity.Slice.Adjunction.SliceKernelFrom (OAlg.Entity.Slice.Free.Free k) OAlg.AbelianGroup.Definition.AbHom


-- | validity of abelian groups.
module OAlg.AbelianGroup.Proposition

-- | validity for abelian groups.
prpAbelianGroups :: Statement
