-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Algebraic structures on oriented entities and limits as a tool kit to solve algebraic problems.
--   
--   Basic definition of algebraic structures on oriented entities.
--   
--   First of all we define <a>entities</a>. Based on them and since we
--   look at algebra through the lens of categories, we define
--   <a>oriented</a> structures on which, by means of a suitable partially
--   defined multiplication, <a>multiplicative</a> structures are defined.
--   If one provides such a multiplicative structure with a matching
--   <a>additive</a> structure, one obtains <a>distributive</a> structures
--   on which matrices are build. If an additive structure is provided with
--   a matching scalar multiplication, <a>vectorial</a> structures are
--   obtained, which then form - together with the distributive structures
--   - the basis for <a>algebraic</a> structures
--   
--   <a>Limits</a> - in context of categories - serve as a backbone for
--   solving algebraic problems, e. g. finding all solutions of the
--   equation <tt>a * x == 0</tt> is given by the <a>kernel</a> of
--   <tt>a</tt>.
--   
--   Particular attention is paid to the <a>duality</a> of concepts -
--   viewed through the lens of categories - so that the implementation of
--   the dual concept could be traced back to the original one to avoid
--   duplicate or redundant implementation efforts.
--   
--   A central feature in this package is that all functions defined here -
--   unless otherwise stated - are total and means <i>if the input values
--   are <a>valid</a> then the resulting value is also valid</i>. Most
--   functions do not check their preconditions. Therefore, all data
--   structures defined here are provided with a property section that is
--   translated into a corresponding <a>statement</a> so that they can be
--   <a>validated</a> as needed. If there is an exception to this rule -
--   such as for partially defined algebraic operators - the rule is
--   extended by <i>if the input values are valid and fulfill the
--   additional required properties, then the resulting value is also
--   valid</i>. Most of the algebraic operators do check there additional
--   required preconditions.
--   
--   Since the algebraic operators - such as <tt>(*)</tt>, <tt>(+)</tt>,
--   <tt>(.)</tt>... - have been redefined here, one should exclude the
--   standard Prelude when using this package, to avoid ambiguity, and use
--   the <a>Prelude</a> provided here.
--   
--   Throughout the descripitions in this package we denote type variables
--   in <b>bold</b> lower case letters to distinguishing them from
--   variables for values of a type.
--   
--   Since we take the view that a value of a data structure or an instance
--   of a class must strictly fulfill the required properties to be valid,
--   Double, for example, has not been implemented as a numerical type.
--   
--   Please see also the README on GitHub at
--   <a>https://github.com/zErichGut/oalg-main/blob/main/oalg-base/README.md</a>
@package oalg-base
@version 1.1.4.0


-- | Actions over a state type, i.e. statefull evaluation.
module OAlg.Control.Action

-- | action over a state <tt><b>s</b></tt>.
newtype Action s x
Action :: (s -> (x, s)) -> Action s x

-- | running an action on the gicen state.
run :: Action s x -> s -> (x, s)

-- | gets the state.
getState :: Action s s

-- | sets the state.
setState :: s -> Action s s
instance GHC.Base.Functor (OAlg.Control.Action.Action s)
instance GHC.Base.Applicative (OAlg.Control.Action.Action s)
instance GHC.Base.Monad (OAlg.Control.Action.Action s)


-- | General algebraic exceptions.
module OAlg.Control.Exception

-- | embedding an exception into <a>SomeOAlgException</a>.
oalgExceptionToException :: Exception e => e -> SomeException

-- | casting an exception to <a>SomeOAlgException</a>.
oalgExceptionFromException :: Exception e => SomeException -> Maybe e

-- | The root exception for all algebraic exceptions.
data SomeOAlgException
SomeOAlgException :: e -> SomeOAlgException

-- | general algebraic exception which are sub exceptions of
--   <a>SomeOAlgException</a>.
data AlgebraicException
AlgebraicException :: String -> AlgebraicException
Undefined :: String -> AlgebraicException
ImplementationError :: String -> AlgebraicException
NoPredecor :: AlgebraicException
InvalidData :: String -> AlgebraicException

-- | message for implementation errors. Mainly used for non-permissible or
--   unreachable patterns.
implementation :: String
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e
displayException :: Exception e => e -> String
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a
instance GHC.Show.Show OAlg.Control.Exception.AlgebraicException
instance GHC.Exception.Type.Exception OAlg.Control.Exception.AlgebraicException
instance GHC.Show.Show OAlg.Control.Exception.SomeOAlgException
instance GHC.Exception.Type.Exception OAlg.Control.Exception.SomeOAlgException


-- | reducing a value to head normal form. This is much weaker then
--   <a>Control.DeepSeq</a>.
module OAlg.Control.HNFData

-- | values in head normal form.
data HNFValue x
HNFValue :: x -> HNFValue x
Failure :: e -> HNFValue x

-- | from head normal form.
--   
--   <b>Property</b> Let <tt>x'</tt> be in <tt><a>HNFValue</a>
--   <b>x</b></tt> then holds:
--   
--   <ol>
--   <li>If <tt>x'</tt> matches <tt><a>HNFValue</a> x</tt> then the result
--   of <tt><a>fromHNFValue</a> x'</tt> is <tt>x</tt>.</li>
--   <li>If <tt>x'</tt> matches <tt><a>Failure</a> e</tt> then evaluation
--   <tt><a>fromHNFValue</a> x'</tt> will end up in a throwing
--   <tt>e</tt>.</li>
--   </ol>
fromHNFValue :: HNFValue x -> x

-- | data reducible to head normal form.
class HNFData x

-- | tries to reduce a value to its head normal form, throwing an
--   <a>Exception</a> for undefined values.
rhnf :: HNFData x => x -> ()

-- | tries to reduce a value <tt>x</tt> to its head normal form. If the
--   reduction ends up in a <a>SomeException</a> <tt>e</tt> then this will
--   be catched and <tt><a>Failure</a> e</tt> will be returned, otherwise
--   @<a>HNFValue</a> will be returned.
hnfValue :: HNFData x => x -> IO (HNFValue x)
instance GHC.Show.Show x => GHC.Show.Show (OAlg.Control.HNFData.HNFValue x)
instance OAlg.Control.HNFData.HNFData ()
instance OAlg.Control.HNFData.HNFData GHC.Types.Bool
instance OAlg.Control.HNFData.HNFData [x]
instance GHC.Base.Functor OAlg.Control.HNFData.HNFValue


-- | A monad to express solving algebraic problems which may fail.
--   
--   <b>Note</b> To express algebraic unsolvable - e.g determine the
--   multiplicative inverse of 0 - one should only use the
--   <tt><a>failure</a></tt> mechanism from this module (see examples in
--   <tt><a>solvable</a></tt>).
module OAlg.Control.Solver

-- | monad to solve algebraic problems which may fail because it is not
--   solvable or ...
data Solver x

-- | throwing exception in to <tt><a>Solver</a></tt> to express unsolvable.
failure :: Exception e => e -> Solver x

-- | handling exception.
--   
--   <b>Note</b> Only exceptions expressed via the <tt><a>failure</a></tt>
--   mechanism can be handled by <a>handle</a>!
handle :: Exception e => Solver x -> (e -> Solver x) -> Solver x

-- | extracting the solution from the solver. If during solving an
--   exception <tt>e</tt> occurs, then <tt>e</tt> will be thrown via the
--   regular <tt>throw</tt> mechanism of <tt><a>Exception</a></tt>.
--   
--   <b>Note</b> <tt>solve</tt> extracts the solution lazy!
solve :: Solver x -> x

-- | checks for solvability of a algebraic problem represented be a solver
--   <tt>s</tt> (see also <tt><a>solve</a></tt>).
solvable :: Solver r -> Bool
instance GHC.Show.Show x => GHC.Show.Show (OAlg.Control.Solver.Solver x)
instance GHC.Base.Functor OAlg.Control.Solver.Solver
instance GHC.Base.Applicative OAlg.Control.Solver.Solver
instance GHC.Base.Monad OAlg.Control.Solver.Solver


-- | constructing values by there <a>Form</a>..
module OAlg.Data.Constructable

-- | types with an associated <i>form</i>, which serves as a
--   <i>blueprint</i> to construct a corresponding value.
--   
--   A common setting for this structure is a module with a reducible type
--   <b><tt>f</tt></b> (see <tt><a>Reducible</a></tt>) with public
--   constructors - which serves as a form to be filled out - and in the
--   same module a type <tt>e</tt> with a private constructor - lets say
--   <tt>E</tt> - to hold the <a>reduced</a> <tt>f</tt>. Than an
--   implementation would be
--   
--   <pre>
--   make f = E (reduce f)
--   </pre>
--   
--   and
--   
--   <pre>
--   form (E f) = f
--   </pre>
--   
--   <b>Property</b> Let <b><tt>x</tt></b> be an instance of the class
--   <a>Constructable</a> than holds: For all <tt>x</tt> in
--   <b><tt>x</tt></b> holds: <tt><a>make</a> (<a>form</a> x) <a>==</a>
--   x</tt>.
class Exposable x => Constructable x

-- | constructor.
make :: Constructable x => Form x -> x

-- | restriction of a <tt>f</tt> in <tt><a>Form</a> <b>x</b> -&gt;
--   <a>Form</a> <b>y</b></tt>.
cmap :: (Constructable x, Constructable y) => (Form x -> Form y) -> x -> y

-- | types with an associated <i>form</i> type and a function <a>form</a>
--   which exposes its values to its <i>form</i>.
class Exposable x where {
    
    -- | the form.
    type Form x;
}

-- | the associated form.
form :: Exposable x => x -> Form x

-- | restriction of a <tt>f</tt> in <tt><a>Form</a> <b>x</b> -&gt; y</tt>.
restrict :: Exposable x => (Form x -> y) -> x -> y


-- | data admitting a kind of duality.
module OAlg.Data.Dualisable

-- | the assigned dual kind.
type family Dual (x :: k) :: k

-- | admitting a duality.
--   
--   <b>Property</b> Let <b><tt>x</tt></b> be <a>Dualisable</a>, than
--   holds: <a>toDual</a> is a bijection with its inverse <a>fromDual</a>.
class Dualisable x
toDual :: Dualisable x => x -> Dual x
fromDual :: Dualisable x => Dual x -> x

-- | <a>fromDual</a> enriched with a parameterized type <b><tt>p</tt></b>
--   which serves as a proxy - e.g. <a>Proxy</a> or <a>Id</a> will serve -
--   and will not be evaluated. It serves for the type checker to pick the
--   right <a>fromDual</a>.
fromDual' :: Dualisable x => p x -> Dual x -> x

-- | admitting reflection.
--   
--   <b>Property</b> Let <b><tt>x</tt></b> be <a>Reflexive</a>, than holds:
--   
--   <ol>
--   <li><a>toBidual</a> is a bijection with its inverse
--   <a>fromBidual</a>.</li>
--   </ol>
class Reflexive x
toBidual :: Reflexive x => x -> Dual (Dual x)
fromBidual :: Reflexive x => Dual (Dual x) -> x

-- | <a>fromBidual</a> enriched with a parameterized type <b><tt>p</tt></b>
--   which serves as a proxy - e.g. <tt>Proxy</tt> or <a>Id</a> will serve
--   - and will not be evaluated. It serves for the type checker to pick
--   the right <a>fromBidual</a>.
fromBidual' :: Reflexive x => p x -> Dual (Dual x) -> x

-- | transposable types..
--   
--   <b>Property</b> Let <b><tt>x</tt></b> be a <a>Transposable</a>, then
--   holds: For all <tt>x</tt> in <b><tt>x</tt></b> holds:
--   <tt><a>transpose</a> (<a>transpose</a> x) <a>==</a> x</tt>.
class Transposable x
transpose :: Transposable x => x -> x

-- | concept of the sites <a>From</a> and <a>To</a>.
data Site
From :: Site
To :: Site

-- | concept of sides <a>LeftSide</a> and <a>RightSide</a>
data Side
LeftSide :: Side
RightSide :: Side

-- | concept of the directions <a>LeftToRight</a> and <a>RightToLeft</a>.
data Direction
LeftToRight :: Direction
RightToLeft :: Direction
instance GHC.Enum.Bounded OAlg.Data.Dualisable.Site
instance GHC.Enum.Enum OAlg.Data.Dualisable.Site
instance GHC.Classes.Ord OAlg.Data.Dualisable.Site
instance GHC.Classes.Eq OAlg.Data.Dualisable.Site
instance GHC.Show.Show OAlg.Data.Dualisable.Site
instance GHC.Enum.Bounded OAlg.Data.Dualisable.Side
instance GHC.Enum.Enum OAlg.Data.Dualisable.Side
instance GHC.Classes.Ord OAlg.Data.Dualisable.Side
instance GHC.Classes.Eq OAlg.Data.Dualisable.Side
instance GHC.Show.Show OAlg.Data.Dualisable.Side
instance GHC.Enum.Bounded OAlg.Data.Dualisable.Direction
instance GHC.Enum.Enum OAlg.Data.Dualisable.Direction
instance GHC.Classes.Ord OAlg.Data.Dualisable.Direction
instance GHC.Classes.Eq OAlg.Data.Dualisable.Direction
instance GHC.Show.Show OAlg.Data.Dualisable.Direction
instance OAlg.Data.Dualisable.Transposable OAlg.Data.Dualisable.Direction
instance OAlg.Data.Dualisable.Transposable OAlg.Data.Dualisable.Side
instance OAlg.Data.Dualisable.Transposable OAlg.Data.Dualisable.Site


-- | equality on values.
module OAlg.Data.Equal
class () => Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool

-- | equal.
eql :: (a -> a -> Ordering) -> a -> a -> Bool

-- | not greater than.
ngt :: (a -> a -> Ordering) -> a -> a -> Bool

-- | equality on values for one parameterized types.
class Eq1 p
eq1 :: Eq1 p => p x -> p x -> Bool
eq1 :: (Eq1 p, Eq (p x)) => p x -> p x -> Bool

-- | equality on values for two parameterized types.
--   
--   <b>Note</b> We use this class meanly in the context of <a>Path</a>.
class Eq2 h
eq2 :: Eq2 h => h x y -> h x y -> Bool
eq2 :: (Eq2 h, Eq (h x y)) => h x y -> h x y -> Bool
instance OAlg.Data.Equal.Eq1 Data.Proxy.Proxy


-- | identical predicate.
module OAlg.Data.Identity

-- | identical predicate.
newtype Id x
Id :: x -> Id x

-- | deconstructs <a>Id</a>.
fromId :: Id x -> x

-- | transforming a <tt>f :: x -&gt; <a>Id</a> y</tt> to a <tt>f' :: x
--   -&gt; i z</tt>.
trafoFromId :: (y -> i z) -> (x -> Id y) -> x -> i z

-- | transforming a <tt>f :: x -&gt; y</tt> to a <tt>f' :: x -&gt; Id
--   y</tt>.
trafoToId :: (x -> y) -> x -> Id y
instance Data.Foldable.Foldable OAlg.Data.Identity.Id
instance GHC.Base.Functor OAlg.Data.Identity.Id
instance GHC.Enum.Bounded x => GHC.Enum.Bounded (OAlg.Data.Identity.Id x)
instance GHC.Enum.Enum x => GHC.Enum.Enum (OAlg.Data.Identity.Id x)
instance GHC.Classes.Ord x => GHC.Classes.Ord (OAlg.Data.Identity.Id x)
instance GHC.Classes.Eq x => GHC.Classes.Eq (OAlg.Data.Identity.Id x)
instance GHC.Read.Read x => GHC.Read.Read (OAlg.Data.Identity.Id x)
instance GHC.Show.Show x => GHC.Show.Show (OAlg.Data.Identity.Id x)


-- | Maybe.
module OAlg.Data.Maybe

-- | <tt>just p a <a>==</a> <a>Just</a> a</tt> if and only if <tt>p a</tt>.
just :: (a -> Bool) -> a -> Maybe a

-- | gets all the <a>Just</a>s - if there are any.
exstJust :: [Maybe v] -> Maybe [v]


-- | <a>Data.Ord</a> enriched with some additional elements.
module OAlg.Data.Ord

-- | comparing according to the mapped values.
fcompare :: Ord i => (a -> i) -> a -> a -> Ordering

-- | comparing according to the given ordering relation on the mapped
--   values.
wcompare :: (w -> w -> Ordering) -> (a -> w) -> a -> a -> Ordering

-- | the <i>reverse</i> ordering
coCompare :: (a -> a -> Ordering) -> a -> a -> Ordering

-- | comparing of pairs.
compare2 :: (a -> a -> Ordering) -> (b -> b -> Ordering) -> (a, b) -> (a, b) -> Ordering

-- | sorting according to the first component.
sortFst :: Ord a => [(a, b)] -> [(a, b)]

-- | sorting according to the first component.
sortFstBy :: (a -> a -> Ordering) -> [(a, b)] -> [(a, b)]

-- | sorting according to the second component.
sortSnd :: Ord b => [(a, b)] -> [(a, b)]

-- | sorting according to the second component.
sortSndBy :: (b -> b -> Ordering) -> [(a, b)] -> [(a, b)]

-- | the closer of a linear ordered <tt><b>x</b></tt>.
data Closer x
NegInf :: Closer x
It :: x -> Closer x
PosInf :: Closer x

-- | the minimum of the items of a list, i.e. the biggest lower bound.
--   
--   <b>Property</b> Let <tt>xs</tt> be in <tt>[<b>x</b>]</tt> for a linear
--   ordered <tt><b>x</b></tt>, then holds: For all <tt>x</tt> in
--   <tt>xs</tt> holds: <tt><a>cmin</a> xs <a>&lt;=</a> <a>It</a> x</tt>.
cmin :: Ord x => [x] -> Closer x

-- | the maximum of the items of a list, i.e. the smallest upper bound.
--   
--   <b>Property</b> Let <tt>xs</tt> be in <tt>[<b>x</b>]</tt> for a linear
--   ordered <tt><b>x</b></tt>, then holds: For all <tt>x</tt> in
--   <tt>xs</tt> holds: <tt><a>It</a> x <a>&lt;=</a> <a>cmax</a> xs</tt>.
cmax :: Ord x => [x] -> Closer x

-- | <tt>(l,u) = <a>cspan</a> xs</tt> where <tt>l</tt> is the minimum and
--   <tt>u</tt> the maximum of the items in <tt>xs</tt>.
--   
--   <b>Example</b>
--   
--   <pre>
--   &gt;&gt;&gt; cspan "aeb"
--   (It 'a',It 'e')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cspan ""
--   (PosInf,NegInf)
--   </pre>
cspan :: Ord x => [x] -> Span x

-- | the span type.
type Span x = (Closer x, Closer x)

-- | <tt><a>enumSpan</a> i0 h</tt> enumerates the index, starting by
--   <tt>i0</tt> to <tt>h</tt>.
enumSpan :: (Enum i, Ord i) => i -> Closer i -> [i]

-- | partially ordered types.
--   
--   <b>Properties</b> Let <tt><b>a</b></tt> be an instance of <a>POrd</a>,
--   then holds:
--   
--   <ol>
--   <li>For all <tt>x</tt> in <tt><b>a</b></tt> holds: <tt>x
--   <a>&lt;&lt;=</a> x</tt>.</li>
--   <li>For all <tt>x</tt>, <tt>y</tt> in <tt><b>a</b></tt> holds: If
--   <tt>x <a>&lt;&lt;=</a> y</tt> and <tt>y <a>&lt;&lt;=</a> x</tt> then
--   <tt>x <a>==</a> y</tt>.</li>
--   <li>For all <tt>x</tt>, <tt>y</tt>, <tt>z</tt> in <tt><b>a</b></tt>
--   holds: If <tt>x <a>&lt;&lt;=</a> y</tt> and <tt>y <a>&lt;&lt;=</a>
--   z</tt> then <tt>x <a>&lt;&lt;=</a> z</tt>.</li>
--   </ol>
class Eq a => POrd a
(<<=) :: POrd a => a -> a -> Bool
infix 4 <<=
instance GHC.Classes.Ord x => GHC.Classes.Ord (OAlg.Data.Ord.Closer x)
instance GHC.Classes.Eq x => GHC.Classes.Eq (OAlg.Data.Ord.Closer x)
instance GHC.Read.Read x => GHC.Read.Read (OAlg.Data.Ord.Closer x)
instance GHC.Show.Show x => GHC.Show.Show (OAlg.Data.Ord.Closer x)


-- | reducing values to there canonical value.
module OAlg.Data.Reducible

-- | types admitting reducible values.
--   
--   <b>Definition</b> <tt><a>reduce</a> e</tt> is called the
--   <b><i>algebraic value</i></b> of <tt>e</tt>.
--   
--   Reducing an <tt>e</tt> twice yield the 'same' value and the idea is
--   that in an algebraic calculation it will be 'safe' to substitute any
--   occurrence of <tt>e</tt> by its reduced value, i.e. both calculations
--   will yield the same result.
--   
--   <b>Property</b> Let <tt><b>e</b></tt> be a reducible type admitting
--   equality, then for all <tt>e</tt> in <tt><b>e</b></tt> holds:
--   <tt><a>reduce</a> (<a>reduce</a> e) == <a>reduce</a> e</tt>.
class Reducible e

-- | reducing <tt>e</tt> to its algebraic value.
--   
--   <b>Note</b> The default implementation is <tt><a>reduce</a> =
--   <a>id</a></tt>.
reduce :: Reducible e => e -> e

-- | reduces <tt>x</tt> by the given rules until no more reductions are
--   applicable.
reduceWith :: (x -> Rdc x) -> x -> x

-- | composition of two reductions.
(>>>=) :: (x -> Rdc x) -> (x -> Rdc x) -> x -> Rdc x
infixr 1 >>>=

-- | <a>Action</a> according to the state type <a>RdcState</a>.
type Rdc = Action RdcState

-- | reduction state.
data RdcState

-- | no reduction has been applied.
Unchanged :: RdcState

-- | a reduction has been applied.
Changed :: RdcState

-- | indicates that a term has the given reduction step, i.e. returns the
--   given value and sets the state to <a>Changed</a>.
reducesTo :: x -> Rdc x
instance GHC.Enum.Bounded OAlg.Data.Reducible.RdcState
instance GHC.Enum.Enum OAlg.Data.Reducible.RdcState
instance GHC.Classes.Ord OAlg.Data.Reducible.RdcState
instance GHC.Classes.Eq OAlg.Data.Reducible.RdcState
instance GHC.Read.Read OAlg.Data.Reducible.RdcState
instance GHC.Show.Show OAlg.Data.Reducible.RdcState


-- | showing data with some auxiliary functions.
module OAlg.Data.Show
class () => Show a
showsPrec :: Show a => Int -> a -> ShowS
show :: Show a => a -> String
showList :: Show a => [a] -> ShowS

-- | inserting the given value in between the elements of the given list.
--   
--   <b>Examples</b>
--   
--   <pre>
--   &gt;&gt;&gt; tween ',' "12345"
--   "1,2,3,4,5"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tween ',' ""
--   ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tween ',' "1"
--   "1"
--   </pre>
tween :: a -> [a] -> [a]

-- | inserting the given list in between the elements of the given list and
--   joining the result.
--   
--   <b> Example</b>
--   
--   <pre>
--   &gt;&gt;&gt; jtween ";" ["abcd","efg"]
--   "abcd;efg"
--   </pre>
jtween :: [a] -> [[a]] -> [a]

-- | showable for one parameterized types.
class Show1 p
show1 :: Show1 p => p x -> String
show1 :: (Show1 p, Show (p x)) => p x -> String

-- | showable for two parameterized types.
--   
--   <b>Note</b> We use this class mearly in the context of <a>Path</a>.
class Show2 h
show2 :: Show2 h => h a b -> String
show2 :: (Show2 h, Show (h a b)) => h a b -> String
type String = [Char]
data () => Char
class () => Read a
read :: Read a => String -> a
instance OAlg.Data.Show.Show1 Data.Proxy.Proxy


-- | predicate for the opposite.
module OAlg.Data.Opposite

-- | Predicate for the opposite of a type <tt><b>x</b></tt>.
newtype Op x
Op :: x -> Op x

-- | from <tt><a>Op</a> x</tt>.
fromOp :: Op x -> x

-- | from <tt><a>Op</a> (<a>Op</a> x)</tt>.
fromOpOp :: Op (Op x) -> x

-- | Predicat for the opposite of a two parametrized type <tt><b>h</b></tt>
--   where the two parameters <tt><b>x</b></tt> and <tt><b>y</b></tt> are
--   switched
newtype Op2 h x y
Op2 :: h y x -> Op2 h x y
instance GHC.Classes.Eq x => GHC.Classes.Eq (OAlg.Data.Opposite.Op x)
instance GHC.Read.Read x => GHC.Read.Read (OAlg.Data.Opposite.Op x)
instance GHC.Show.Show x => GHC.Show.Show (OAlg.Data.Opposite.Op x)
instance OAlg.Data.Show.Show2 h => OAlg.Data.Show.Show2 (OAlg.Data.Opposite.Op2 h)
instance OAlg.Data.Equal.Eq2 h => OAlg.Data.Equal.Eq2 (OAlg.Data.Opposite.Op2 h)


-- | disjoint union of data.
module OAlg.Data.Either
data () => Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | disjoint union of two parameterized data types.
data Either2 f g a b
[Left2] :: f a b -> Either2 f g a b
[Right2] :: g a b -> Either2 f g a b
instance (OAlg.Data.Show.Show2 f, OAlg.Data.Show.Show2 g) => OAlg.Data.Show.Show2 (OAlg.Data.Either.Either2 f g)
instance (OAlg.Data.Show.Show2 f, OAlg.Data.Show.Show2 g) => GHC.Show.Show (OAlg.Data.Either.Either2 f g x y)
instance (OAlg.Data.Equal.Eq2 f, OAlg.Data.Equal.Eq2 g) => OAlg.Data.Equal.Eq2 (OAlg.Data.Either.Either2 f g)


-- | application on values.
module OAlg.Category.Applicative

-- | family of types having a representation in <tt>(-&gt;)</tt>.
class Applicative h

-- | application.
amap :: Applicative h => h a b -> a -> b

-- | right associative application on values.
($) :: Applicative h => h a b -> a -> b
infixr 0 $

-- | family of types having a representation in <tt>f a -&gt; f b</tt>.
class Applicative1 h f

-- | application.
amap1 :: Applicative1 h f => h a b -> f a -> f b
instance GHC.Base.Functor f => OAlg.Category.Applicative.Applicative1 (->) f
instance OAlg.Category.Applicative.Applicative (->)
instance (OAlg.Category.Applicative.Applicative f, OAlg.Category.Applicative.Applicative g) => OAlg.Category.Applicative.Applicative (OAlg.Data.Either.Either2 f g)


-- | verbosity on showing.
module OAlg.Control.Verbose

-- | shows <tt>a</tt> in the context of verbosity.
class Show a => Verbose a

-- | the default implementation is: <tt>vshow v a = vshowStr
--   (<a>mnString</a> v) (show a)</tt>
vshow :: Verbose a => Verbosity -> a -> String

-- | kinds of verbosity.
data Verbosity
Low :: Verbosity
Middle :: Verbosity
High :: Verbosity
Full :: Verbosity
Pretty :: Verbosity

-- | verbosely showing a string by the given length.
--   
--   <b>Example</b>
--   
--   <pre>
--   &gt;&gt;&gt; vshowStr (Just 3) "123456789"
--   "123.."
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; vshowStr Nothing "123456789"
--   "123456789"
--   </pre>
vshowStr :: Maybe Int -> String -> String

-- | default length for a string representation in context of verbosity.
mnString :: Verbosity -> Maybe Int

-- | verbosely showing a list by the given length.
--   
--   <b>Examples</b>
--   
--   <pre>
--   &gt;&gt;&gt; vshowList Full (Just 3) "[" "]" "abcdef"
--   "['a','b','c'..]"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; vshowList Low (Just 3) "{" "}" ["abcdef","ghijklmn","op","qrst","uvwxyz"]
--   "{['a','b'..],['g','h'..],['o','p']..}"
--   </pre>
vshowList :: Verbose a => Verbosity -> Maybe Int -> String -> String -> [a] -> String

-- | default number of entries for a list representation in context of
--   verbosity.
mnList :: Verbosity -> Maybe Int

-- | tagging for showing percentage of a <a>Double</a>.
newtype Percent x
Percent :: x -> Percent x

-- | showing a double as percent with the given precision.
--   
--   <b>Example</b>
--   
--   <pre>
--   &gt;&gt;&gt; showPercent 2 0.912837
--   " 91.28%"
--   </pre>
showPercent :: Int -> Double -> String
instance GHC.Enum.Bounded OAlg.Control.Verbose.Verbosity
instance GHC.Enum.Enum OAlg.Control.Verbose.Verbosity
instance GHC.Classes.Ord OAlg.Control.Verbose.Verbosity
instance GHC.Classes.Eq OAlg.Control.Verbose.Verbosity
instance GHC.Show.Show OAlg.Control.Verbose.Verbosity
instance GHC.Show.Show x => GHC.Show.Show (OAlg.Control.Verbose.Percent x)
instance OAlg.Control.Verbose.Verbose (OAlg.Control.Verbose.Percent GHC.Types.Double)
instance OAlg.Control.Verbose.Verbose GHC.Types.Char
instance OAlg.Control.Verbose.Verbose GHC.Types.Int
instance OAlg.Control.Verbose.Verbose GHC.Num.Integer.Integer
instance OAlg.Control.Verbose.Verbose a => OAlg.Control.Verbose.Verbose [a]
instance OAlg.Control.Verbose.Verbose GHC.Types.Double
instance OAlg.Control.Verbose.Verbose ()
instance (OAlg.Control.Verbose.Verbose a, OAlg.Control.Verbose.Verbose b) => OAlg.Control.Verbose.Verbose (a, b)
instance (OAlg.Control.Verbose.Verbose a, OAlg.Control.Verbose.Verbose b, OAlg.Control.Verbose.Verbose c) => OAlg.Control.Verbose.Verbose (a, b, c)
instance (OAlg.Control.Verbose.Verbose a, OAlg.Control.Verbose.Verbose b, OAlg.Control.Verbose.Verbose c, OAlg.Control.Verbose.Verbose d) => OAlg.Control.Verbose.Verbose (a, b, c, d)
instance (OAlg.Control.Verbose.Verbose a, OAlg.Control.Verbose.Verbose b, OAlg.Control.Verbose.Verbose c, OAlg.Control.Verbose.Verbose d, OAlg.Control.Verbose.Verbose e) => OAlg.Control.Verbose.Verbose (a, b, c, d, e)
instance (OAlg.Control.Verbose.Verbose a, OAlg.Control.Verbose.Verbose b, OAlg.Control.Verbose.Verbose c, OAlg.Control.Verbose.Verbose d, OAlg.Control.Verbose.Verbose e, OAlg.Control.Verbose.Verbose f) => OAlg.Control.Verbose.Verbose (a, b, c, d, e, f)


-- | singleton types having exactly one value.
module OAlg.Data.Singleton

-- | types <tt><b>s</b></tt> with exactly one value which is called the
--   <b><i>unit</i></b> of <tt><b>s</b></tt>.
class Singleton s
unit :: Singleton s => s

-- | one parameterized types <tt><b>s</b></tt> with exactly one element for
--   each <tt><b>x</b></tt> which is called the <b><i>unit1</i></b> of
--   <tt><b>s</b> <b>x</b></tt>.
class Singleton1 s
unit1 :: Singleton1 s => s x
instance OAlg.Data.Singleton.Singleton1 Data.Proxy.Proxy
instance OAlg.Data.Singleton.Singleton ()
instance OAlg.Data.Singleton.Singleton (Data.Proxy.Proxy t)
instance OAlg.Data.Singleton.Singleton u => OAlg.Data.Singleton.Singleton (a -> u)


-- | parameterized types with at most on constructor.
module OAlg.Data.Singular

-- | parameterized types with at most on constructor.
--   
--   <b>Definition</b> A type function <tt><b>p</b></tt> is called
--   <b><i>singular</i></b> if and only if for each type <tt><b>x</b></tt>
--   there is at most one constructor for <tt><b>p</b> <b>x</b></tt>.
class Eq1 p => Singular p

-- | equivalence of witnesses in <tt><b>p</b> <b>x</b></tt>.
--   
--   <b>Note</b> <tt>p <a>&lt;==&gt;</a> q</tt> returns either <a>True</a>
--   or an <a>ImplementationError</a> will be thrown.
(<==>) :: Singular p => p x -> p x -> Bool
instance OAlg.Data.Singular.Singular Data.Proxy.Proxy


-- | a tool kit for making statistics.
module OAlg.Data.Statistics

-- | makes the statistics of the given list of wight, value pairs.
mkStatisticW :: Ord x => [x -> String] -> [(Int, x)] -> (Int, [(Double, [String], x)])

-- | makes the statistics of the given list of values.
mkStatistic :: Ord x => [x -> String] -> [x] -> (Int, [(Double, [String], x)])

-- | puts the statistics of the given list of wight, values pairs.
putStatisticW :: (Show x, Ord x) => [x -> String] -> [(Int, x)] -> IO ()

-- | puts the statistics of the given list of values.
putStatistic :: (Show x, Ord x) => [x -> String] -> [x] -> IO ()


-- | binary trees for lookup.
module OAlg.Data.Tree

-- | binary tree with node element in <tt><b>i</b></tt> and leaf element in
--   <tt><b>x</b></tt>.
data Tree i x
Node :: i -> Tree i x -> Tree i x -> Tree i x
Leaf :: x -> Tree i x

-- | lookup a value in a binary tree.
lookup :: Ord i => Tree i x -> i -> x


module OAlg.Data.TypeLits


-- | introducing the idiom <a>Hom</a>.
module OAlg.Hom.Definition

-- | parameterized constraint that the values of the type <tt><b>h</b>
--   <b>x</b> <b>y</b></tt> admit the constraints of a homomorphisms
--   between the structures given by <tt>s</tt>.
type family Hom s (h :: Type -> Type -> Type) :: Constraint


-- | introducing the idiom of <a>Structure</a>s as parameterized
--   constraints.
module OAlg.Structure.Definition

-- | parameterized constraint for a type <tt><b>x</b></tt>.
type family Structure s x :: Constraint

-- | attest that the type <tt><b>x</b></tt> admits the constrains given by
--   the parameter <tt><b>s</b></tt>.
data Struct s x
[Struct] :: Structure s x => Struct s x

-- | transforming structural attests.
class Transformable s t
tau :: Transformable s t => Struct s x -> Struct t x

-- | transforming structural attests.
class Transformable1 f s
tau1 :: Transformable1 f s => Struct s x -> Struct s (f x)

-- | helper class to avoid undecidable instances.
class Transformable1 Op s => TransformableOp s

-- | helper class to avoid undecidable instances.
class Transformable s Typ => ForgetfulTyp s

-- | <a>Typeable</a> structures.
data Typ

-- | type for ordered structures.
data Ord'
instance GHC.Show.Show (OAlg.Structure.Definition.Struct s x)
instance GHC.Classes.Eq (OAlg.Structure.Definition.Struct s x)
instance OAlg.Structure.Definition.Transformable s s
instance OAlg.Structure.Definition.Transformable s (*)
instance OAlg.Structure.Definition.Transformable s OAlg.Structure.Definition.Typ => Data.Type.Equality.TestEquality (OAlg.Structure.Definition.Struct s)
instance OAlg.Data.Show.Show1 (OAlg.Structure.Definition.Struct s)
instance OAlg.Data.Equal.Eq1 (OAlg.Structure.Definition.Struct s)
instance OAlg.Data.Singular.Singular (OAlg.Structure.Definition.Struct s)


-- | boolean structure for multivalent logic.
module OAlg.Data.Boolean.Definition

-- | types with a <a>Boolean</a> structure, allowing multivalent logic.
--   
--   <b>Note</b> Every <a>Enum</a> type which is also <a>Bounded</a> has a
--   natural implementation as <tt><a>false</a> = <a>minBound</a></tt>,
--   <tt><a>true</a> = <a>maxBound</a></tt>, <tt>(<a>||</a>) =
--   <a>max</a></tt>, <tt>(<a>&amp;&amp;</a>) = <a>min</a></tt> (as there
--   are min and max bounds the operator (<a>||</a>) and
--   <tt>(<a>&amp;&amp;</a>)</tt> should be implemented with a lazy variant
--   of <a>min</a> and <a>max</a>) and <tt><a>not</a> b = <a>toEnum</a>
--   (<a>fromEnum</a> <a>maxBound</a> <a>-</a> <a>fromEnum</a> t)</tt>.
class Boolean b
false :: Boolean b => b
true :: Boolean b => b
not :: Boolean b => b -> b
(||) :: Boolean b => b -> b -> b
or :: Boolean b => [b] -> b
(&&) :: Boolean b => b -> b -> b
and :: Boolean b => [b] -> b
(~>) :: Boolean b => b -> b -> b
(<~>) :: Boolean b => b -> b -> b
eqvl :: Boolean b => [b] -> b
infixr 2 ||
infixr 3 &&
infixr 1 ~>
infixr 1 <~>
data () => Bool
False :: Bool
True :: Bool
otherwise :: Bool

-- | type representing <a>Boolean</a> structures.
data Bol
instance OAlg.Data.Boolean.Definition.Boolean GHC.Types.Bool


-- | canonical mappings between two types.
module OAlg.Data.Canonical

-- | canonical embedding from <tt><b>a</b></tt> in to <tt><b>b</b></tt>.
--   
--   <b>Property</b>
--   
--   <ol>
--   <li><a>inj</a> is injective.</li>
--   <li>if the two types <tt><b>a</b></tt> and <tt><b>b</b></tt> are also
--   <tt><a>Projectible</a> <b>a</b> <b>b</b></tt> then <tt><a>prj</a>
--   <a>.</a> <a>inj</a></tt> is the identical mapping.</li>
--   </ol>
class Embeddable a b

-- | canonical injetion from <tt>a</tt> in to <tt>b</tt>.
inj :: Embeddable a b => a -> b

-- | canonical projection from <tt>b</tt> on to <tt>a</tt>.
--   
--   <b>Property</b>
--   
--   <ol>
--   <li><a>prj</a> is surjective.</li>
--   <li>if the two types <tt><b>a</b></tt> and <tt><b>b</b></tt> are also
--   <tt><a>Projectible</a> <b>a</b> <b>b</b></tt> then <tt><a>prj</a>
--   <a>.</a> <a>inj</a></tt> is the identical mapping.</li>
--   </ol>
class Projectible a b

-- | canonical projection from <tt>b</tt> on to <tt>a</tt>
prj :: Projectible a b => b -> a
instance (OAlg.Data.Canonical.Projectible a a', OAlg.Data.Canonical.Projectible b b') => OAlg.Data.Canonical.Projectible (a, b) (a', b')
instance (OAlg.Data.Canonical.Projectible a a', OAlg.Data.Canonical.Projectible b b', OAlg.Data.Canonical.Projectible c c') => OAlg.Data.Canonical.Projectible (a, b, c) (a', b', c')
instance (OAlg.Data.Canonical.Embeddable a a', OAlg.Data.Canonical.Embeddable b b') => OAlg.Data.Canonical.Embeddable (a, b) (a', b')
instance (OAlg.Data.Canonical.Embeddable a a', OAlg.Data.Canonical.Embeddable b b', OAlg.Data.Canonical.Embeddable c c') => OAlg.Data.Canonical.Embeddable (a, b, c) (a', b', c')
instance OAlg.Data.Boolean.Definition.Boolean b => OAlg.Data.Canonical.Embeddable GHC.Types.Bool b


-- | basic number types.
module OAlg.Data.Number

-- | natural numbers <tt>0, 1, 2..</tt>.
data N

-- | <tt>a &gt;- b = a - b</tt> if <tt>b &lt;= a</tt>, otherwise a
--   <tt><a>Undefined</a> <a>SubtrahendToBig</a></tt> exception will be
--   thrown.
(>-) :: N -> N -> N
infixl 6 >-

-- | types admitting a length.
class LengthN x
lengthN :: LengthN x => x -> N

-- | takes the first <tt>n</tt> elements of the list.
takeN :: N -> [a] -> [a]

-- | splits a list in left and right part according to the given number.
splitAtN :: N -> [x] -> ([x], [x])

-- | integers <tt> ..-1, 0, 1, 2.. </tt>.
data Z
data () => Integer
data () => Int

-- | modulo for <a>Int</a>.
modInt :: Int -> Int -> Int

-- | division for <a>Int</a>
divInt :: Int -> Int -> Int

-- | rational numbers <tt>q = z<a>%</a>n</tt> with <tt><a>numerator</a> q
--   == z</tt> and <tt><a>denominator</a> q == n</tt>.
data Q

-- | Forms the ratio of two integral numbers.
(%) :: Z -> N -> Q
infix 7 %

-- | numerator of a rational.
--   
--   <b>Example</b>
--   
--   <pre>
--   &gt;&gt;&gt; denominator (3/2)
--   3
--   </pre>
numerator :: Q -> Z

-- | denominator of a rational.
--   
--   <b>Example</b>
--   
--   <pre>
--   &gt;&gt;&gt; denominator (3/2)
--   2
--   </pre>
denominator :: Q -> N
class () => Enum a
succ :: Enum a => a -> a
pred :: Enum a => a -> a
toEnum :: Enum a => Int -> a
fromEnum :: Enum a => a -> Int
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]
enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | enumeration.
--   
--   <pre>
--   &gt;&gt;&gt; enum 3 6 :: [N]
--    [3,4,5,6]
--   </pre>
enum :: (Ord i, Enum i) => i -> i -> [i]
instance Control.DeepSeq.NFData OAlg.Data.Number.N
instance GHC.Real.Integral OAlg.Data.Number.N
instance GHC.Real.Real OAlg.Data.Number.N
instance GHC.Ix.Ix OAlg.Data.Number.N
instance GHC.Classes.Ord OAlg.Data.Number.N
instance GHC.Classes.Eq OAlg.Data.Number.N
instance Control.DeepSeq.NFData OAlg.Data.Number.Z
instance GHC.Real.Real OAlg.Data.Number.Z
instance GHC.Real.Integral OAlg.Data.Number.Z
instance GHC.Enum.Enum OAlg.Data.Number.Z
instance GHC.Num.Num OAlg.Data.Number.Z
instance GHC.Ix.Ix OAlg.Data.Number.Z
instance GHC.Classes.Ord OAlg.Data.Number.Z
instance GHC.Classes.Eq OAlg.Data.Number.Z
instance Control.DeepSeq.NFData OAlg.Data.Number.Q
instance GHC.Real.Fractional OAlg.Data.Number.Q
instance GHC.Real.RealFrac OAlg.Data.Number.Q
instance GHC.Real.Real OAlg.Data.Number.Q
instance GHC.Enum.Enum OAlg.Data.Number.Q
instance GHC.Num.Num OAlg.Data.Number.Q
instance GHC.Classes.Ord OAlg.Data.Number.Q
instance GHC.Classes.Eq OAlg.Data.Number.Q
instance GHC.Show.Show OAlg.Data.Number.Q
instance OAlg.Data.Canonical.Embeddable OAlg.Data.Number.Z OAlg.Data.Number.Q
instance OAlg.Data.Canonical.Projectible OAlg.Data.Number.Z OAlg.Data.Number.Q
instance OAlg.Data.Canonical.Embeddable OAlg.Data.Number.N OAlg.Data.Number.Q
instance OAlg.Data.Canonical.Projectible OAlg.Data.Number.N OAlg.Data.Number.Q
instance OAlg.Data.Dualisable.Transposable OAlg.Data.Number.Q
instance GHC.Show.Show OAlg.Data.Number.Z
instance OAlg.Data.Canonical.Embeddable GHC.Types.Int OAlg.Data.Number.Z
instance OAlg.Data.Canonical.Projectible GHC.Types.Int OAlg.Data.Number.Z
instance OAlg.Data.Canonical.Embeddable GHC.Num.Integer.Integer OAlg.Data.Number.Z
instance OAlg.Data.Canonical.Projectible GHC.Num.Integer.Integer OAlg.Data.Number.Z
instance OAlg.Data.Canonical.Embeddable OAlg.Data.Number.N OAlg.Data.Number.Z
instance OAlg.Data.Canonical.Projectible OAlg.Data.Number.N OAlg.Data.Number.Z
instance OAlg.Data.Dualisable.Transposable OAlg.Data.Number.Z
instance OAlg.Data.Number.LengthN [x]
instance GHC.Show.Show OAlg.Data.Number.N
instance OAlg.Data.Canonical.Embeddable OAlg.Data.Number.N GHC.Num.Integer.Integer
instance OAlg.Data.Canonical.Projectible OAlg.Data.Number.N GHC.Num.Integer.Integer
instance GHC.Num.Num OAlg.Data.Number.N
instance GHC.Enum.Enum OAlg.Data.Number.N
instance OAlg.Data.Dualisable.Transposable OAlg.Data.Number.N


-- | Random variables for stochastical validation.
module OAlg.Data.X

-- | random variable over <b><tt>x</tt></b>, possibly <a>XEmpty</a>. Let
--   <b><tt>x</tt></b> be a type and <tt>xx</tt> in <tt><a>X</a>
--   <b>x</b></tt>, then we use the idiom <tt>x</tt> <i><b>is in the range
--   of</b></i> <tt>xx</tt> if there exist a <tt>o</tt> in <a>Omega</a>
--   such that <tt>x</tt> is an element of <tt><a>samples</a> xx o</tt>.
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>For the empty set <tt>O</tt> there is exactly one sigma algebra,
--   i.e. the power set of the empty set <tt>O</tt>, and for every set
--   <tt>X</tt> there is exactly one measurable function <tt>O -&gt;
--   X</tt>, i.e. the empty function, and hence exactly one random variable
--   over <tt>O</tt>.</li>
--   <li>To not run into non terminating programs, we restrict the
--   implementation of <tt>xa <a>&gt;&gt;=</a> f</tt> to a maximal number
--   of iterations to find a suitable sample in <tt>xa</tt> for which <tt>f
--   a</tt> is not empty. If the iterations exceed this maximum number, a
--   <a>ProbablyEmpty</a> exception will be thrown.</li>
--   </ol>
data X x
XEmpty :: X x

-- | infinite list of randomly picked samples of <tt>xx</tt> according to a
--   initial omega <tt>o</tt>. If <tt>xx</tt> is empty then the result will
--   be <tt>'[]'</tt>.
samples :: X x -> Omega -> [x]

-- | gets a list of randomly picked samples.
getSamples :: N -> X x -> IO [x]

-- | the first element of <tt><a>samples</a> xx o</tt>. If <tt>xx</tt> is
--   empty then a <a>IsEmpty</a> exception will be thrown.
sample :: X x -> Omega -> x

-- | the mean value of <tt>n</tt>-samples according the state <tt>s</tt>.
meanValue :: Fractional x => Int -> X x -> Omega -> x

-- | A possible state of the <i>world</i>. It is used for
--   <tt><a>run</a></tt> or <tt><a>samples</a></tt> to generate randomly
--   values.
data Omega

-- | makes a state.
mkOmega :: Int -> Omega

-- | gets randomly a state.
getOmega :: IO Omega

-- | random variable of <a>Omega</a>.
xOmega :: X Omega

-- | uniformly distributed random variable of <a>Int</a>s.
xInt :: X Int

-- | uniformly distributed random variable of <a>Int</a>s in the given
--   range. If the lower bound is greater then the upper bound the result
--   will be <a>XEmpty</a>.
xIntB :: Int -> Int -> X Int

-- | uniformly distributed random variable of <a>Word</a>s.
xWord :: X Word

-- | uniformly distributed random variable of <a>Word</a>s in the given
--   range. If the lower bound is greater then the upper bound the result
--   will be <a>XEmpty</a>.
xWordB :: Word -> Word -> X Word

-- | uniformly distributed random variable of <a>Integer</a>s.
xInteger :: X Integer

-- | uniformly distributed random variable of <a>Integer</a>s in the given
--   range. If the lower bound is greater then the upper bound the result
--   will be <a>XEmpty</a>.
xIntegerB :: Integer -> Integer -> X Integer

-- | uniformly distributed random variable of <a>Char</a>s.
xChar :: X Char

-- | uniformly distributed random variable of <a>Char</a>s in the given
--   range. If the lower bound is greater then the upper bound the result
--   will be <a>XEmpty</a>.
xCharB :: Char -> Char -> X Char

-- | uniformly distributed random variable of <a>Double</a>s.
xDouble :: X Double

-- | uniformly distributed random variable of <a>Double</a>s in the given
--   range. If the lower bound is greater then the upper bound the result
--   will be <a>XEmpty</a>.
xDoubleB :: Double -> Double -> X Double

-- | uniformly distributed random variable of a <a>Bounded</a> <a>Enum</a>
--   in the range <a>minBound</a> to <a>maxBound</a>.
xEnum :: (Enum a, Bounded a) => X a

-- | uniformly distributed random variable of a <a>Enum</a> in the given
--   range. If the lower bound is greater then the upper bound the result
--   will be <a>XEmpty</a>.
xEnumB :: Enum a => a -> a -> X a

-- | uniformly distributed random variable of <a>Bool</a>s.
xBool :: X Bool

-- | random variable for pairs.
xTupple2 :: X a -> X b -> X (a, b)

-- | random variable for triples.
xTupple3 :: X a -> X b -> X c -> X (a, b, c)

-- | random variable of list with the given length for non empty random
--   variables. Otherwise the result will be <a>XEmpty</a>.
xTakeN :: N -> X x -> X [x]

-- | random variable of lists with a length between the given bounds.
xTakeB :: N -> N -> X x -> X [x]

-- | random variable of list.
xList :: [X x] -> X [x]

-- | <tt>xOneOf xs</tt> is the random variable of <tt>x</tt>s in
--   <tt>xs</tt> with a uniformly distribution of the <tt>xi</tt>s, where
--   <tt>0 &lt; length xs</tt>. If <tt>xs == []</tt> then <a>XEmpty</a>
--   will be the result.
xOneOf :: [a] -> X a

-- | as <a>xOneOf</a>.
xOneOfX :: [X a] -> X a

-- | <tt>xOneOfW [(w1,x1)..(wn,xn)]</tt> is the random variable of
--   <tt>x</tt>s in <tt>[x1,x2,..xn]</tt> with a distribution of the
--   <tt>xi</tt>s of <tt>pi = wi/s</tt>, where <tt>0 &lt; n</tt>, <tt>s =
--   w1+w2+..+wn</tt> and <tt>0 &lt;= wi</tt> for <tt>i = 1..n</tt>. If
--   <tt>n == 0</tt> then <a>XEmpty</a> will be the result.
xOneOfW :: [(Q, a)] -> X a

-- | as <a>xOneOfW</a>.
xOneOfXW :: [(Q, X a)] -> X a

-- | uniformly distributed random variable in the given range.
xN :: X N

-- | uniformly distributed random variable in the given range. If the lower
--   bound is greater then the upper bound the result will be
--   <a>XEmpty</a>.
xNB :: N -> N -> X N

-- | uniformly distributed random variable of <a>Z</a>.
xZ :: X Z

-- | uniformly distributed random variable of <a>Z</a> in the given bounds.
--   If the lower bound is greater then the upper bound the result will be
--   <a>XEmpty</a>.
xZB :: Z -> Z -> X Z

-- | uniformly distributed random variable of <a>Q</a>.
xQ :: X Q

-- | a strict and head recursive version of <a>sum</a>.
sum' :: Num x => [x] -> x

-- | puts the distribution according of the given number of samples.
putDistribution :: (Show x, Ord x) => Int -> X x -> Omega -> IO ()

-- | puts the distribution according to the given <i>aspects</i> and the
--   given number of samples.
putDistribution' :: (Show x, Ord x) => [x -> String] -> Int -> X x -> Omega -> IO ()

-- | puts the distribution of according the given number of samples.
putDistributionIO :: (Show x, Ord x) => Int -> X (IO x) -> Omega -> IO ()

-- | puts the distribution according of the given number of samples.
putDstr :: (x -> [String]) -> Int -> X x -> IO ()

-- | showing the constructor as an aspect.
aspCnstr :: Show x => x -> String

-- | Exceptions for random variables.
data XException
ProbablyEmpty :: String -> XException
IsEmpty :: XException
instance GHC.Show.Show OAlg.Data.X.XException
instance GHC.Show.Show OAlg.Data.X.Omega
instance OAlg.Control.HNFData.HNFData (OAlg.Data.X.X x)
instance GHC.Base.Functor OAlg.Data.X.X
instance GHC.Base.Applicative OAlg.Data.X.X
instance GHC.Base.Monad OAlg.Data.X.X
instance Control.Monad.Fail.MonadFail OAlg.Data.X.X
instance GHC.Base.Alternative OAlg.Data.X.X
instance GHC.Base.MonadPlus OAlg.Data.X.X
instance GHC.Classes.Eq OAlg.Data.X.Omega
instance GHC.Exception.Type.Exception OAlg.Data.X.XException


-- | categories of morphisms. We adapted the concept of categories form
--   <a>Category</a> to better cover our needs.
module OAlg.Category.Definition

-- | category of morphisms.
--   
--   <b>Properties</b> Let <b><tt>c</tt></b> be a type instance of the
--   class <a>Category</a>, then holds:
--   
--   <ol>
--   <li>For all types <b><tt>x</tt></b>, <b><tt>y</tt></b> and <tt>f</tt>
--   in <b><tt>c</tt></b> <b><tt>x</tt></b> <b><tt>y</tt></b> holds:
--   <tt><a>cOne</a> (<a>range</a> f) <a>.</a> f = f</tt> and <tt>f
--   <a>.</a> <a>cOne</a> (<a>domain</a> f) = f</tt>.</li>
--   <li>For all types <b><tt>w</tt></b>, <b><tt>x</tt></b>,
--   <b><tt>y</tt></b>, <b><tt>z</tt></b> and <tt>f</tt> in
--   <b><tt>c</tt></b> <b><tt>x</tt></b> <b><tt>w</tt></b>, <tt>g</tt> in
--   <b><tt>c</tt></b> <b><tt>y</tt></b> <b><tt>x</tt></b>, <tt>h</tt> in
--   <b><tt>c</tt></b> <b><tt>z</tt></b> <b><tt>y</tt></b> holds: <tt>f
--   <a>.</a> (g <a>.</a> h) = (f <a>.</a> g) <a>.</a> h</tt>.</li>
--   </ol>
class Morphism c => Category c

-- | the identity morphism for an eligible <b><tt>x</tt></b>.
cOne :: Category c => Struct (ObjectClass c) x -> c x x
(.) :: Category c => c y z -> c x y -> c x z
infixr 9 .

-- | the <a>cOne</a> to a given <tt><a>Struct</a> (<a>ObjectClass</a>
--   <b>c</b>)</tt>. The type <tt><b>p c</b></tt> serves only as proxy and
--   <a>cOne'</a> is lazy in it.
--   
--   <b>Note</b> As <a>ObjectClass</a> may be a non-injective type family,
--   the type checker needs some times a little bit more information to pic
--   the right <a>cOne</a>.
cOne' :: Category c => p c -> Struct (ObjectClass c) x -> c x x

-- | the identity map.
id :: x -> x

-- | the constant map given by a value in <tt><b>b</b></tt>.
--   
--   <b>Property</b> Let <tt>y</tt> be in <tt><b>b</b></tt> then for all
--   <tt>x</tt> in <tt><b>a</b></tt> holds: <tt><a>const</a> y x</tt> is
--   identical to <tt>y</tt>.
const :: b -> a -> b

-- | currying a map.
curry :: ((a, b) -> c) -> a -> b -> c

-- | uncurrying a map.
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | the first component of the pair.
fst :: (a, b) -> a

-- | the second component of the pair.
snd :: (a, b) -> b

-- | currying a map.
curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d

-- | uncurrying a map.
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d

-- | category of isomorphisms.
--   
--   <b>Property</b> Let <b><tt>c</tt></b> be a type instance of
--   <a>Cayleyan2</a>, then holds: For all types <b><tt>x</tt></b>,
--   <b><tt>y</tt></b> and <tt>f</tt> in <b><tt>c</tt></b>
--   <b><tt>x</tt></b> <b><tt>y</tt></b> holds: <tt>(<a>invert2</a> f
--   <a>.</a> f) == <a>cOne</a> (<a>domain</a> f)</tt> and <tt>(f <a>.</a>
--   <a>invert2</a> f) == <a>cOne</a> (<a>range</a> f)</tt> where <tt>(==)
--   = <a>eq2</a></tt>.
class (Category c, Eq2 c) => Cayleyan2 c
invert2 :: Cayleyan2 c => c x y -> c y x

-- | morphism.
class Morphism m where {
    
    -- | the object class.
    type ObjectClass m;
}

-- | attests, that the types <tt><b>x</b></tt> and <tt><b>y</b></tt>
--   fulfill the constraints given by <tt><a>Homomorphous</a>
--   (<a>ObjectClass</a> <b>m</b>) <b>x</b> <b>y</b></tt>, i.e both fulfill
--   the constraints given by <tt><a>Structure</a> (<a>ObjectClass</a>
--   <b>m</b>) <b>x</b></tt> and <tt><a>Structure</a> (<a>ObjectClass</a>
--   <b>m</b>) <b>y</b></tt> respectively.
homomorphous :: Morphism m => m x y -> Homomorphous (ObjectClass m) x y

-- | attests that the domain type <tt><b>x</b></tt> fulfills the
--   constraints given by <tt><a>Structure</a> (<a>ObjectClass</a>
--   <b>m</b>) <b>x</b></tt>.
domain :: Morphism m => m x y -> Struct (ObjectClass m) x

-- | attests that the range type <tt><b>y</b></tt> fulfills the constraints
--   given by <tt><a>Structure</a> (<a>ObjectClass</a> <b>m</b>)
--   <b>y</b></tt>.
range :: Morphism m => m x y -> Struct (ObjectClass m) y

-- | attest that both <tt><b>x</b></tt> and <tt><b>y</b></tt> have
--   homomorphous structures, i.e. both admit the same constraints given by
--   the parameter <tt>s</tt>.
data Homomorphous s x y
(:>:) :: Struct s x -> Struct s y -> Homomorphous s x y
infix 5 :>:

-- | transforming homomorphous structural attests.
tauHom :: Transformable s t => Homomorphous s x y -> Homomorphous t x y

-- | transforming homomorphous structural attests.
tau1Hom :: Transformable1 f s => Homomorphous s x y -> Homomorphous s (f x) (f y)

-- | gets for two <a>Typeable</a> types <tt><b>x</b></tt> and
--   <tt><b>x'</b></tt> and for two parameterized types maybe an attest
--   that the domain types are equal.
eqlDomain :: Struct Typ x -> Struct Typ x' -> m x y -> m x' y -> Maybe (x :~: x')

-- | gets for two <a>Typeable</a> types <tt><b>y</b></tt> and
--   <tt><b>y'</b></tt> and for two parameterized types maybe an attest
--   that the range types are equal.
eqlRange :: Struct Typ y -> Struct Typ y' -> m x y -> m x y' -> Maybe (y :~: y')

-- | gets maybe an attest that the two given morphisms types are equal.
eqlMorphism :: Typeable m => Struct Typ x -> Struct Typ x' -> Struct Typ y -> Struct Typ y' -> m x y -> m x' y' -> Maybe (m x y :~: m x' y')

-- | family of types having a representation in <tt>(-&gt;)</tt>.
class Applicative h

-- | application.
amap :: Applicative h => h a b -> a -> b

-- | right associative application on values.
($) :: Applicative h => h a b -> a -> b
infixr 0 $

-- | family of types having a representation in <tt>f a -&gt; f b</tt>.
class Applicative1 h f

-- | application.
amap1 :: Applicative1 h f => h a b -> f a -> f b

-- | representable categories, i.e. covariant functors from an
--   <a>Applicative</a> category <b>c</b> to <tt>(<tt>-&gt;</tt>)</tt>.
--   
--   <b>Properties</b> Let <b><tt>c</tt></b> be a type instance of the
--   class <a>Functorial</a> then holds:
--   
--   <ol>
--   <li>For all types <b><tt>x</tt></b> and <tt>d</tt> in
--   <tt><a>Struct</a> (<a>ObjectClass</a> <b>c</b>) <b>x</b></tt> holds:
--   <tt><a>amap</a> (<a>cOne</a> d) = <a>id</a></tt>.</li>
--   <li>For all types <b><tt>x</tt></b>, <b><tt>y</tt></b>,
--   <b><tt>z</tt></b> and <tt>f</tt> in <b><tt>c</tt></b>
--   <b><tt>y</tt></b> <b><tt>z</tt></b>, <tt>g</tt> in <b><tt>c</tt></b>
--   <b><tt>x</tt></b> <b><tt>y</tt></b> holds: <tt><a>amap</a> (f <a>.</a>
--   g) = <a>amap</a> f <a>.</a> <a>amap</a> g</tt>.</li>
--   </ol>
class (Applicative c, Category c) => Functorial c

-- | forgets the <a>ObjectClass</a> of <b><tt>m</tt></b> and sets it to
--   <b><tt>t</tt></b>, under the condition that the <a>ObjectClass</a> of
--   <b><tt>m</tt></b> is <a>Transformable</a> to <b><tt>t</tt></b>.
data Forget t m x y
[Forget] :: Transformable (ObjectClass m) t => m x y -> Forget t m x y

-- | morphism for which its object class can be embedded into the given
--   structure.
class (Morphism m, Transformable (ObjectClass m) t) => EmbeddableMorphism m t

-- | helper class to avoid undecidable instances.
class EmbeddableMorphism m Typ => EmbeddableMorphismTyp m
instance GHC.Classes.Eq (OAlg.Category.Definition.Homomorphous s x y)
instance GHC.Show.Show (OAlg.Category.Definition.Homomorphous s x y)
instance (OAlg.Category.Definition.Morphism m, OAlg.Structure.Definition.ForgetfulTyp t) => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Category.Definition.Forget t m)
instance OAlg.Category.Definition.EmbeddableMorphismTyp m => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Data.Opposite.Op2 m)
instance (OAlg.Category.Definition.Morphism m, OAlg.Structure.Definition.Transformable s t) => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Category.Definition.Forget s m) t
instance OAlg.Category.Definition.EmbeddableMorphism m t => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Data.Opposite.Op2 m) t
instance OAlg.Data.Show.Show2 m => OAlg.Data.Show.Show2 (OAlg.Category.Definition.Forget t m)
instance OAlg.Data.Show.Show2 m => GHC.Show.Show (OAlg.Category.Definition.Forget t m x y)
instance OAlg.Data.Equal.Eq2 m => OAlg.Data.Equal.Eq2 (OAlg.Category.Definition.Forget t m)
instance OAlg.Data.Equal.Eq2 m => GHC.Classes.Eq (OAlg.Category.Definition.Forget t m x y)
instance OAlg.Category.Definition.Morphism m => OAlg.Category.Definition.Morphism (OAlg.Category.Definition.Forget t m)
instance OAlg.Category.Applicative.Applicative m => OAlg.Category.Applicative.Applicative (OAlg.Category.Definition.Forget t m)
instance OAlg.Category.Definition.Cayleyan2 (OAlg.Category.Definition.Homomorphous m)
instance OAlg.Category.Definition.Cayleyan2 c => OAlg.Category.Definition.Cayleyan2 (OAlg.Data.Opposite.Op2 c)
instance OAlg.Category.Definition.Category (OAlg.Category.Definition.Homomorphous s)
instance OAlg.Category.Definition.Category (->)
instance OAlg.Category.Definition.Category c => OAlg.Category.Definition.Category (OAlg.Data.Opposite.Op2 c)
instance OAlg.Category.Definition.Morphism (OAlg.Category.Definition.Homomorphous s)
instance OAlg.Category.Definition.Morphism (->)
instance OAlg.Category.Definition.Morphism h => OAlg.Category.Definition.Morphism (OAlg.Data.Opposite.Op2 h)
instance (OAlg.Category.Definition.Morphism f, OAlg.Category.Definition.Morphism g, OAlg.Category.Definition.ObjectClass f GHC.Types.~ OAlg.Category.Definition.ObjectClass g) => OAlg.Category.Definition.Morphism (OAlg.Data.Either.Either2 f g)
instance OAlg.Data.Show.Show2 (OAlg.Category.Definition.Homomorphous m)
instance OAlg.Data.Equal.Eq2 (OAlg.Category.Definition.Homomorphous m)


-- | Statements on properties which can be validated via
--   <a>validateStoch</a>. They serve to implement automatic testing (see
--   <a>OAlg.Control.Validate</a>).
--   
--   <b>Examples</b> Deterministic
--   
--   Validation of the valid and invalid statement
--   
--   <pre>
--   &gt;&gt;&gt; getOmega &gt;&gt;= validateStoch SValid 10
--   Valid
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getOmega &gt;&gt;= validateStoch SInvalid 5
--   Invalid
--   </pre>
--   
--   As no stochastic was used to evaluate the two examples, the result is
--   <a>Valid</a> and <a>Invalid</a> respectively!
--   
--   <b>Examples</b> Stochastic
--   
--   Validation of a <a>Forall</a> and <a>Exist</a> statement
--   
--   <pre>
--   &gt;&gt;&gt; getOmega &gt;&gt;= validateStoch (Forall (xIntB 0 10) (\i -&gt; (0 &lt;= i &amp;&amp; i &lt;= 10):?&gt;Params["i":=show i]-- )) 100
--   ProbablyValid
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getOmega &gt;&gt;= validateStoch (Exist (xIntB 0 10) (\i -&gt; (11 &lt;= i):?&gt;Params["i":=show i])) 100
--   ProbablyInvalid
--   </pre>
--   
--   The valuation of these two examples uses the given <a>Omega</a> and
--   <a>Wide</a> of <tt>100</tt> to pick randomly <tt>100</tt> samples of
--   the given random variable <tt><a>xIntB</a> 0 10</tt> and applies these
--   samples to the given test function. The result is <a>ProbablyValid</a>
--   and <a>ProbablyInvalid</a> respectively!
module OAlg.Data.Statement.Definition

-- | statement on properties..
data Statement

-- | the invalid statement.
[SInvalid] :: Statement

-- | the valid statement.
[SValid] :: Statement

-- | checking a boolean.
[:?>] :: Bool -> Message -> Statement

-- | catching an exception.
[Catch] :: Exception e => Statement -> (e -> Statement) -> Statement

-- | not
[Not] :: Statement -> Statement

-- | and
[:&&] :: Statement -> Statement -> Statement

-- | and
[And] :: [Statement] -> Statement

-- | or
[:||] :: Statement -> Statement -> Statement

-- | or
[Or] :: [Statement] -> Statement

-- | implication
[:=>] :: Statement -> Statement -> Statement

-- | implication
[Impl] :: [Statement] -> Statement -> Statement

-- | efinitional equivalence
[:<=>:] :: Label -> Statement -> Statement

-- | equivalence
[:<=>] :: Statement -> Statement -> Statement

-- | equivalence
[Eqvl] :: [Statement] -> Statement

-- | the for all constructor
[Forall] :: X x -> (x -> Statement) -> Statement

-- | the exist constructor.
[Exist] :: X x -> (x -> Statement) -> Statement
infix 4 :?>
infixr 3 :&&
infixr 2 :||
infixr 1 :=>
infixr 1 :<=>
infixr 0 :<=>:

-- | checking for equality.
(.==.) :: Eq a => a -> a -> Statement
infix 4 .==.

-- | checking for inequality.
(./=.) :: Eq a => a -> a -> Statement
infix 4 ./=.

-- | implication without resulting in denied premises for a <a>false</a>
--   premises. This is useful for <i>switch</i> cases.
(|~>) :: Statement -> Statement -> Statement
infixr 1 |~>

-- | convenient catcher for <a>SomeException</a>.
someException :: Statement -> SomeException -> Statement

-- | a labels.
data Label
Label :: String -> Label
Prp :: String -> Label

-- | a message.
data Message

-- | used for relations where no further information is desired or possible
--   to give (see <tt>relRelation</tt> as an example).
MInvalid :: Message

-- | a message
Message :: String -> Message

-- | a list of parameters
Params :: [Parameter] -> Message

-- | type of variables.
type Variable = String

-- | showing the involved parameters of a statement.
data Parameter
[:=] :: Variable -> String -> Parameter

-- | validates the statement according to a given <a>Wide</a> and
--   <a>Omega</a>. For deterministic statements better use
--   <a>validateDet</a> and for non deterministic or to get more
--   information <a>validate</a>.
validateStoch :: Statement -> Wide -> Omega -> IO Valid

-- | the wide for a <a>Forall</a> and <a>Exist</a> resolution.
type Wide = Int

-- | evaluates the value of a statement according a given <a>Wide</a> and
--   <a>Omega</a>.
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>The only reason to valuate a statement in the <a>IO</a> monad is
--   to be able to catch exceptions. Other interactions with the <i>real
--   world</i> during the valuation are not performed.</li>
--   <li>During the evaluation process the given wide and omega will not be
--   changed and as such all <i>same</i> random variables will produce
--   exactly the same samples. This restricts the stochastic, but it is
--   necessary for the sound behavior of the validation of statements.</li>
--   </ol>
value :: Statement -> Wide -> Omega -> IO V

-- | the <a>value</a> of a statement resulting from its validation.
--   <a>Forall</a> and <a>Exist</a> are resolved by finite samples.
data V

-- | determines whether the value is deterministic, i.e. dose not contain a
--   <a>VForall</a> or <a>VExist</a> constructor.
valDeterministic :: V -> Bool

-- | validating a value <tt>v</tt>.
valT :: V -> T

-- | the <i>truth</i> type of a value <tt>v</tt>.
type T = HNFValue Valid

-- | weak form of classical boolean values arising from stochastically
--   performed valuation of <a>Statement</a>s.
--   
--   <b>Definition</b> Let <tt>a</tt>, <tt>b</tt> be in <a>Valid</a>, then
--   we define:
--   
--   <ol>
--   <li><tt><a>not</a> a = <a>toEnum</a> (<a>fromEnum</a> <a>Valid</a>
--   <a>-</a> <a>fromEnum</a> a)</tt>.</li>
--   <li><tt>a <a>||</a> b = max a b</tt>.</li>
--   <li><tt>a <a>&amp;&amp;</a> b = min a b</tt>.</li>
--   <li><tt>a <a>~&gt;</a> b = <a>not</a> a <a>||</a> b</tt>.</li>
--   </ol>
--   
--   <b>Note</b> <tt>min</tt> and <tt>max</tt> are implemented lazy as
--   <a>Valid</a> is bounded. This is important that <a>~&gt;</a> behaves
--   as desired, i.e. for <tt>a <a>~&gt;</a> b</tt> and <tt>a =
--   <a>Invalid</a></tt> then <tt>b</tt> has not to be evaluated, because
--   the maximum is already reached..
data Valid
Invalid :: Valid
ProbablyInvalid :: Valid
ProbablyValid :: Valid
Valid :: Valid

-- | pretty showing a value with the given indentation.
showV :: Indent -> V -> String

-- | the initial indentation given by a indentation string.
indent0 :: String -> Indent

-- | pretty showing the value of a statement according to the given
--   <a>Wide</a> and randomly given <a>Omega</a>.
showVStatement :: Wide -> Statement -> IO ()

-- | validation for <i>deterministic</i> statements.
--   
--   <b>Definition</b> A statement s is called <b><i>deterministic</i></b>
--   if and only if it dose not depend on the stochastic nor on the state
--   of the machine.
--   
--   <b>Examples</b>
--   
--   <pre>
--   &gt;&gt;&gt; validateDet SValid
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; validateDet (Forall xBool (\_ -&gt; SValid))
--   *** Exception: NonDeterministic
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; validateDet (SValid || Exist xInt (\i -&gt; (i==0):?&gt;MInvalid))
--   True
--   </pre>
validateDet :: Statement -> Bool

-- | the list of all relevant tests - i.e <tt>'VDedEqvl l _</tt> where
--   <tt>l = <a>Label</a> _</tt> - together with the number of tests.
tests :: V -> [(Int, SPath)]

-- | path of strings.
type SPath = [String]

-- | number of <a>tests</a>.
cntTests :: V -> Int

-- | reduces true valus to its relevant part.
rdcTrue :: V -> Maybe V

-- | number of <a>tests</a> for true values. <b>Note</b> Before counting
--   the tests they will be first reduced to there relevant part (see
--   <a>rdcTrue</a>).
cntTestsRdcTrue :: V -> Int

-- | reduces false valus to its relevant part.
rdcFalse :: V -> Maybe V

-- | number of <a>tests</a> for false values. <b>Note</b> Before counting
--   the tests they will be first reduced to there relevant part (see
--   <a>rdcFalse</a>).
cntTestsRdcFalse :: V -> Int

-- | reduces ture values - having implications with no conclusions, i.e.
--   denied premises - to its relevant part.
rdcDndPrms :: V -> Maybe V

-- | number of <a>tests</a> for values containing denied premises.
--   <b>Note</b> Before counting the tests they will be first reduced to
--   there relevant part (see <a>rdcDndPrms</a>).
cntTestsRdcDndPrms :: V -> Int

-- | reduces failed values to its relevant part.
rdcFailed :: V -> Maybe V

-- | number of <a>tests</a> for failed values. <b>Note</b> Before counting
--   the tests they will be first reduced to there relevant part (see
--   <a>rdcFailed</a>).
cntTestsRdcFailed :: V -> Int

-- | random variable of valuation values according to the randomly given
--   <a>Wide</a> and <a>Omega</a>.
xValue :: Statement -> X (Wide, Omega) -> X (IO V)

-- | <tt>xWO l h</tt> is the random variable over wide and omgea, where the
--   wide is bounded between <tt>l</tt> and <tt>h</tt>.
xWO :: Wide -> Wide -> X (Wide, Omega)

-- | uniformly distributed random variable of <a>Valid</a>.
xValid :: X Valid

-- | validating exceptions which are sub exceptions from
--   <a>SomeOAlgException</a>.
data ValidateingException
NonDeterministic :: ValidateingException
instance GHC.Show.Show OAlg.Data.Statement.Definition.ValidateingException
instance GHC.Classes.Eq OAlg.Data.Statement.Definition.ValidateingException
instance GHC.Show.Show OAlg.Data.Statement.Definition.Message
instance GHC.Enum.Bounded OAlg.Data.Statement.Definition.Valid
instance GHC.Enum.Enum OAlg.Data.Statement.Definition.Valid
instance GHC.Classes.Ord OAlg.Data.Statement.Definition.Valid
instance GHC.Classes.Eq OAlg.Data.Statement.Definition.Valid
instance GHC.Show.Show OAlg.Data.Statement.Definition.Valid
instance GHC.Show.Show OAlg.Data.Statement.Definition.Parameter
instance GHC.Show.Show OAlg.Data.Statement.Definition.V
instance OAlg.Control.Verbose.Verbose OAlg.Data.Statement.Definition.V
instance Control.DeepSeq.NFData OAlg.Data.Statement.Definition.Valid
instance OAlg.Data.Boolean.Definition.Boolean OAlg.Data.Statement.Definition.Valid
instance OAlg.Data.Canonical.Projectible GHC.Types.Bool OAlg.Data.Statement.Definition.Valid
instance OAlg.Data.Boolean.Definition.Boolean OAlg.Data.Statement.Definition.Statement
instance OAlg.Control.HNFData.HNFData OAlg.Data.Statement.Definition.Statement
instance OAlg.Control.Verbose.Verbose OAlg.Data.Statement.Definition.Message
instance OAlg.Control.Verbose.Verbose OAlg.Data.Statement.Definition.Parameter
instance GHC.Show.Show OAlg.Data.Statement.Definition.Label
instance OAlg.Control.Verbose.Verbose OAlg.Data.Statement.Definition.Label
instance GHC.Exception.Type.Exception OAlg.Data.Statement.Definition.ValidateingException


-- | propositions on boolean structures which must always be true, i.e.
--   tautologies. They serve also to describe the semantic of the boolean
--   operators.
module OAlg.Data.Boolean.Proposition

-- | validity of the <a>Boolean</a> structure of <a>Bool</a>.
prpBool :: Statement

-- | tautologies for <a>Bool</a>.
prpBoolTautologies :: Statement

-- | tautologies on boolean structures.
prpTautologies :: Boolean b => (b -> Statement) -> X b -> X [b] -> Statement

-- | for all <tt>p</tt> holds: <tt><a>not</a> (<a>not</a> p)
--   <a>&lt;~&gt;</a> p</tt>.
prpNotNot :: Boolean b => b -> b

-- | for all <tt>a</tt>, <tt>b</tt> and <tt>c</tt> holds: <tt>(a
--   <a>&amp;&amp;</a> b) <a>&amp;&amp;</a> c <a>&lt;~&gt;</a> a
--   <a>&amp;&amp;</a> (b <a>&amp;&amp;</a> c)</tt>.
prpAndAssoc :: Boolean b => b -> b -> b -> b

-- | for all <tt>a</tt>, <tt>b</tt> and <tt>c</tt> holds: <tt>(a
--   <a>&amp;&amp;</a> b) <a>||</a> c <a>&lt;~&gt;</a> (a <a>||</a> c)
--   <a>&amp;&amp;</a> (b <a>||</a> c)</tt>.
prpAndOr :: Boolean b => b -> b -> b -> b

-- | for all <tt>p</tt> holds: <tt><a>true</a> <a>&amp;&amp;</a> p
--   <a>&lt;~&gt;</a> p</tt>.
prpAndTrue :: Boolean b => b -> b

-- | <tt><a>and</a> [] <a>&lt;~&gt;</a> <a>true</a></tt>.
prpAnd0 :: Boolean b => b

-- | for all <tt>a</tt> and <tt>as</tt> holds: <tt><a>and</a>
--   (a<tt>:</tt>as) <a>&lt;~&gt;</a> a <a>&amp;&amp;</a> <a>and</a>
--   as</tt>.
prpAnds :: Boolean b => b -> [b] -> b

-- | for all <tt>a</tt>, <tt>b</tt> and <tt>c</tt> holds: <tt>(a <a>||</a>
--   b) <a>||</a> c <a>&lt;~&gt;</a> a <a>||</a> (b <a>||</a> c)</tt>.
prpOrAssoc :: Boolean b => b -> b -> b -> b

-- | for all <tt>a</tt>, <tt>b</tt> and <tt>c</tt> holds: <tt>(a <a>||</a>
--   b) <a>&amp;&amp;</a> c <a>&lt;~&gt;</a> (a <a>&amp;&amp;</a> c)
--   <a>||</a> (b <a>&amp;&amp;</a> c)</tt>.
prpOrAnd :: Boolean b => b -> b -> b -> b

-- | <tt><a>or</a> [] <a>&lt;~&gt;</a> <a>false</a></tt>.
prpOr0 :: Boolean b => b

-- | <tt>for all </tt>a<tt> and </tt>as<tt> holds: <a>or</a>
--   (a<tt>:</tt>as) <a>&lt;~&gt;</a> a <a>||</a> <a>or</a> as</tt>.
prpOrs :: Boolean b => b -> [b] -> b

-- | <tt>for all </tt>p<tt> holds: p <a>~&gt;</a> p</tt>.
prpImplRefl :: Boolean b => b -> b

-- | for all <tt>p</tt> holds: <tt><a>false</a> <a>~&gt;</a> (p
--   <a>&lt;~&gt;</a> <a>true</a>)</tt>.
--   
--   i.e. a false premisis implies everithing.
prpImplFalseEverything :: Boolean b => b -> b

-- | for all <tt>a</tt>, <tt>b</tt> and <tt>c</tt> holds: <tt>((a
--   <a>&amp;&amp;</a> b) <a>~&gt;</a> c) <a>&lt;~&gt;</a> (a <a>~&gt;</a>
--   b <a>~&gt;</a> c)</tt>.
prpImplCurry :: Boolean b => b -> b -> b -> b

-- | for all <tt>a</tt>, <tt>b</tt> and <tt>c</tt> holds: <tt>(a
--   <a>~&gt;</a> b) <a>&amp;&amp;</a> (b <a>~&gt;</a> c) <a>~&gt;</a> (a
--   <a>~&gt;</a> c)</tt>.
prpImplTransitive :: Boolean b => b -> b -> b -> b

-- | for all <tt>a</tt> and <tt>b</tt> holds: <tt>(a <a>&lt;~&gt;</a> b)
--   <a>&lt;~&gt;</a> ((a <a>~&gt;</a> b) &amp;&amp; (b <a>~&gt;</a>
--   a))</tt>.
prpEqvlAnd :: Boolean b => b -> b -> b

-- | laziness of <a>and</a>, <a>or</a> and <tt>(<a>~&gt;</a>)</tt>.
prpLazy :: Boolean b => (b -> Statement) -> Statement

-- | lazy evaluation of <a>&amp;&amp;</a>, i.e. <tt><a>false</a>
--   <a>&amp;&amp;</a> <a>undefined</a> <a>&lt;~&gt;</a> <a>false</a></tt>.
--   
--   <b>Note</b> <tt>(<a>undefined</a> <a>&amp;&amp;</a> <a>false</a>)</tt>
--   evaluates to an exception!
prpLazyAnd :: Boolean b => b

-- | lazy evaluationof <a>||</a>, i.e. <tt><a>true</a> <a>||</a>
--   <a>undefined</a></tt>.
prpLazyOr :: Boolean b => b

-- | lazy evaluation of <a>~&gt;</a>, i.e. <tt><a>false</a> <a>:=&gt;</a>
--   <a>undefined</a></tt>.
prpLazyImpl :: Boolean b => b


-- | boolean structure and propositions on them.
module OAlg.Data.Boolean


-- | Propositions on statements.
module OAlg.Data.Statement.Proposition

-- | validity of the logic of <a>Statement</a>..
prpStatement :: Statement

-- | logical tautologies of <a>Statement</a>.
--   
--   <b>Note</b> Validating this proposition produces about 15% denied
--   premises, which is OK.
prpStatementTautologies :: Statement

-- | logical tautologies of <a>Valid</a>.
prpValidTautologies :: Statement

-- | <tt><a>true</a> <a>:?&gt;</a> <a>MInvalid</a></tt>.
prpCheckTrue :: Statement

-- | <tt><a>false</a> <a>:?&gt;</a> <a>MInvalid</a> <a>&lt;~&gt;</a>
--   <a>false</a></tt>.
prpCheckFalse :: Statement

-- | catch algebraic exceptions.
prpCatch :: Statement

-- | <tt><a>prj</a> :: <a>Valid</a> -&gt; <a>Bool</a></tt> is a
--   homomorphism between <a>Boolean</a> structures.
prpPrjHom :: Statement

-- | random variable of statements with the maximal given depth.
xStatement :: Int -> X Statement


module OAlg.Data.Statement


-- | validable values <tt>x</tt>, which can be validated via
--   <tt><a>validate</a> (<a>valid</a> x)</tt>.
module OAlg.Data.Validable

-- | validation of a value of <tt><b>a</b></tt>.
class Validable a
valid :: Validable a => a -> Statement

-- | validation of being reducible to normal form.
rnfValid :: NFData x => x -> Statement

-- | validation of a value of <tt>p x</tt>.
class Validable1 p
valid1 :: Validable1 p => p x -> Statement
valid1 :: (Validable1 p, Validable (p x)) => p x -> Statement

-- | validation of a value of <tt>h x y</tt>.
class Validable2 h
valid2 :: Validable2 h => h x y -> Statement
valid2 :: (Validable2 h, Validable (h x y)) => h x y -> Statement

-- | standard random variable for <b><tt>x</tt></b>.
--   
--   <b>Property</b> For all <tt>x</tt> in the range of <a>xStandard</a>
--   holds: <tt><a>valid</a> x</tt>.
class Validable x => XStandard x
xStandard :: XStandard x => X x

-- | validity of the standard random variable associated to
--   <b><tt>x</tt></b> (<b><tt>p x</tt></b> just serves as proxy and will
--   not be evaluated).
relXStandard :: XStandard x => p x -> Statement
instance OAlg.Data.Validable.Validable x => OAlg.Data.Validable.Validable (OAlg.Data.Opposite.Op x)
instance OAlg.Data.Validable.Validable2 h => OAlg.Data.Validable.Validable2 (OAlg.Data.Opposite.Op2 h)
instance (OAlg.Data.Validable.Validable2 f, OAlg.Data.Validable.Validable2 g) => OAlg.Data.Validable.Validable2 (OAlg.Data.Either.Either2 f g)
instance OAlg.Data.Validable.Validable2 m => OAlg.Data.Validable.Validable2 (OAlg.Category.Definition.Forget t m)
instance OAlg.Data.Validable.Validable2 m => OAlg.Data.Validable.Validable (OAlg.Category.Definition.Forget t m x y)
instance OAlg.Data.Validable.Validable1 Data.Proxy.Proxy
instance OAlg.Data.Validable.Validable1 (OAlg.Structure.Definition.Struct s)
instance OAlg.Data.Validable.XStandard ()
instance OAlg.Data.Validable.XStandard OAlg.Data.Number.N
instance OAlg.Data.Validable.XStandard OAlg.Data.Number.Z
instance OAlg.Data.Validable.XStandard OAlg.Data.Number.Q
instance (OAlg.Data.Validable.XStandard x, OAlg.Data.Validable.Validable y) => OAlg.Data.Validable.Validable (x -> y)
instance OAlg.Data.Validable.Validable ()
instance OAlg.Data.Validable.Validable GHC.Types.Bool
instance OAlg.Data.Validable.Validable OAlg.Data.Statement.Definition.Valid
instance OAlg.Data.Validable.Validable GHC.Types.Char
instance OAlg.Data.Validable.Validable GHC.Types.Int
instance OAlg.Data.Validable.Validable GHC.Num.Integer.Integer
instance OAlg.Data.Validable.Validable (GHC.Real.Ratio GHC.Num.Integer.Integer)
instance OAlg.Data.Validable.Validable OAlg.Data.Number.N
instance OAlg.Data.Validable.Validable OAlg.Data.Number.Z
instance OAlg.Data.Validable.Validable OAlg.Data.Number.Q
instance OAlg.Data.Validable.Validable (Data.Proxy.Proxy x)
instance OAlg.Data.Validable.Validable (OAlg.Structure.Definition.Struct s x)
instance OAlg.Data.Validable.Validable a => OAlg.Data.Validable.Validable (GHC.Maybe.Maybe a)
instance OAlg.Data.Validable.Validable a => OAlg.Data.Validable.Validable [a]
instance (OAlg.Data.Validable.Validable a, OAlg.Data.Validable.Validable b) => OAlg.Data.Validable.Validable (Data.Either.Either a b)
instance (OAlg.Data.Validable.Validable a, OAlg.Data.Validable.Validable b) => OAlg.Data.Validable.Validable (a, b)
instance (OAlg.Data.Validable.Validable a, OAlg.Data.Validable.Validable b, OAlg.Data.Validable.Validable c) => OAlg.Data.Validable.Validable (a, b, c)
instance (OAlg.Data.Validable.Validable a, OAlg.Data.Validable.Validable b, OAlg.Data.Validable.Validable c, OAlg.Data.Validable.Validable d) => OAlg.Data.Validable.Validable (a, b, c, d)
instance (OAlg.Data.Validable.Validable a, OAlg.Data.Validable.Validable b, OAlg.Data.Validable.Validable c, OAlg.Data.Validable.Validable d, OAlg.Data.Validable.Validable e) => OAlg.Data.Validable.Validable (a, b, c, d, e)
instance OAlg.Data.Validable.Validable a => OAlg.Data.Validable.Validable (OAlg.Data.X.X a)


-- | symbols from <a>A</a> to <a>Z</a>. They are mainly used to validate
--   the algebraic structure of <a>Orientation</a>.
module OAlg.Data.Symbol

-- | symbols from <a>A</a> to <a>Z</a>.
data Symbol
A :: Symbol
B :: Symbol
C :: Symbol
D :: Symbol
E :: Symbol
F :: Symbol
G :: Symbol
H :: Symbol
I :: Symbol
J :: Symbol
K :: Symbol
L :: Symbol
M :: Symbol
N :: Symbol
O :: Symbol
P :: Symbol
Q :: Symbol
R :: Symbol
S :: Symbol
T :: Symbol
U :: Symbol
V :: Symbol
W :: Symbol
X :: Symbol
Y :: Symbol
Z :: Symbol

-- | uniformly distributed random variable of <a>Symbol</a>.
xSymbol :: X Symbol
instance GHC.Enum.Bounded OAlg.Data.Symbol.Symbol
instance GHC.Enum.Enum OAlg.Data.Symbol.Symbol
instance GHC.Classes.Ord OAlg.Data.Symbol.Symbol
instance GHC.Classes.Eq OAlg.Data.Symbol.Symbol
instance GHC.Read.Read OAlg.Data.Symbol.Symbol
instance GHC.Show.Show OAlg.Data.Symbol.Symbol
instance Control.DeepSeq.NFData OAlg.Data.Symbol.Symbol
instance OAlg.Data.Validable.Validable OAlg.Data.Symbol.Symbol
instance OAlg.Data.Validable.XStandard OAlg.Data.Symbol.Symbol


-- | definition of entities. All algebraic structures defined here are
--   based on them. They are <b><a>showable</a></b>,
--   <b><a>distinguishable</a></b>, <b><a>validable</a></b> and
--   <b><a>typeable</a></b>.
module OAlg.Entity.Definition

-- | entity.
class (Show a, Eq a, Validable a, Typeable a) => Entity a

-- | indexing <a>Entity</a>s.
data Ent

-- | entity for parameterized types.
class (Show1 a, Eq1 a, Validable1 a, Typeable a) => Entity1 a

-- | entity for two parameterized types.
class (Show2 h, Eq2 h, Validable2 h, Typeable h) => Entity2 h

-- | the empty entity.
data Empty

-- | the empty function.
empty :: Empty -> x

-- | the empty entity2.
data Empty2 a b

-- | the empty function.
empty2 :: Empty2 a b -> x
instance GHC.Show.Show OAlg.Entity.Definition.Empty
instance GHC.Classes.Ord OAlg.Entity.Definition.Empty
instance GHC.Classes.Eq OAlg.Entity.Definition.Empty
instance GHC.Show.Show (OAlg.Entity.Definition.Empty2 a b)
instance GHC.Classes.Eq (OAlg.Entity.Definition.Empty2 a b)
instance OAlg.Entity.Definition.Entity x => OAlg.Entity.Definition.Entity (OAlg.Data.Opposite.Op x)
instance OAlg.Data.Validable.Validable (OAlg.Entity.Definition.Empty2 x y)
instance OAlg.Data.Show.Show2 OAlg.Entity.Definition.Empty2
instance OAlg.Data.Equal.Eq2 OAlg.Entity.Definition.Empty2
instance OAlg.Data.Validable.Validable2 OAlg.Entity.Definition.Empty2
instance OAlg.Entity.Definition.Entity2 OAlg.Entity.Definition.Empty2
instance OAlg.Data.Validable.Validable OAlg.Entity.Definition.Empty
instance OAlg.Entity.Definition.Entity OAlg.Entity.Definition.Empty
instance (OAlg.Entity.Definition.Entity2 f, OAlg.Entity.Definition.Entity2 g) => OAlg.Entity.Definition.Entity2 (OAlg.Data.Either.Either2 f g)
instance (OAlg.Entity.Definition.Entity2 h, Data.Typeable.Internal.Typeable t) => OAlg.Entity.Definition.Entity2 (OAlg.Category.Definition.Forget t h)
instance OAlg.Entity.Definition.Entity1 Data.Proxy.Proxy
instance OAlg.Entity.Definition.Entity ()
instance OAlg.Entity.Definition.Entity GHC.Types.Int
instance OAlg.Entity.Definition.Entity GHC.Num.Integer.Integer
instance OAlg.Entity.Definition.Entity GHC.Types.Char
instance OAlg.Entity.Definition.Entity OAlg.Data.Symbol.Symbol
instance OAlg.Entity.Definition.Entity OAlg.Data.Number.N
instance OAlg.Entity.Definition.Entity OAlg.Data.Number.Z
instance OAlg.Entity.Definition.Entity OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity a => OAlg.Entity.Definition.Entity [a]
instance (OAlg.Entity.Definition.Entity a, OAlg.Entity.Definition.Entity b) => OAlg.Entity.Definition.Entity (a, b)


-- | Validation of <a>Statement</a>s, based on a stochastic approach.
--   
--   <b>Example</b> Deterministic statements
--   
--   <pre>
--   &gt;&gt;&gt; validate (SValid &amp;&amp; (SInvalid || SValid))
--   Valid
--   </pre>
--   
--   The validation shows the following output:
--   
--   <pre>
--   &gt;&gt; Omega (StdGen {unStdGen = SMGen 1872899651221430933 9051984386581193015})
--   &gt;&gt; --------------------------------------------------------------------------------
--   &gt;&gt; Summary
--   &gt;&gt; 1 sample tested where 0 tests are false, having 0 denied premises
--   &gt;&gt; 5 tests with a false ratio of 0% and a denied premises ratio of 0%
--   </pre>
--   
--   From the third line on the number of samples is shown and how many
--   tests over all have been performed to determine the result. As the
--   above statement is obviously deterministic, only one sample has been
--   tested, as the result is independent of the used stochastic.
--   
--   <b>Example</b> Non deterministic statements
--   
--   <pre>
--   &gt;&gt;&gt; validate (Forall (xIntB 0 100) (\i -&gt; (i &lt;= 100) :?&gt; Params["i":=show i]))
--   ProbablyValid
--   </pre>
--   
--   The validation shows the following output:
--   
--   <pre>
--   &gt;&gt; Omega (StdGen {unStdGen = SMGen 8429292192981378265 11527977991108410805})
--   &gt;&gt; --------------------------------------------------------------------------------
--   &gt;&gt; Summary
--   &gt;&gt; 10 samples tested where 0 tests are false, having 0 denied premises
--   &gt;&gt; 94 tests with a false ratio of 0% and a denied premises ratio of 
--   </pre>
--   
--   As this statement is non deterministic, the validation of it pics
--   randomly 10 samples of <a>Omega</a>s and <a>Wide</a>s (see the number
--   of samples in the summery above) - starting from the shown
--   <a>Omega</a> - and uses <a>validateStoch</a> to determine for each
--   sample the result. All this results are combined with the
--   <a>&amp;&amp;</a>-operator to yield the final result.
--   
--   <b>Example</b> Lazy validation
--   
--   <pre>
--   &gt;&gt;&gt; validate (SValid || throw DivideByZero)
--   Valid
--   </pre>
--   
--   <b>Example</b> Denied premises
--   
--   <pre>
--   &gt;&gt;&gt; let s = Forall xInt (\i -&gt; (i == i+1):?&gt;Params["i":=show i]) in validate (s :=&gt; s)
--   Valid
--   </pre>
--   
--   The validation shows the following output:
--   
--   <pre>
--   &gt;&gt; Omega (StdGen {unStdGen = SMGen 1872899651221430933 9051984386581193015})
--   &gt;&gt; --------------------------------------------------------------------------------
--   &gt;&gt; Summary
--   &gt;&gt; 1 sample tested where 0 tests are false, having 4 denied premises
--   &gt;&gt; 7 tests with a false ratio of 0% and a denied premises ratio of 57%
--   </pre>
--   
--   The statement <tt>s</tt> is obviously invalid but the tautology <tt>s
--   <a>:=&gt;</a> s</tt> is valid because of denied premises, which is
--   shown in the summery.
--   
--   <b>Example</b> Invalid statements
--   
--   <pre>
--   &gt;&gt;&gt; validate (Forall (xIntB 0 10) (\i -&gt; (10 &lt; i):?&gt;Params["i":=show i]))
--   Invalid
--   </pre>
--   
--   The validation shows the following output:
--   
--   <pre>
--   &gt;&gt; Omega (StdGen {unStdGen = SMGen 8429292192981378265 11527977991108410805})
--   &gt;&gt; --------------------------------------------------------------------------------
--   for all Invalid
--     and Invalid
--       check Invalid
--         Invalid
--         parameters
--           i := 9
--   
--   &gt;&gt; --------------------------------------------------------------------------------
--   &gt;&gt; Summary
--   &gt;&gt; 1 sample tested where 3 tests are false, having 0 denied premises
--   &gt;&gt; 3 tests with a false ratio of 100% and a denied premises ratio of 0%
--   </pre>
--   
--   where from the third line on the invalid test is shown and the summery
--   shows that in the first sample for <a>Omega</a> and <a>Wide</a> an
--   invalid test has been found.
--   
--   <b>Example</b> Tracking of exceptions
--   
--   <pre>
--   &gt;&gt;&gt; validate (SValid &amp;&amp; (Label "bad" :&lt;=&gt;: throw DivideByZero))
--   *** Exception: FailedStatement divide by zero
--   </pre>
--   
--   The validation shows the following output:
--   
--   <pre>
--   &gt;&gt; Omega (StdGen {unStdGen = SMGen 3069986384088197145 15225250911862971905})
--   &gt;&gt; --------------------------------------------------------------------------------
--   &gt;&gt; failed sample
--   and divide by zero
--     (bad) divide by zero
--       failure divide by zero
--   
--   &gt;&gt; --------------------------------------------------------------------------------
--   &gt;&gt; Summary
--   &gt;&gt; 1 sample tested where 0 tests are false, having 0 denied premises
--   &gt;&gt; 3 tests
--   </pre>
--   
--   The failed sample part of the output shows that in an <i>and</i>
--   construct the component - labeled by <tt>bad</tt> - has been throwing
--   an exception during the validation process.
--   
--   <b>Example</b> Extended stochastic
--   
--   If we validate the obviously false statement
--   
--   <pre>
--   &gt; validate Forall (xIntB 0 1000) (\i -&gt; (i &lt; 1000) :?&gt; Params["i":=show i])
--   </pre>
--   
--   the validation may nevertheless yield <a>ProbablyValid</a> - because
--   all randomly picked <a>Omega</a>s and <a>Wide</a>s may produce only
--   values which are strict smaller then <tt>1000</tt>. To overcome this
--   <i>problem</i> and to get more confidence of the result it is possible
--   to adapt the stochastic and use <tt><a>validateStochastic</a>
--   <a>Massive</a></tt> instead (<a>validate</a> is equivalent to
--   <tt><a>validateStochastic</a> <a>Sparse</a></tt>).
--   
--   <b>Note</b> The here defined validation is highly inspired by the
--   QuickCheck package. But we have chosen to adopt the idea to fit more
--   our needs. For example, if a statement throws an exception, then the
--   occurrence can be tracked. Also we devoted special attention to the
--   logic of statements (as <a>Statement</a> is an instance
--   <a>Boolean</a>, they fulfill all the logical tautologies). For
--   example, the simple tautology <tt>s <a>:=&gt;</a> s</tt> breaks, if
--   you don't take special care during the validating process or if you
--   allow user interactions.
module OAlg.Control.Validate

-- | validates a statement.
validate :: Statement -> IO Valid

-- | short cut for <a>validateDet</a> and should be used mainly in
--   interactiv mode.
validate' :: Statement -> Bool

-- | validates the statement with the configuration given by <a>stdStc</a>,
validateStochastic :: Stochastic -> Statement -> IO Valid

-- | defines the stochastic behavior of <a>validateStochastic</a>.
data Stochastic
Sparse :: Stochastic
Standard :: Stochastic
Massive :: Stochastic

-- | validates a statement according to the given stochastic with showing
--   the statistics.
validateStatistics :: Stochastic -> Statement -> IO Valid

-- | validates the proposition with the given configuration and stochastic.
validateWith :: Cnfg -> Statement -> IO Valid

-- | configuration of validating.
data Cnfg
Cnfg :: Maybe Omega -> Int -> (Int, Int) -> Int -> Int -> Bool -> Int -> Cnfg

-- | initial state.
[cnfOmega] :: Cnfg -> Maybe Omega

-- | number of samples to be validated.
[cnfSamples] :: Cnfg -> Int

-- | range of wide.
[cnfWide] :: Cnfg -> (Int, Int)

-- | maximal time for validateing in seconds.
[cnfMaxDuration] :: Cnfg -> Int

-- | duration between two log entires in seconds.
[cnfLogDuration] :: Cnfg -> Int

-- | <a>True</a> with statistics.
[cnfStatistics] :: Cnfg -> Bool

-- | number of labels to be shown for the statistics over all.
[cnfStcPathLength] :: Cnfg -> Int

-- | result of the validation.
data Result
Result :: Maybe Valid -> Int -> Int -> Int -> Int -> Result
[rsValid] :: Result -> Maybe Valid
[rsValidatedSamples] :: Result -> Int

-- | number of tests over all
[rsTests] :: Result -> Int

-- | number of false tests from a non valid sample
[rsTestsFalse] :: Result -> Int

-- | number of tests from reduced denied premises
[rsTestsRdcDndPrms] :: Result -> Int

-- | standard configuration
stdCnf :: Cnfg

-- | adapts the standard configuration <a>stdCnf</a> according to the given
--   stochastic.
stdStc :: Stochastic -> Cnfg
instance GHC.Show.Show OAlg.Control.Validate.ValidateException
instance GHC.Enum.Bounded OAlg.Control.Validate.Stochastic
instance GHC.Enum.Enum OAlg.Control.Validate.Stochastic
instance GHC.Classes.Ord OAlg.Control.Validate.Stochastic
instance GHC.Classes.Eq OAlg.Control.Validate.Stochastic
instance GHC.Read.Read OAlg.Control.Validate.Stochastic
instance GHC.Show.Show OAlg.Control.Validate.Stochastic
instance GHC.Show.Show OAlg.Control.Validate.Cnfg
instance GHC.Show.Show OAlg.Control.Validate.Result
instance GHC.Exception.Type.Exception OAlg.Control.Validate.ValidateException


-- | category of paths over morphisms.
module OAlg.Category.Path

-- | paths over morphisms.
data Path m x y
[IdPath] :: Struct (ObjectClass m) x -> Path m x x
[:.] :: m y z -> Path m x y -> Path m x z
infixr 9 :.

-- | the opposite path.
toOp2Path :: Morphism m => Path m x y -> Path (Op2 m) y x

-- | from the opposite path.
fromOp2Path :: Morphism m => Path (Op2 m) x y -> Path m y x

-- | composing the morphisms of a path.
compose :: Category m => Path m x y -> m x y

-- | embedding morphisms into paths.
mPath :: Morphism m => m x y -> Path m x y

-- | reversing a path given by the formal <i>inverse</i> function.
reverse :: (Morphism m, Morphism f) => (forall u. Struct (ObjectClass m) u -> Struct (ObjectClass f) u) -> (forall u v. m u v -> f v u) -> Path m x y -> Path f y x

-- | folding from the right.
pthFoldr :: (forall x y. m x y -> f x -> f y) -> f a -> Path m a b -> f b

-- | the length of a path.
pthLength :: Path m x y -> N
instance OAlg.Category.Definition.Morphism m => OAlg.Data.Dualisable.Dualisable (OAlg.Category.Path.Path m x y)
instance OAlg.Data.Show.Show2 m => OAlg.Data.Show.Show2 (OAlg.Category.Path.Path m)
instance OAlg.Data.Show.Show2 (OAlg.Category.Path.Path m) => GHC.Show.Show (OAlg.Category.Path.Path m x y)
instance (OAlg.Category.Definition.Morphism m, OAlg.Data.Validable.Validable2 m) => OAlg.Data.Validable.Validable2 (OAlg.Category.Path.Path m)
instance OAlg.Data.Validable.Validable2 (OAlg.Category.Path.Path m) => OAlg.Data.Validable.Validable (OAlg.Category.Path.Path m x y)
instance (OAlg.Category.Definition.EmbeddableMorphismTyp m, OAlg.Data.Equal.Eq2 m) => OAlg.Data.Equal.Eq2 (OAlg.Category.Path.Path m)
instance OAlg.Data.Equal.Eq2 (OAlg.Category.Path.Path m) => GHC.Classes.Eq (OAlg.Category.Path.Path m x y)
instance (OAlg.Entity.Definition.Entity2 h, OAlg.Category.Definition.EmbeddableMorphismTyp h) => OAlg.Entity.Definition.Entity2 (OAlg.Category.Path.Path h)
instance OAlg.Category.Definition.Morphism m => OAlg.Category.Definition.Morphism (OAlg.Category.Path.Path m)
instance OAlg.Category.Definition.EmbeddableMorphism m t => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Category.Path.Path m) t
instance OAlg.Category.Definition.EmbeddableMorphismTyp m => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Category.Path.Path m)
instance OAlg.Category.Definition.Morphism m => OAlg.Category.Definition.Category (OAlg.Category.Path.Path m)
instance OAlg.Category.Applicative.Applicative m => OAlg.Category.Applicative.Applicative (OAlg.Category.Path.Path m)
instance (OAlg.Category.Applicative.Applicative m, OAlg.Category.Definition.Morphism m) => OAlg.Category.Definition.Functorial (OAlg.Category.Path.Path m)
instance (OAlg.Category.Definition.Cayleyan2 m, OAlg.Category.Definition.EmbeddableMorphismTyp m) => OAlg.Category.Definition.Cayleyan2 (OAlg.Category.Path.Path m)


-- | unification of categories, i.e. projecting morphisms by dropping the
--   parameterization by there <a>domain</a> and <a>range</a>.
module OAlg.Category.Unify

-- | some morphism.
data SomeMorphism m
[SomeMorphism] :: m x y -> SomeMorphism m

-- | some object class.
data SomeObjectClass m
[SomeObjectClass] :: Transformable (ObjectClass m) Typ => Struct (ObjectClass m) x -> SomeObjectClass m

-- | some morphism given by a <a>Site</a>.
data SomeMorphismSite s m x
[SomeMorphismDomain] :: m x y -> SomeMorphismSite From m x
[SomeMorphismRange] :: m x y -> SomeMorphismSite To m y

-- | some path
data SomePath m
[SomePath] :: Path m x y -> SomePath m

-- | embedding.
somePath :: SomePathSite s m x -> SomePath m

-- | some path parameterized either by its <a>domain</a> or <a>range</a>.
data SomePathSite s m x
[SomePathDomain] :: Path m x y -> SomePathSite From m x
[SomePathRange] :: Path m x y -> SomePathSite To m y

-- | some entity <tt>x</tt> in <tt><b>x</b></tt> having the given
--   <tt><a>ObjectClass</a> <b>m</b></tt> as structure.
data SomeEntity m
[SomeEntity] :: Entity x => Struct (ObjectClass m) x -> x -> SomeEntity m

-- | some application.
data SomeApplication h
[SomeApplication] :: h x y -> x -> SomeApplication h
instance GHC.Show.Show (OAlg.Category.Unify.SomeObjectClass m)
instance OAlg.Data.Dualisable.Dualisable (OAlg.Category.Unify.SomeMorphismSite 'OAlg.Data.Dualisable.To m y)
instance OAlg.Category.Definition.Morphism m => OAlg.Data.Dualisable.Dualisable (OAlg.Category.Unify.SomePathSite 'OAlg.Data.Dualisable.To m y)
instance OAlg.Data.Dualisable.Dualisable (OAlg.Category.Unify.SomeObjectClass m)
instance GHC.Classes.Eq (OAlg.Category.Unify.SomeObjectClass m)
instance OAlg.Data.Validable.Validable (OAlg.Category.Unify.SomeObjectClass m)
instance Data.Typeable.Internal.Typeable m => OAlg.Entity.Definition.Entity (OAlg.Category.Unify.SomeObjectClass m)
instance OAlg.Data.Show.Show2 m => GHC.Show.Show (OAlg.Category.Unify.SomePath m)
instance OAlg.Category.Definition.Morphism m => OAlg.Data.Dualisable.Dualisable (OAlg.Category.Unify.SomePath m)
instance OAlg.Data.Show.Show2 m => GHC.Show.Show (OAlg.Category.Unify.SomeMorphism m)
instance (OAlg.Category.Definition.EmbeddableMorphismTyp m, Data.Typeable.Internal.Typeable m, OAlg.Data.Equal.Eq2 m) => GHC.Classes.Eq (OAlg.Category.Unify.SomeMorphism m)
instance OAlg.Data.Validable.Validable2 m => OAlg.Data.Validable.Validable (OAlg.Category.Unify.SomeMorphism m)
instance (OAlg.Category.Definition.EmbeddableMorphismTyp m, OAlg.Entity.Definition.Entity2 m) => OAlg.Entity.Definition.Entity (OAlg.Category.Unify.SomeMorphism m)


-- | propositions on categories.
module OAlg.Category.Proposition

-- | validity of a <a>Category</a>.
prpCategory :: (Category c, Eq2 c, Show2 c) => XCat c -> Statement

-- | random variable for validating <a>Category</a>.
data XCat c
XCat :: X (SomeMorphism c) -> X (SomeCmpb3 c) -> XCat c
[xcSomeMrph] :: XCat c -> X (SomeMorphism c)
[xcSomeCmpb3] :: XCat c -> X (SomeCmpb3 c)

-- | validity according to <a>OAlg.Category.Category#Cat1</a>.
prpCategory1 :: (Category c, Show2 c, Eq2 c) => X (SomeMorphism c) -> Statement

-- | validity according to <a>OAlg.Category.Category#Cat2</a>.
prpCategory2 :: (Category c, Show2 c, Eq2 c) => X (SomeCmpb3 c) -> Statement

-- | some composable morphisms.
data SomeCmpb3 c
[SomeCmpb3] :: c x w -> c y x -> c z y -> SomeCmpb3 c

-- | random variable for some application.
type XAppl h = X (SomeApplication h)

-- | validity of a <a>Functorial</a> category.
prpFunctorial :: (Functorial c, Show2 c) => XFnct c -> Statement

-- | random variable for <a>Functorial</a> categories.
data XFnct c
[XFnct] :: X (SomeEntity c) -> X (SomeCmpbAppl c) -> XFnct c

-- | validity according to <a>OAlg.Category.Category#Fnc1</a>.
prpFunctorial1 :: (Functorial c, Show2 c) => X (SomeEntity c) -> Statement

-- | validity according to <a>OAlg.Category.Category#Fnc2</a>.
prpFunctorial2 :: (Functorial c, Show2 c) => X (SomeCmpbAppl c) -> Statement

-- | some composable morphisms with an applicable value.
data SomeCmpbAppl c
[SomeCmpbAppl] :: (Entity x, Eq z) => c y z -> c x y -> x -> SomeCmpbAppl c

-- | validity of <a>Cayleyan2</a>.
prpCayleyan2 :: (Cayleyan2 c, Show2 c) => X (SomeMorphism c) -> Statement

-- | random variable for validating <a>Category</a>.
xCat :: Category c => XMrphSite s c -> XCat c

-- | random variable of <a>SomeObjectClass</a> and <a>SomeMorphismSite</a>
--   with:
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>The random variable <tt><a>X</a> (<a>SomeObjectClass</a> m)</tt>
--   should have a bias towards non terminal respectively initial object
--   classes. For an implementation see <a>xIsoOpOrtFrom</a>.</li>
--   <li>It is the analogue to <a>XStart</a> at the level of
--   <a>Category</a>s.</li>
--   </ol>
data XMrphSite (s :: Site) m
[XDomain] :: X (SomeObjectClass m) -> (forall x. Struct (ObjectClass m) x -> X (SomeMorphismSite From m x)) -> XMrphSite From m
[XRange] :: X (SomeObjectClass m) -> (forall y. Struct (ObjectClass m) y -> X (SomeMorphismSite To m y)) -> XMrphSite To m

-- | random variable of paths of <a>Morphism</a>s having maximal the given
--   length. If during the randomly build path no terminal respectively
--   initial object class has reached then the resulting path will have the
--   given length.
--   
--   It is the analogue to <a>xStartPathOrt</a> at the level of
--   <a>Category</a>s.
xSomePathSiteMax :: Morphism m => XMrphSite s m -> N -> Struct (ObjectClass m) x -> X (SomePathSite s m x)

-- | derived random variable for some paths.
xSomePathMax :: Morphism m => XMrphSite s m -> N -> X (SomePath m)

-- | constructing random variable for some path site.
xSomePathSite :: Category c => XMrphSite s c -> N -> Struct (ObjectClass c) x -> X (SomePathSite s c x)

-- | constructing random variable for some path.
xSomePath :: Category c => XMrphSite s c -> N -> X (SomePath c)

-- | random variable for <a>Functorial</a> <a>Category</a>s.
xFnct :: (Category c, Transformable (ObjectClass c) Ent) => XFnctMrphSite s c -> XFnct c

-- | random variable for <a>Morphism</a>s for a given <a>Site</a>.
xMrphSite :: XFnctMrphSite s m -> XMrphSite s m

-- | random variable for <a>Functorial</a> <a>Category</a>s.
data XFnctMrphSite s m
[XFnctMrphSite] :: XMrphSite s m -> (forall x. Struct (ObjectClass m) x -> X x) -> XFnctMrphSite s m
instance GHC.Show.Show OAlg.Category.Proposition.XMorphismException
instance GHC.Classes.Eq OAlg.Category.Proposition.XMorphismException
instance OAlg.Data.Dualisable.Dualisable (OAlg.Category.Proposition.XMrphSite 'OAlg.Data.Dualisable.To m)
instance GHC.Exception.Type.Exception OAlg.Category.Proposition.XMorphismException


-- | To avoid ambiguity for the algebraic operators on should
--   <i>exclude</i> the standard <a>Prelude</a> and use this one instead.
module OAlg.Prelude
class a ~# b => (a :: k) ~ (b :: k)
class () => Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a
data () => IO a
putStrLn :: String -> IO ()
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a


-- | concept of <a>Projective</a> and <a>Injective</a>.
module OAlg.Limes.Perspective

-- | concept of <a>Projective</a> and <a>Injective</a>.
data Perspective
Projective :: Perspective
Injective :: Perspective
instance GHC.Enum.Bounded OAlg.Limes.Perspective.Perspective
instance GHC.Enum.Enum OAlg.Limes.Perspective.Perspective
instance GHC.Classes.Ord OAlg.Limes.Perspective.Perspective
instance GHC.Classes.Eq OAlg.Limes.Perspective.Perspective
instance GHC.Show.Show OAlg.Limes.Perspective.Perspective


-- | arithmetic exceptions.
module OAlg.Structure.Exception

-- | arithmetic exceptions which are sub exceptions from
--   <a>SomeOAlgException</a>.
data ArithmeticException
NotAddable :: ArithmeticException
NotMultiplicable :: ArithmeticException
NotInvertible :: ArithmeticException
UndefinedScalarproduct :: ArithmeticException
NotExponential :: ArithmeticException
NotEndo :: ArithmeticException
NotTransformable :: ArithmeticException
NoMinusOne :: ArithmeticException
NotApplicable :: ArithmeticException
instance GHC.Show.Show OAlg.Structure.Exception.ArithmeticException
instance GHC.Classes.Eq OAlg.Structure.Exception.ArithmeticException
instance GHC.Exception.Type.Exception OAlg.Structure.Exception.ArithmeticException


-- | definition of <a>Oriented</a> structures.
module OAlg.Structure.Oriented.Definition

-- | types with a <a>Oriented</a> structure. The values of an
--   <a>Oriented</a> structure will be called <b><i>arrows</i></b> and the
--   values of the associated <a>Point</a> type <b><i>points</i></b>. To
--   each arrow there is a <b><i><a>start</a></i></b> and a
--   <b><i><a>end</a></i></b> point assigned.
--   
--   <b>Property</b> Let <b><tt>q</tt></b> be a type instance of the class
--   <a>Oriented</a>, then holds:
--   
--   <ol>
--   <li>For all <tt>a</tt> in <b><tt>q</tt></b> holds:
--   <tt><a>orientation</a> a <a>==</a> <a>start</a> a <a>:&gt;</a>
--   <a>end</a> a</tt>.</li>
--   </ol>
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>If the types <tt><b>q</b></tt> and <tt><a>Point</a> <b>q</b></tt>
--   are interpreted as sets <tt><b>A</b></tt> and <tt><b>P</b></tt> and
--   <a>start</a>, <a>end</a> as functions from <tt><b>A</b></tt> to
--   <tt><b>P</b></tt> then this structure forms a <b><i>quiver</i></b>
--   with <b><i>arrows</i></b> in <tt><b>A</b></tt> and
--   <b><i>points</i></b> in <tt><b>P</b></tt>.</li>
--   <li><a>Morphism</a>s can be interpreted as <a>Oriented</a> structures
--   via <a>SomeMorphism</a>. The bad thing about this is that we lose the
--   check for <i>composability</i> of two <a>Morphism</a>s given by the
--   type checker, but we gain all the functionality of <a>Oriented</a>
--   structures, i.e we can define homomorphisms, limits etc on
--   <a>Morphism</a>s.</li>
--   </ol>
class (Entity q, Entity (Point q)) => Oriented q where {
    
    -- | the associated type of points.
    type Point q;
}

-- | the orientation of an arrow.
orientation :: Oriented q => q -> Orientation (Point q)

-- | the start point of an arrow.
start :: Oriented q => q -> Point q

-- | the end point of an arrow.
end :: Oriented q => q -> Point q

-- | structures where its associated <a>Point</a> type is singleton. They
--   yield globally defiend algebraic operations.
class Singleton (Point x) => Total x

-- | helper class to avoid undecidable instances.
class Entity (Point x) => EntityPoint x

-- | helper class to circumvent undecidable instances.
class Ord (Point x) => OrdPoint x

-- | check for being an endo.
--   
--   <b>Definition</b> Let <tt><b>q</b></tt> be a <a>Oriented</a>
--   structure, then an arrow <tt>a</tt> in <tt><b>q</b></tt> is called
--   <b><i>endo</i></b> if and only if <tt><a>start</a> a <a>==</a>
--   <a>end</a> a</tt>.
isEndo :: Oriented q => q -> Bool

-- | check for being an endo at the given point.
isEndoAt :: Oriented a => Point a -> a -> Bool

-- | as <tt><a>Orientation</a> p</tt> is an instance of almost every
--   structured class it serves as a standard type for validating.
type OS = Orientation Symbol

-- | type representing the class of <a>Oriented</a> structures.
data Ort

-- | attest that if <tt><b>x</b></tt> is <a>Oriented</a> then also
--   <tt><a>Op</a> <b>x</b></tt> is <a>Oriented</a>.
structOrtOp :: Struct Ort x -> Struct Ort (Op x)

-- | transformable to <a>Oriented</a> structure.
class Transformable s Ort => ForgetfulOrt s

-- | transposable oriented structures.
--   
--   <b>Property</b> Let <tt><b>q</b></tt> be a <a>TransposableOriented</a>
--   structure, then holds: For all <tt>a</tt> in <tt><b>q</b></tt> holds:
--   <tt><a>orientation</a> (<a>transpose</a> a) <a>==</a> <a>opposite</a>
--   (<a>orientation</a> a)</tt>.
class (Transposable q, Oriented q) => TransposableOriented q

-- | orientation given by the start point as its first component and the
--   end point as its second.
--   
--   <b>Property</b> For all <tt>o</tt> in <b><tt><a>Orientation</a>
--   p</tt></b> holds: <tt>o <a>==</a> <a>start</a> o <a>:&gt;</a>
--   <a>end</a> o</tt>.
--   
--   <b>Note</b> As <a>Orientation</a>s are instances of almost all
--   algebraic structures defined here, they serve as a <i>proof</i> that
--   this structures are instanceable.
data Orientation p
(:>) :: p -> p -> Orientation p
infix 5 :>

-- | the opposite orientation.
opposite :: Orientation p -> Orientation p

-- | a path in a <a>Oriented</a> structure <tt><b>q</b></tt> starting at a
--   given point.
--   
--   <b>Definition</b> Let <tt><b>q</b></tt> be a <a>Oriented</a> structure
--   and <tt>p = <a>Path</a> s [a 0..a (n-1)]</tt> a path in
--   <tt><b>q</b></tt>, then <tt>p</tt> is <a>valid</a> if and only if
--   
--   <ol>
--   <li><tt>s</tt> is <a>valid</a> and <tt>a i</tt> are <a>valid</a> for
--   all <tt>i = 0..n-1</tt>.</li>
--   <li><tt><a>start</a> (a (n-1)) <a>==</a> s</tt> and <tt><a>start</a>
--   (a i) <a>==</a> <a>end</a> (a (n+1))</tt> for all <tt>i =
--   0..n-2</tt>.</li>
--   </ol>
--   
--   furthermore <tt>n</tt> is called the <b><i>length</i></b> of
--   <tt>p</tt>.
--   
--   <b>Note</b> Paths admit a canonical embedding in to <a>Product</a>.
data Path q
Path :: Point q -> [q] -> Path q

-- | the length of a path.
pthLength :: Path q -> N

-- | path of length 0 at the given point.
pthOne :: Point q -> Path q

-- | composition of two paths.
pthMlt :: Oriented q => Path q -> Path q -> Path q

-- | random variables <tt><a>X</a> <b>q</b></tt> and <tt><a>X</a>
--   (<a>Point</a> <b>q</b>)</tt> for <a>Oriented</a> structure
--   <tt><b>q</b></tt>.
--   
--   <b>Properties</b> Let <tt><b>q</b></tt> be an instance of the class
--   <a>Oriented</a>, then holds:
--   
--   <ol>
--   <li>Let <tt><a>XStart</a> xp xStart</tt> be in <tt><a>XOrtSite</a>
--   <a>From</a> <b>q</b></tt>, then holds: For all <tt>p</tt> in
--   <tt><a>Point</a> <b>q</b></tt> and <tt>x</tt> in the range of
--   <tt>xStart p</tt> holds: <tt><a>start</a> x <a>==</a> p</tt>.</li>
--   <li>Let <tt><a>XEnd</a> xp xEnd</tt> be in <tt><a>XOrtSite</a>
--   <a>To</a> <b>q</b></tt>, then holds: For all <tt>p</tt> in
--   <tt><a>Point</a> <b>q</b></tt> and <tt>x</tt> in the range of <tt>xEnd
--   p</tt> holds: <tt><a>end</a> x <a>==</a> p</tt>.</li>
--   </ol>
--   
--   <b>Note</b> The random variables <tt>xp</tt> should have a bias to non
--   trivial random variables <tt>xp <a>&gt;&gt;=</a> xStart</tt> or <tt>xp
--   <a>&gt;&gt;=</a> xEnd</tt>.
data XOrtSite s q
[XStart] :: X (Point q) -> (Point q -> X q) -> XOrtSite From q
[XEnd] :: X (Point q) -> (Point q -> X q) -> XOrtSite To q

-- | standard random variable for <a>XOrtSite</a>.
class XStandardOrtSite s a
xStandardOrtSite :: XStandardOrtSite s a => XOrtSite s a

-- | standard random variable for <tt><a>XOrtSite</a> <a>To</a></tt>,
--   helper class to avoid undecidable instances.
class XStandardOrtSite To a => XStandardOrtSiteTo a

-- | standard random variable for <tt><a>XOrtSite</a> <a>From</a></tt>,
--   helper class to avoid undecidable instances.
class XStandardOrtSite From a => XStandardOrtSiteFrom a

-- | to the dual of a <tt><a>XOrtSite</a> <b>s</b> <b>q</b></tt>, with
--   inverse <a>coXOrtSiteInv</a>.
coXOrtSite :: XOrtSite s q -> Dual (XOrtSite s q)

-- | from the dual of a <tt><a>Dual</a> (<a>XOrtSite</a> <b>s</b>
--   <b>q</b>)</tt>, with inverse <a>coXOrtSite</a>.
coXOrtSiteInv :: (Dual (Dual s) :~: s) -> Dual (XOrtSite s q) -> XOrtSite s q

-- | from the bidual.
xosFromOpOp :: XOrtSite s (Op (Op q)) -> XOrtSite s q

-- | the random variable of arrows in <tt><b>q</b></tt> having all as
--   <a>start</a> the given point.
xosStart :: XOrtSite From q -> Point q -> X q

-- | the random variable of arrows in <tt><b>q</b></tt> having all as
--   <a>end</a> the given point.
xosEnd :: XOrtSite To q -> Point q -> X q

-- | tries to make a path at the given point with maximal length of the
--   given length.
--   
--   <b>Properties</b> Let <tt>xPath = <a>xosPathMaxAt</a> xos n x</tt>,
--   then holds:
--   
--   <ol>
--   <li>If <tt>xos</tt> matches <tt><a>XStart</a> _ xq</tt> then for all
--   <tt>p</tt> in the range of <tt>xPath</tt>
--   holds:<ol><li><tt><a>start</a> p <a>==</a> x</tt>.</li><li>If
--   <tt><a>pthLength</a> p <a>&lt;</a> n</tt> then <tt>xq (<a>end</a>
--   p)</tt> matches <a>XEmpty</a>.</li></ol></li>
--   <li>If <tt>xos</tt> matches <tt><a>XEnd</a> _ xq</tt> then for all
--   <tt>p</tt> in the range of <tt>xPath</tt> holds:<ol><li><tt><a>end</a>
--   p <a>==</a> x</tt>.</li><li>If <tt><a>pthLength</a> p <a>&lt;</a>
--   n</tt> then <tt>xq (<a>start</a> p)</tt> matches
--   <a>XEmpty</a>.</li></ol></li>
--   </ol>
xosPathMaxAt :: Oriented q => XOrtSite s q -> N -> Point q -> X (Path q)

-- | random variable of paths with maximal length of the given length.
xosPathMax :: Oriented q => XOrtSite s q -> N -> X (Path q)

-- | random variable of arrows given by an orientation.
--   
--   <b>Properties</b> Let <tt><a>XOrtOrientation</a> xo xArrow</tt> be in
--   <tt><a>XOrtOrientation</a> <b>q</b></tt> for a <a>Oriented</a>
--   structure <tt><b>q</b></tt>, then holds: For all <tt>o</tt> in
--   <tt><a>Orientation</a> <b>q</b></tt> and <tt>x</tt> in the range of
--   <tt>xArrow o</tt> holds: <tt><a>orientation</a> x <a>==</a> o</tt>.
--   
--   <b>Note</b> The random variable <tt>xo</tt> should have a bias to non
--   trivial random variables <tt>xo <a>&gt;&gt;=</a> xArrow</tt> and as
--   such the range of <tt>xo</tt> should be included in one connection
--   component of <tt><b>q</b></tt>.
data XOrtOrientation q
XOrtOrientation :: X (Orientation (Point q)) -> (Orientation (Point q) -> X q) -> XOrtOrientation q

-- | the underlying random variable of orientations.
xoOrientation :: XOrtOrientation q -> X (Orientation (Point q))

-- | the underlying random variable of arrow given by the orientation.
xoArrow :: XOrtOrientation q -> Orientation (Point q) -> X q

-- | the underlying random variable of points, i.e. the union of the
--   induced <a>start</a> and <a>end</a> random variable of
--   <a>xoOrientation</a>.
xoPoint :: Oriented q => XOrtOrientation q -> X (Point q)

-- | to the dual.
coXOrtOrientation :: XOrtOrientation q -> Dual (XOrtOrientation q)

-- | the induced <tt><a>XOrtSite</a> <a>To</a></tt>
xoTo :: Oriented q => XOrtOrientation q -> XOrtSite To q

-- | the induced <tt><a>XOrtSite</a> <a>From</a></tt>.
xoFrom :: Oriented q => XOrtOrientation q -> XOrtSite From q

-- | random variable of <tt><a>XOrtOrientation</a> <b>q</b></tt> for a
--   total <tt><b>q</b></tt>.
xoTtl :: Total q => X q -> XOrtOrientation q

-- | the induced random variable of <tt><a>Orientation</a> <b>q</b></tt>.
xoOrnt :: X p -> XOrtOrientation (Orientation p)

-- | standard random variable for <a>XOrtOrientation</a>.
class XStandardOrtOrientation q
xStandardOrtOrientation :: XStandardOrtOrientation q => XOrtOrientation q

-- | standard random variable of <a>Point</a>s of <tt><b>a</b></tt>.
class XStandard (Point a) => XStandardPoint a

-- | the <tt><a>XOrtSite</a> <a>From</a></tt> for <tt><a>Orientation</a>
--   <b>p</b></tt> of the given random variable.
xStartOrnt :: X p -> XOrtSite From (Orientation p)

-- | the <tt><a>XOrtSite</a> <a>To</a></tt> of <tt><a>Orientation</a>
--   <b>p</b></tt> of the given random variable.
xEndOrnt :: X p -> XOrtSite To (Orientation p)
instance GHC.Classes.Ord p => GHC.Classes.Ord (OAlg.Structure.Oriented.Definition.Orientation p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (OAlg.Structure.Oriented.Definition.Orientation p)
instance GHC.Show.Show p => GHC.Show.Show (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Oriented.Definition.Oriented q => GHC.Show.Show (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Structure.Oriented.Definition.Oriented q => GHC.Classes.Eq (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Data.Validable.XStandard p => OAlg.Structure.Oriented.Definition.XStandardOrtOrientation (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Oriented.Definition.XStandardOrtOrientation OAlg.Data.Number.Z
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Data.Validable.Validable (OAlg.Structure.Oriented.Definition.XOrtOrientation q)
instance OAlg.Structure.Oriented.Definition.XStandardPoint OAlg.Data.Number.N
instance OAlg.Structure.Oriented.Definition.XStandardPoint OAlg.Data.Number.Z
instance OAlg.Structure.Oriented.Definition.XStandardPoint OAlg.Data.Number.Q
instance OAlg.Data.Validable.XStandard p => OAlg.Structure.Oriented.Definition.XStandardPoint (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Data.Validable.XStandard p => OAlg.Structure.Oriented.Definition.XStandardOrtSiteFrom (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Data.Validable.XStandard p => OAlg.Structure.Oriented.Definition.XStandardOrtSiteTo (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Data.Validable.XStandard p => OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Data.Validable.XStandard p => OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From a => OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To (OAlg.Data.Opposite.Op a)
instance OAlg.Data.Dualisable.Dualisable (OAlg.Structure.Oriented.Definition.XOrtSite 'OAlg.Data.Dualisable.To q)
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Data.Validable.Validable (OAlg.Structure.Oriented.Definition.XOrtSite s q)
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Oriented.Definition.Ort OAlg.Structure.Definition.Typ
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Oriented.Definition.Ort OAlg.Entity.Definition.Ent
instance OAlg.Structure.Definition.Transformable1 OAlg.Data.Opposite.Op OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Structure.Definition.TransformableOp OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Structure.Definition.ForgetfulTyp OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Structure.Oriented.Definition.OrdPoint ()
instance OAlg.Structure.Oriented.Definition.OrdPoint GHC.Types.Int
instance OAlg.Structure.Oriented.Definition.OrdPoint GHC.Num.Integer.Integer
instance OAlg.Structure.Oriented.Definition.OrdPoint OAlg.Data.Number.N
instance OAlg.Structure.Oriented.Definition.OrdPoint OAlg.Data.Number.Z
instance OAlg.Structure.Oriented.Definition.OrdPoint OAlg.Data.Number.Q
instance OAlg.Structure.Oriented.Definition.OrdPoint q => OAlg.Structure.Oriented.Definition.OrdPoint (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Structure.Oriented.Definition.EntityPoint ()
instance OAlg.Structure.Oriented.Definition.EntityPoint GHC.Types.Int
instance OAlg.Structure.Oriented.Definition.EntityPoint GHC.Num.Integer.Integer
instance OAlg.Structure.Oriented.Definition.EntityPoint OAlg.Data.Number.N
instance OAlg.Structure.Oriented.Definition.EntityPoint OAlg.Data.Number.Z
instance OAlg.Structure.Oriented.Definition.EntityPoint OAlg.Data.Number.Q
instance OAlg.Structure.Oriented.Definition.EntityPoint q => OAlg.Structure.Oriented.Definition.EntityPoint (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Structure.Oriented.Definition.EntityPoint x => OAlg.Structure.Oriented.Definition.EntityPoint (OAlg.Data.Opposite.Op x)
instance OAlg.Structure.Oriented.Definition.Total ()
instance OAlg.Structure.Oriented.Definition.Total GHC.Types.Int
instance OAlg.Structure.Oriented.Definition.Total GHC.Num.Integer.Integer
instance OAlg.Structure.Oriented.Definition.Total OAlg.Data.Number.N
instance OAlg.Structure.Oriented.Definition.Total OAlg.Data.Number.Z
instance OAlg.Structure.Oriented.Definition.Total OAlg.Data.Number.Q
instance OAlg.Structure.Oriented.Definition.Total q => OAlg.Structure.Oriented.Definition.Total (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Structure.Oriented.Definition.Total x => OAlg.Structure.Oriented.Definition.Total (OAlg.Data.Opposite.Op x)
instance Data.Foldable.Foldable OAlg.Structure.Oriented.Definition.Path
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Data.Validable.Validable (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Entity.Definition.Entity (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Data.Dualisable.Dualisable (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Data.Dualisable.Reflexive (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Data.Canonical.Embeddable q (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Data.Number.LengthN (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Oriented.Definition.TransposableOriented (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Oriented.Definition.TransposableOriented OAlg.Data.Number.N
instance OAlg.Structure.Oriented.Definition.TransposableOriented OAlg.Data.Number.Z
instance OAlg.Structure.Oriented.Definition.TransposableOriented OAlg.Data.Number.Q
instance OAlg.Structure.Oriented.Definition.Oriented ()
instance OAlg.Structure.Oriented.Definition.Oriented GHC.Types.Int
instance OAlg.Structure.Oriented.Definition.Oriented GHC.Num.Integer.Integer
instance OAlg.Structure.Oriented.Definition.Oriented OAlg.Data.Number.N
instance OAlg.Structure.Oriented.Definition.Oriented OAlg.Data.Number.Z
instance OAlg.Structure.Oriented.Definition.Oriented OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Data.Opposite.Op q)
instance (OAlg.Category.Definition.EmbeddableMorphismTyp m, OAlg.Entity.Definition.Entity2 m) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Category.Unify.SomeMorphism m)
instance OAlg.Data.Validable.Validable p => OAlg.Data.Validable.Validable (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Entity.Definition.Entity p => OAlg.Entity.Definition.Entity (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Data.Singleton.Singleton u => OAlg.Data.Singleton.Singleton (OAlg.Structure.Oriented.Definition.Orientation u)
instance GHC.Base.Functor OAlg.Structure.Oriented.Definition.Orientation
instance OAlg.Data.Validable.XStandard p => OAlg.Data.Validable.XStandard (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Data.Dualisable.Transposable (OAlg.Structure.Oriented.Definition.Orientation p)


-- | Propositions on <a>Oriented</a> structure.
module OAlg.Structure.Oriented.Proposition

-- | validity of the <a>Oriented</a> structure of <tt><b>q</b></tt>.
prpOrt :: Oriented q => XOrt q -> Statement

-- | random variable for <a>Oriented</a> structures.
type XOrt = X

-- | validity of the functions <a>orientation</a>, <a>start</a> and
--   <a>end</a>.
prpOrt0 :: Oriented q => X q -> Statement

-- | validity of the relation between <a>orientation</a>, <a>start</a> and
--   <a>end</a> according to
--   <a>OAlg.Structure.Oriented.Definition#Ort1</a>.
prpOrt1 :: Oriented q => X q -> Statement

-- | the underlying random variable for <a>Oriented</a> structures.
xosOrt :: Oriented q => XOrtSite s q -> XOrt q

-- | the underlying random variable of <tt><a>Point</a> <b>g</b></tt>.
xosPoint :: XOrtSite s q -> X (Point q)

-- | the underlying random variable for <a>Oriented</a> structures.
xoOrt :: XOrtOrientation q -> XOrt q

-- | the induced random variable of <a>Oriented</a> structures for
--   <tt><a>Orientation</a> <b>p</b></tt>.
xOrtOrnt :: X p -> XOrt (Orientation p)


-- | <a>Oriented</a> structures.
module OAlg.Structure.Oriented


-- | multiplicative structures, i.e. structures with a <b>partially</b>
--   defined multiplication <tt>(<a>*</a>)</tt>.
module OAlg.Structure.Multiplicative.Definition

-- | <a>Oriented</a> structures with a <b>partially</b> defined
--   <b>multiplication</b> and having <a>one</a> as the <b>neutral
--   element</b> of the multiplication. An entity of a
--   <a>Multiplicative</a> structure will be called a <b>factor</b>.
--   
--   <b>Properties</b> Let <b><tt>c</tt></b> be a type instance of the
--   class <a>Multiplicative</a>, then holds:
--   
--   <ol>
--   <li>For all <tt>p</tt> in <tt><a>Point</a> <b>c</b></tt> holds:
--   <tt><a>orientation</a> (<a>one</a> p) <a>==</a> p <a>:&gt;</a>
--   p</tt>.</li>
--   <li>For all <tt>f</tt> and <tt>g</tt> in <b><tt>c</tt></b>
--   holds:<ol><li>if <tt><a>start</a> f <a>==</a> <a>end</a> g</tt> then
--   <tt>f <a>*</a> g</tt> is <a>valid</a> and <tt><a>start</a> (f <a>*</a>
--   g) <a>==</a> <a>start</a> g</tt> and <tt><a>end</a> (f <a>*</a> g)
--   <a>==</a> <a>end</a> f</tt>.</li><li>if <tt><a>start</a> f <a>/=</a>
--   <a>end</a> g</tt> then <tt>f <a>*</a> g</tt> is not <a>valid</a> and
--   its evaluation will end up in a <a>NotMultiplicable</a>
--   exception.</li></ol></li>
--   <li>For all <tt>f</tt> in <b><tt>c</tt></b> holds: <tt><a>one</a>
--   (<a>end</a> f) <a>*</a> f <a>==</a> f</tt> and <tt>f <a>*</a>
--   <a>one</a> (<a>start</a> f) <a>==</a> f</tt>.</li>
--   <li>For all <tt>f</tt>, <tt>g</tt> and <tt>h</tt> in <b><tt>c</tt></b>
--   with <tt><a>start</a> g == <a>end</a> h</tt> and <tt><a>start</a> f ==
--   <a>end</a> g</tt> holds: <tt>(f <a>*</a> g) <a>*</a> h <a>==</a> f
--   <a>*</a> (g <a>*</a> h)</tt>.</li>
--   <li>For all <tt>f</tt> in <b><tt>c</tt></b>
--   holds:<ol><li><tt><a>npower</a> f 1 <a>==</a> f</tt>.</li><li>If
--   <tt>f</tt> is a endo than <tt><a>npower</a> f 0 <a>==</a> <a>one</a>
--   (<a>start</a> f)</tt> and For all <tt>n</tt> in <a>N</a> holds:
--   <tt><a>npower</a> f (<a>succ</a> n) <a>==</a> f <a>*</a> <a>npower</a>
--   f n</tt>.</li></ol></li>
--   </ol>
--   
--   Such a <b><tt>c</tt></b> will be called a <b><i>multiplicative
--   structure</i></b> and an entity <tt>f</tt> of <b><tt>c</tt></b> will
--   be called <b><i>factor</i></b>. The associated factor <tt><a>one</a>
--   p</tt> to a <tt>p</tt> in <tt><a>Point</a> <b>c</b></tt> will be
--   called the <b><i>one at</i></b> <tt>p</tt>.
--   
--   <b>Note</b> If the types <b><tt>c</tt></b> and <tt><a>Point</a>
--   <b>c</b></tt> are interpreted as sets <b><tt>M</tt></b> and
--   <b><tt>O</tt></b> and <tt><a>*</a></tt> as a partially defined
--   function from <b><tt>M x M -&gt; M</tt></b> then this forms a
--   <b><i>small category</i></b> with objects in <b><tt>O</tt></b> and
--   morphisms in <b><tt>M</tt></b>.
class Oriented c => Multiplicative c

-- | the neutral element associated to each point. If there is no ambiguity
--   for <tt><a>one</a> p</tt> we will briefly denote it by <tt>1 r</tt> or
--   just <tt>1</tt>.
one :: Multiplicative c => Point c -> c

-- | the multiplication of two factors.
(*) :: Multiplicative c => c -> c -> c

-- | <tt>n</tt> times the multiplication of a given factor <tt>f</tt>.
npower :: Multiplicative c => c -> N -> c
infixl 7 *

-- | the <a>one</a> to a given point. The type <tt>p c</tt> serves only as
--   proxy and <a>one'</a> is lazy in it.
--   
--   <b>Note</b> As <a>Point</a> may be a non-injective type family, the
--   type checker needs some times a little bit more information to pic the
--   right <a>one</a>.
one' :: Multiplicative c => p c -> Point c -> c

-- | check for being equal to <a>one</a>.
isOne :: Multiplicative c => c -> Bool

-- | type representing the class of <a>Multiplicative</a> structures.
data Mlt

-- | transformable to <a>Multiplicative</a> structure.
class (ForgetfulOrt s, Transformable s Mlt) => ForgetfulMlt s

-- | transposable <a>Multiplicative</a> structures.
--   
--   <b>Property</b> Let <b><tt>c</tt></b> be a
--   <a>TransposableMultiplicative</a> structure, then holds:
--   
--   <ol>
--   <li>For all <tt>p</tt> in <tt><a>Point</a> <b>c</b></tt> holds:
--   <tt><a>transpose</a> (<a>one</a> p) = <a>one</a> p</tt>.</li>
--   <li>For all <tt>f</tt>, <tt>g</tt> in <b><tt>c</tt></b> with
--   <tt><a>start</a> f <a>==</a> <a>end</a> g</tt> holds:
--   <tt><a>transpose</a> (f <a>*</a> g) <a>==</a> <a>transpose</a> g
--   <a>*</a> <a>transpose</a> f</tt>.</li>
--   </ol>
class (TransposableOriented c, Multiplicative c) => TransposableMultiplicative c

-- | commutative multiplicative structures.
--   
--   <b>Property</b> Let <tt><b>c</b></tt> be a <a>Commutative</a>
--   structure, then holds: For all <tt>f</tt> and <tt>g</tt> in
--   <tt><b>c</b></tt> with <tt><a>start</a> f <a>==</a> <a>end</a> f</tt>,
--   <tt><a>start</a> g <a>==</a> <a>end</a> g</tt> and <tt><a>start</a> f
--   <a>==</a> <a>end</a> g</tt> holds: <tt>f <a>*</a> g <a>==</a> g
--   <a>*</a> f</tt>.
class Multiplicative c => Commutative c

-- | multiplicative structures having a <b><i>multiplicative
--   inverse</i></b>.
--   
--   <b>Definition</b> Let <tt>f</tt> and <tt>g</tt> be two factors in a
--   <a>Multiplicative</a> structure <tt><b>_c</b></tt> then we call
--   <tt>g</tt> a <b><i>multiplicative inverse</i></b> to <tt>f</tt> (or
--   short inverse) if and only if the following hold:
--   
--   <ol>
--   <li><tt><a>start</a> g == <a>end</a> f</tt> and <tt><a>end</a> g ==
--   <a>start</a> f</tt>.</li>
--   <li><tt>f <a>*</a> g = <a>one</a> (<a>end</a> f)</tt> and <tt>g
--   <a>*</a> f == <a>one</a> (<a>start</a> f)</tt>.</li>
--   </ol>
--   
--   <b>Properties</b> For all <tt>f</tt> in a <a>Invertible</a> structure
--   <tt><b>c</b></tt> holds:
--   
--   <ol>
--   <li><tt><a>isInvertible</a> f</tt> is equivalent to
--   <tt><a>solvable</a> (<a>tryToInvert</a> f)</tt>.</li>
--   <li>if <tt><a>isInvertible</a> f</tt> holds, then <tt><a>invert</a>
--   f</tt> is <a>valid</a> and it is the multiplicative inverse of
--   <tt>f</tt>. Furthermore <tt><a>invert</a> f <a>==</a> <a>solve</a>
--   (<a>tryToInvert</a> m)</tt>.</li>
--   <li>if <a>not</a> <tt><a>isInvertible</a> f</tt> holds, then
--   <tt><a>invert</a> f</tt> is not <a>valid</a> and evaluating it will
--   end up in a <a>NotInvertible</a>-exception.</li>
--   </ol>
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>It is not required that every factor has a multiplicative inverse
--   (see <a>Cayleyan</a> for such structures).</li>
--   <li>This structure is intended for multiplicative structures having a
--   known algorithm to evaluate for every invertible <tt>f</tt> its
--   inverse.</li>
--   </ol>
class Multiplicative c => Invertible c

-- | solver to evaluate the multiplicative inverse - if it exists.
tryToInvert :: Invertible c => c -> Solver c

-- | the inverse.
invert :: Invertible c => c -> c

-- | check for being invertible.
isInvertible :: Invertible c => c -> Bool

-- | if <tt>0 <a>&lt;=</a> z</tt> then <tt>n</tt> times the multiplication
--   for the given factor else <tt><a>prj</a> z</tt> times the
--   multiplication of the inverse of the given factor.
zpower :: Invertible c => c -> Z -> c

-- | invertible factors within a <a>Multiplicative</a> structures
--   <tt><b>c</b></tt>, which forms a <i>sub</i> <a>Multiplicative</a>
--   structure on <tt><b>c</b></tt>, given by the canonical inclusion
--   <a>inj</a> which is given by <tt>\<a>Inv</a> f _ -&gt; f</tt>.
--   
--   <b>Property</b> Let <tt><a>Inv</a> f f'</tt> be in <tt><a>Inv</a>
--   <b>c</b></tt> where <tt><b>c</b></tt> is a <a>Multiplicative</a>
--   structure, then holds:
--   
--   <ol>
--   <li><tt><a>orientation</a> f' <a>==</a> <a>opposite</a>
--   (<a>orientation</a> f)</tt>.</li>
--   <li><tt>f' <a>*</a> f <a>==</a> <a>one</a> (<a>start</a> f)</tt>.</li>
--   <li><tt>f <a>*</a> f' <a>==</a> <a>one</a> (<a>end</a> f)</tt>.</li>
--   </ol>
--   
--   <b>Note</b> The canonical inclusion is obviously not injective on the
--   <i>set</i> of all values of type <tt><a>Inv</a> <b>c</b></tt> to
--   <tt><b>c</b></tt>. But restricted to the <a>valid</a> ones it is
--   injective, because the inverses of a <tt>f</tt> in <tt><b>c</b></tt>
--   are uniquely determined by <tt>f</tt>.
data Inv c
Inv :: c -> c -> Inv c

-- | <a>Invertible</a> structures where every element is invertible.
--   
--   <b>Property</b> Let <tt><b>c</b></tt> be a <a>Cayleyan</a> structure,
--   then holds: For all <tt>f</tt> in <tt><b>c</b></tt> holds:
--   <tt><a>isInvertible</a> f <a>==</a> <a>True</a></tt>.
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>If the type <tt><a>Point</a> <b>c</b></tt> is singleton, then the
--   mathematical interpretation of <tt><b>c</b></tt> is a
--   <b>group</b>.</li>
--   <li>The name of this structures is given by <i>Arthur Cayley</i> who
--   introduced the concept (and the name) of an abstract group in 1854
--   (<a>https://en.wikipedia.org/wiki/Arthur_Cayley</a>).</li>
--   <li>Usually in mathematics such a structure is called a
--   <b><i>groupoid</i></b>.</li>
--   </ol>
class Invertible c => Cayleyan c

-- | random variable of paths at the given point and the given length (see
--   <a>xosPathMaxAt</a> and as <tt><b>c</b></tt> is <a>Multiplicative</a>,
--   the underlying random variable for factors for a given point is not
--   empty).
xosPathAt :: Multiplicative c => XOrtSite s c -> N -> Point c -> X (Path c)

-- | random variable of paths with the given length.
xosPath :: Multiplicative c => XOrtSite s c -> N -> X (Path c)

-- | the induced random variable for paths.
xosXOrtSitePath :: Multiplicative c => XOrtSite s c -> N -> XOrtSite s (Path c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (OAlg.Structure.Multiplicative.Definition.Inv c)
instance GHC.Show.Show c => GHC.Show.Show (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.ForgetfulMlt OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Multiplicative.Definition.Mlt OAlg.Structure.Definition.Typ
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Multiplicative.Definition.Mlt OAlg.Entity.Definition.Ent
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Multiplicative.Definition.Mlt OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Structure.Definition.Transformable1 OAlg.Data.Opposite.Op OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Structure.Definition.TransformableOp OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Structure.Definition.ForgetfulTyp OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Data.Canonical.Embeddable (OAlg.Structure.Multiplicative.Definition.Inv c) c
instance OAlg.Structure.Multiplicative.Definition.Multiplicative c => OAlg.Data.Validable.Validable (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.Multiplicative c => OAlg.Entity.Definition.Entity (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.Multiplicative c => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.Multiplicative c => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.Multiplicative c => OAlg.Structure.Multiplicative.Definition.Invertible (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.Multiplicative c => OAlg.Structure.Multiplicative.Definition.Cayleyan (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative c => OAlg.Data.Dualisable.Transposable (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative c => OAlg.Structure.Oriented.Definition.TransposableOriented (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative c => OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative (OAlg.Structure.Multiplicative.Definition.Inv c)
instance OAlg.Structure.Multiplicative.Definition.Cayleyan ()
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Multiplicative.Definition.Cayleyan (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Multiplicative.Definition.Cayleyan c => OAlg.Structure.Multiplicative.Definition.Cayleyan (OAlg.Data.Opposite.Op c)
instance OAlg.Structure.Multiplicative.Definition.Invertible ()
instance OAlg.Structure.Multiplicative.Definition.Invertible GHC.Types.Int
instance OAlg.Structure.Multiplicative.Definition.Invertible GHC.Num.Integer.Integer
instance OAlg.Structure.Multiplicative.Definition.Invertible OAlg.Data.Number.N
instance OAlg.Structure.Multiplicative.Definition.Invertible OAlg.Data.Number.Z
instance OAlg.Structure.Multiplicative.Definition.Invertible OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Multiplicative.Definition.Invertible (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Multiplicative.Definition.Invertible c => OAlg.Structure.Multiplicative.Definition.Invertible (OAlg.Data.Opposite.Op c)
instance OAlg.Structure.Multiplicative.Definition.Commutative ()
instance OAlg.Structure.Multiplicative.Definition.Commutative GHC.Types.Int
instance OAlg.Structure.Multiplicative.Definition.Commutative GHC.Num.Integer.Integer
instance OAlg.Structure.Multiplicative.Definition.Commutative OAlg.Data.Number.N
instance OAlg.Structure.Multiplicative.Definition.Commutative OAlg.Data.Number.Z
instance OAlg.Structure.Multiplicative.Definition.Commutative OAlg.Data.Number.Q
instance OAlg.Structure.Multiplicative.Definition.Commutative c => OAlg.Structure.Multiplicative.Definition.Commutative (OAlg.Data.Opposite.Op c)
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative OAlg.Data.Number.N
instance OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative OAlg.Data.Number.Z
instance OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative OAlg.Data.Number.Q
instance OAlg.Structure.Multiplicative.Definition.Multiplicative ()
instance OAlg.Structure.Multiplicative.Definition.Multiplicative GHC.Types.Int
instance OAlg.Structure.Multiplicative.Definition.Multiplicative GHC.Num.Integer.Integer
instance OAlg.Structure.Multiplicative.Definition.Multiplicative OAlg.Data.Number.N
instance OAlg.Structure.Multiplicative.Definition.Multiplicative OAlg.Data.Number.Z
instance OAlg.Structure.Multiplicative.Definition.Multiplicative OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Structure.Oriented.Definition.Path q)
instance OAlg.Structure.Multiplicative.Definition.Multiplicative c => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Data.Opposite.Op c)
instance OAlg.Structure.Multiplicative.Definition.Multiplicative c => OAlg.Data.Canonical.Projectible c (OAlg.Structure.Oriented.Definition.Path c)


-- | operations on entities by a <a>Multiplicative</a> structure.
module OAlg.Structure.Operational

-- | right operation of <tt><b>f</b></tt> on <tt><b>x</b></tt>. This class
--   is rather technical, because on this abstract level it is not possible
--   to define the exact behavior of the operation, i.e. for which values
--   <tt>f</tt> and <tt>x</tt> the expression <tt>x <a>&lt;*</a> f</tt> is
--   <a>valid</a>. For a precise definition see for example <a>TotalOpr</a>
--   or <a>OrientedOpr</a> where the behavior can be stated.
class Opr f x

-- | right operation.
(<*) :: Opr f x => x -> f -> x
infixl 5 <*

-- | left operation of <tt><b>f</b></tt> on <tt><b>x</b></tt>. This class
--   is rather technical, because on this abstract level it is not possible
--   to define the exact behavior of the operation, i.e. for which values
--   <tt>f</tt> and <tt>x</tt> the expression <tt>f <a>*&gt;</a> x</tt> is
--   <a>valid</a>. For a precise definition see for example <a>TotalOpl</a>
--   or <a>OrientedOpl</a> where the behavior can be stated.
class Opl f x
(*>) :: Opl f x => f -> x -> x
infixr 9 *>

-- | right operation of a <a>Total</a> <a>Multiplicative</a> structure
--   <tt><b>f</b></tt> on <tt><b>x</b></tt>.
--   
--   <b>Property</b> Let <tt><b>f</b></tt> be a <a>Total</a>
--   <a>Multiplicative</a> structure and <tt><b>x</b></tt> an instance of
--   <a>Entity</a>, then holds:
--   
--   <ol>
--   <li>For all <tt>x</tt> in <tt><b>x</b></tt> holds: <tt>x <a>&lt;*</a>
--   <a>one</a> u <a>==</a> x</tt> where <tt>u = <a>unit</a></tt> is the
--   singleton element in <tt><a>Point</a> <b>f</b></tt>.</li>
--   <li>For all <tt>x</tt> in <tt><b>x</b></tt> and <tt>f</tt>, <tt>g</tt>
--   in <tt><b>f</b></tt> holds: <tt>x <a>&lt;*</a> f <a>&lt;*</a> g
--   <a>==</a> x <a>&lt;*</a> (f <a>*</a> g)</tt>.</li>
--   </ol>
--   
--   <b>Note</b> If <tt>f</tt> is invertible, then it gives rise of a
--   <i>bijection</i> <tt><a>&lt;*</a> f</tt> on <tt><b>x</b></tt> with
--   inverse <tt><a>&lt;*</a> <a>invert</a> f</tt>.
class (Opr f x, Multiplicative f, Total f, Entity x) => TotalOpr f x

-- | left operation of a <a>Total</a> <a>Multiplicative</a> structure
--   <tt><b>f</b></tt> on <tt><b>x</b></tt>.
--   
--   <b>Property</b> Let <tt><b>f</b></tt> be a <a>Total</a>
--   <a>Multiplicative</a> structure and <tt><b>x</b></tt> an instance of
--   <a>Entity</a>, then holds:
--   
--   <ol>
--   <li>For all <tt>x</tt> in <tt><b>x</b></tt> holds: <tt><a>one</a> u
--   <a>*&gt;</a> x <a>==</a> x</tt> where <tt>u = <a>unit</a></tt> is the
--   singleton element in <tt><a>Point</a> <b>f</b></tt>.</li>
--   <li>For all <tt>x</tt> in <tt><b>x</b></tt> and <tt>f</tt>, <tt>g</tt>
--   in <tt><b>f</b></tt> holds: <tt>f <a>*&gt;</a> g <a>*&gt;</a> x
--   <a>==</a> (f <a>*</a> g) <a>*&gt;</a> x</tt>.</li>
--   </ol>
--   
--   <b>Note</b> If <tt>f</tt> is invertible, then it gives rise of a
--   <i>bijection</i> <tt>f <a>*&gt;</a></tt> on <tt><b>x</b></tt> with
--   inverse <tt><a>invert</a> f <a>*&gt;</a></tt>.
class (Opr f x, Multiplicative f, Total f, Entity x) => TotalOpl f x

-- | right operation of a <a>Multiplicative</a> structure <tt><b>f</b></tt>
--   on a <a>Oriented</a> structure <tt><b>x</b></tt>.
--   
--   <b>Property</b> Let <tt><b>f</b></tt> be a <a>Multiplicative</a> and
--   <tt><b>x</b></tt> a <a>Oriented</a> structure, then holds:
--   
--   <ol>
--   <li>For all <tt>f</tt> in <tt><b>f</b></tt> and <tt>x</tt> in
--   <tt><b>x</b></tt> holds.<ol><li>If <tt><a>start</a> x <a>==</a>
--   <a>end</a> f</tt> then <tt>x <a>&lt;*</a> f</tt> is <a>valid</a> and
--   <tt><a>orientation</a> (x <a>&lt;*</a> f) <a>==</a> <a>start</a> f
--   <a>:&gt;</a> <a>end</a> x</tt>.</li><li>If <tt><a>start</a> x
--   <a>/=</a> <a>end</a> f</tt> then <tt>x <a>&lt;*</a> f</tt> is not
--   <a>valid</a> and its evaluation will end up in a <a>NotApplicable</a>
--   exception.</li></ol></li>
--   <li>For all <tt>x</tt> in <tt><b>x</b></tt> holds: <tt>x <a>&lt;*</a>
--   <a>one</a> (<a>start</a> x) <a>==</a> x</tt>.</li>
--   <li>For all <tt>x</tt> in <tt><b>x</b></tt> and <tt>f</tt>, <tt>g</tt>
--   in <tt><b>f</b></tt> with <tt><a>end</a> f <a>==</a> <a>start</a>
--   x</tt>, <tt><a>end</a> g <a>==</a> <a>start</a> f</tt> holds: <tt>x
--   <a>&lt;*</a> f <a>&lt;*</a> g <a>==</a> x <a>&lt;*</a> (f <a>*</a>
--   g)</tt>.</li>
--   </ol>
--   
--   <b>Note</b> If <tt>f</tt> is invertible, then it rise of a
--   <i>bijection</i> <tt><a>&lt;*</a> f</tt> from all <tt>x</tt> in
--   <tt><b>x</b></tt> with <tt><a>start</a> x <a>==</a> <a>end</a> f</tt>
--   to all <tt>y</tt> in <tt><b>x</b></tt> with <tt><a>start</a> y
--   <a>==</a> <a>start</a> f</tt>. Its inverse is given by
--   <tt><a>&lt;*</a> <a>invert</a> f</tt>.
class (Opr f x, Multiplicative f, Oriented x) => OrientedOpr f x

-- | left operation of a <a>Multiplicative</a> structure <tt><b>f</b></tt>
--   on a <a>Oriented</a> structure <tt><b>x</b></tt>.
--   
--   <b>Property</b> Let <tt><b>f</b></tt> be a <a>Multiplicative</a> and
--   <tt><b>x</b></tt> a <a>Oriented</a> structure, and <tt><b>f</b></tt>,
--   <tt><b>x</b></tt> an instance of <a>OrientedOpl</a>, then holds:
--   
--   <ol>
--   <li>For all <tt>f</tt> in <tt><b>f</b></tt> and <tt>x</tt> in
--   <tt><b>x</b></tt> holds.<ol><li>If <tt><a>end</a> x <a>==</a>
--   <a>start</a> f</tt> then <tt>f <a>*&gt;</a> x</tt> is <a>valid</a> and
--   <tt><a>orientation</a> (f <a>*&gt;</a> x) <a>==</a> <a>start</a> x
--   <a>:&gt;</a> <a>end</a> f</tt>.</li><li>If <tt><a>end</a> x <a>/=</a>
--   <a>start</a> f</tt> then <tt>f <a>*&gt;</a> x</tt> is not <a>valid</a>
--   and its evaluation will end up in a <a>NotApplicable</a>
--   exception.</li></ol></li>
--   <li>For all <tt>x</tt> in <tt><b>x</b></tt> holds: <tt><a>one</a>
--   (<a>end</a> x) <a>*&gt;</a> x<a>==</a> x</tt>.</li>
--   <li>For all <tt>x</tt> in <tt><b>x</b></tt> and <tt>f</tt>, <tt>g</tt>
--   in <tt><b>f</b></tt> with <tt><a>start</a> g <a>==</a> <a>end</a>
--   x</tt>, <tt><a>start</a> f <a>==</a> <a>end</a> g</tt> holds: <tt>f
--   <a>*&gt;</a> g <a>*&gt;</a> x <a>==</a> (f <a>*</a> g) <a>*&gt;</a> x
--   </tt>.</li>
--   </ol>
--   
--   <b>Note</b> If <tt>f</tt> is invertible, then it rise of a
--   <i>bijection</i> <tt>f <a>*&gt;</a></tt> from all <tt>x</tt> in
--   <tt><b>x</b></tt> with <tt><a>end</a> x <a>==</a> <a>start</a> f</tt>
--   to all <tt>y</tt> in <tt><b>x</b></tt> with <tt><a>end</a> y <a>==</a>
--   <a>end</a> f</tt>. Its inverse is given by <tt><a>invert</a> f
--   <a>*&gt;</a></tt>.
class (Opl f x, Multiplicative f, Oriented x) => OrientedOpl f x


-- | Propositions on <a>Multiplicative</a> structures.
module OAlg.Structure.Multiplicative.Proposition

-- | validity of the <a>Multiplicative</a> structure of <tt><b>c</b></tt>.
prpMlt :: Multiplicative c => XMlt c -> Statement

-- | random variable for <a>Multiplicative</a> structures.
--   
--   <b>Note</b> As the multiplication could by costly, it is recommended
--   to use a bounded random variable for <a>xMltN</a> which serves to
--   validate <a>npower</a>.
data XMlt c
XMlt :: X N -> X (Point c) -> X c -> X (Endo c) -> X (Mltp2 c) -> X (Mltp3 c) -> XMlt c
[xMltN] :: XMlt c -> X N
[xMltPoint] :: XMlt c -> X (Point c)
[xMltFactor] :: XMlt c -> X c
[xMltEndo] :: XMlt c -> X (Endo c)
[xMltMltp2] :: XMlt c -> X (Mltp2 c)
[xMltMltp3] :: XMlt c -> X (Mltp3 c)

-- | predicate for endos.
newtype Endo q
Endo :: q -> Endo q

-- | predicate for two multiplicable factors.
data Mltp2 c
Mltp2 :: c -> c -> Mltp2 c

-- | predicate for three multiplicable factors.
data Mltp3 c
Mltp3 :: c -> c -> c -> Mltp3 c

-- | validity of <a>one</a> according to
--   <a>OAlg.Structure.Multiplicative.Definition#Mlt1</a>.
prpMlt1 :: Multiplicative c => p c -> X (Point c) -> Statement

-- | validity of <a>*</a> according to
--   <a>OAlg.Structure.Multiplicative.Definition#Mlt2</a>.
prpMlt2 :: Multiplicative c => X (c, c) -> Statement

-- | validity of <a>*</a> for two multiplicable factors according to
--   <a>OAlg.Structure.Multiplicative.Definition#Mlt2_1</a>.
prpMlt2_1 :: Multiplicative c => Mltp2 c -> Statement

-- | validity of <a>*</a> for two not multiplicable factors according to
--   <a>OAlg.Structure.Multiplicative.Definition#Mlt2_2</a>.
prpMlt2_2 :: Multiplicative c => c -> c -> Statement

-- | validity according to
--   <a>OAlg.Structure.Multiplicative.Definition#Mlt3</a>.
prpMlt3 :: Multiplicative c => X c -> Statement

-- | validity according to
--   <a>OAlg.Structure.Multiplicative.Definition#Mlt4</a>.
prpMlt4 :: Multiplicative c => X (Mltp3 c) -> Statement

-- | validity of <a>npower</a> according to
--   <a>OAlg.Structure.Multiplicative.Definition#Mlt5</a>.
--   
--   <b>Note</b> As the multiplication can by very costly the random
--   variable for <tt><a>X</a> <a>N</a></tt> - which serves to check
--   <a>OAlg.Structure.Multiplicative.Definition#Mlt5_2</a> - has to be
--   chosen carefully.
prpMlt5 :: Multiplicative c => X N -> X c -> X (Endo c) -> Statement

-- | standard random variable for <a>Multiplicative</a> structures.
class XStandardMlt c
xStandardMlt :: XStandardMlt c => XMlt c

-- | random variable for <a>Multiplicative</a> structures.
xMlt :: Multiplicative c => XOrtSite d c -> X N -> X (Endo c) -> XMlt c

-- | random variable of two multiplicable factors.
xMltp2 :: Multiplicative c => XOrtSite d c -> X (Mltp2 c)

-- | random variable of three multiplicable factors.
xMltp3 :: Multiplicative c => XOrtSite d c -> X (Mltp3 c)

-- | the induced random variable for multiplicable structures.
xoMlt :: Multiplicative c => X N -> XOrtOrientation c -> XMlt c

-- | random variable for total <a>Multiplicative</a> structures.
xMltTtl :: Singleton (Point c) => X N -> X c -> XMlt c

-- | random variable for the <a>Multiplicative</a> structure of
--   <tt><a>Orientation</a> p</tt>.
xMltOrnt :: Entity p => X N -> X p -> XMlt (Orientation p)
instance GHC.Classes.Ord q => GHC.Classes.Ord (OAlg.Structure.Multiplicative.Proposition.Endo q)
instance GHC.Classes.Eq q => GHC.Classes.Eq (OAlg.Structure.Multiplicative.Proposition.Endo q)
instance GHC.Show.Show q => GHC.Show.Show (OAlg.Structure.Multiplicative.Proposition.Endo q)
instance GHC.Classes.Ord c => GHC.Classes.Ord (OAlg.Structure.Multiplicative.Proposition.Mltp2 c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (OAlg.Structure.Multiplicative.Proposition.Mltp2 c)
instance GHC.Show.Show c => GHC.Show.Show (OAlg.Structure.Multiplicative.Proposition.Mltp2 c)
instance GHC.Classes.Ord c => GHC.Classes.Ord (OAlg.Structure.Multiplicative.Proposition.Mltp3 c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (OAlg.Structure.Multiplicative.Proposition.Mltp3 c)
instance GHC.Show.Show c => GHC.Show.Show (OAlg.Structure.Multiplicative.Proposition.Mltp3 c)
instance OAlg.Structure.Multiplicative.Proposition.XStandardMlt OAlg.Data.Number.N
instance OAlg.Structure.Multiplicative.Proposition.XStandardMlt OAlg.Data.Number.Z
instance OAlg.Structure.Multiplicative.Proposition.XStandardMlt OAlg.Data.Number.Q
instance (OAlg.Entity.Definition.Entity p, OAlg.Data.Validable.XStandard p) => OAlg.Structure.Multiplicative.Proposition.XStandardMlt (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Oriented.Definition.Oriented c => OAlg.Data.Validable.Validable (OAlg.Structure.Multiplicative.Proposition.XMlt c)
instance OAlg.Structure.Oriented.Definition.Oriented c => OAlg.Data.Validable.Validable (OAlg.Structure.Multiplicative.Proposition.Mltp3 c)
instance OAlg.Structure.Oriented.Definition.Oriented c => OAlg.Data.Dualisable.Dualisable (OAlg.Structure.Multiplicative.Proposition.Mltp3 c)
instance OAlg.Structure.Oriented.Definition.Oriented c => OAlg.Data.Validable.Validable (OAlg.Structure.Multiplicative.Proposition.Mltp2 c)
instance OAlg.Structure.Oriented.Definition.Oriented c => OAlg.Data.Dualisable.Dualisable (OAlg.Structure.Multiplicative.Proposition.Mltp2 c)
instance OAlg.Structure.Oriented.Definition.Oriented q => OAlg.Data.Validable.Validable (OAlg.Structure.Multiplicative.Proposition.Endo q)


-- | <a>Multiplicative</a> structures.
module OAlg.Structure.Multiplicative


-- | fibred structures, i.e. type <tt><b>f</b></tt> with an associated root
--   type <tt><a>Root</a> <b>f</b></tt> such that every value in
--   <tt><b>f</b></tt> has a <a>root</a>.
module OAlg.Structure.Fibred.Definition

-- | types with a <a>Fibred</a> structure. An entity of a <a>Fibred</a>
--   structure will be called a <b>stalk</b>.
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>On should accept the <tt>default</tt> for <a>root</a> only for
--   <a>FibredOriented</a> structures!</li>
--   <li>For <a>Distributive</a> structures the only thing to be
--   implemented is the <a>Root</a> type and should be defined as
--   <tt><a>Root</a> d = <a>Orientation</a> p</tt> where-- <tt>p =
--   <a>Point</a> d</tt> (see the default implementation of
--   <a>root</a>).</li>
--   </ol>
class (Entity f, Entity (Root f)) => Fibred f where {
    
    -- | the type of roots.
    type Root f;
}

-- | the <a>root</a> of a stalk in <tt>f</tt>.
root :: Fibred f => f -> Root f

-- | the <a>root</a> of a stalk in <tt>f</tt>.
root :: (Fibred f, Root f ~ Orientation (Point f), Oriented f) => f -> Root f

-- | type representing the class of <a>Fibred</a> structures.
data Fbr

-- | transformable to <a>Fibred</a> structure.
class Transformable s Fbr => ForgetfulFbr s

-- | <a>Fibred</a> and <a>Oriented</a> structure with matching <a>root</a>
--   and <a>orientation</a>.
--   
--   <b>Property</b> Let <b><tt>d</tt></b> be a <a>FibredOriented</a>
--   structure, then holds: For all <tt>s</tt> in <b><tt>d</tt></b> holds:
--   <tt><a>root</a> s <a>==</a> <a>orientation</a> s</tt>.
--   
--   <b>Note</b> <a>FibredOriented</a> structures are required for
--   <a>Distributive</a> structures.
class (Fibred d, Oriented d, Root d ~ Orientation (Point d)) => FibredOriented d

-- | type representing the class of <a>FibredOriented</a> structures.
data FbrOrt

-- | transformable to <a>FibredOriented</a> structure.
class (ForgetfulFbr s, ForgetfulOrt s, Transformable s FbrOrt) => ForgetfulFbrOrt s

-- | type where the associated root type is ordered.
--   
--   <b>Note</b> Helper class to circumvent undecidable instances.
class Ord (Root f) => OrdRoot f

-- | type where the associated root type is a singleton.
class Singleton (Root f) => TotalRoot f

-- | a list in a <a>Fibred</a> structure having all the same <a>root</a>.
--   
--   <b>Definition</b> Let <b><tt>f</tt></b> be a <a>Fibred</a> structure
--   and <tt>s = <a>Sheaf</a> r [t 0 .. t (n-1)]</tt> a sheaf in
--   <b><tt><a>Sheaf</a> f</tt></b>, then <tt>s</tt> is <a>valid</a> if and
--   only if
--   
--   <ol>
--   <li><tt>r</tt> is <a>valid</a> and <tt>t i</tt> are valid for all
--   <tt>i = 0..n-1</tt>.</li>
--   <li><tt><a>root</a> (t i) <a>==</a> r</tt> for all <tt>i =
--   0..n-1</tt>.</li>
--   </ol>
--   
--   furthermore <tt>n</tt> is called the <b><i>length</i></b> of
--   <tt>s</tt>.
--   
--   If two sheafs have the same <a>root</a> then there stalks can be
--   composed - via <tt>(<a>++</a>)</tt> - to a new sheaf having the same
--   <a>root</a>. But as <tt>(<a>++</a>)</tt> is not commutative they are
--   equipped with a <a>Multiplicative</a> structure.
data Sheaf f
Sheaf :: Root f -> [f] -> Sheaf f
instance OAlg.Structure.Fibred.Definition.Fibred f => GHC.Show.Show (OAlg.Structure.Fibred.Definition.Sheaf f)
instance OAlg.Structure.Fibred.Definition.Fibred f => GHC.Classes.Eq (OAlg.Structure.Fibred.Definition.Sheaf f)
instance OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt OAlg.Structure.Fibred.Definition.FbrOrt
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Fibred.Definition.FbrOrt OAlg.Structure.Definition.Typ
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Fibred.Definition.FbrOrt OAlg.Entity.Definition.Ent
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Fibred.Definition.FbrOrt OAlg.Structure.Fibred.Definition.Fbr
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Fibred.Definition.FbrOrt OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Structure.Definition.ForgetfulTyp OAlg.Structure.Fibred.Definition.FbrOrt
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt OAlg.Structure.Fibred.Definition.FbrOrt
instance OAlg.Structure.Fibred.Definition.ForgetfulFbr OAlg.Structure.Fibred.Definition.FbrOrt
instance OAlg.Structure.Fibred.Definition.ForgetfulFbr OAlg.Structure.Fibred.Definition.Fbr
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Fibred.Definition.Fbr OAlg.Structure.Definition.Typ
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Fibred.Definition.Fbr OAlg.Entity.Definition.Ent
instance OAlg.Structure.Definition.ForgetfulTyp OAlg.Structure.Fibred.Definition.Fbr
instance Data.Foldable.Foldable OAlg.Structure.Fibred.Definition.Sheaf
instance OAlg.Structure.Fibred.Definition.Fibred f => OAlg.Data.Validable.Validable (OAlg.Structure.Fibred.Definition.Sheaf f)
instance OAlg.Structure.Fibred.Definition.Fibred f => OAlg.Entity.Definition.Entity (OAlg.Structure.Fibred.Definition.Sheaf f)
instance OAlg.Structure.Fibred.Definition.Fibred f => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Structure.Fibred.Definition.Sheaf f)
instance OAlg.Structure.Fibred.Definition.Fibred f => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Structure.Fibred.Definition.Sheaf f)
instance OAlg.Structure.Fibred.Definition.Fibred f => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Structure.Fibred.Definition.Sheaf f)
instance OAlg.Structure.Fibred.Definition.FibredOriented f => OAlg.Data.Dualisable.Dualisable (OAlg.Structure.Fibred.Definition.Sheaf f)
instance OAlg.Structure.Fibred.Definition.Fibred f => OAlg.Data.Canonical.Embeddable f (OAlg.Structure.Fibred.Definition.Sheaf f)
instance OAlg.Structure.Fibred.Definition.FibredOriented ()
instance OAlg.Structure.Fibred.Definition.FibredOriented GHC.Types.Int
instance OAlg.Structure.Fibred.Definition.FibredOriented GHC.Num.Integer.Integer
instance OAlg.Structure.Fibred.Definition.FibredOriented OAlg.Data.Number.N
instance OAlg.Structure.Fibred.Definition.FibredOriented OAlg.Data.Number.Z
instance OAlg.Structure.Fibred.Definition.FibredOriented OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Fibred.Definition.FibredOriented (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Fibred.Definition.FibredOriented f => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Data.Opposite.Op f)
instance OAlg.Structure.Fibred.Definition.FibredOriented f => OAlg.Structure.Fibred.Definition.FibredOriented (OAlg.Data.Opposite.Op f)
instance OAlg.Structure.Fibred.Definition.Fibred ()
instance OAlg.Structure.Fibred.Definition.Fibred GHC.Types.Int
instance OAlg.Structure.Fibred.Definition.Fibred GHC.Num.Integer.Integer
instance OAlg.Structure.Fibred.Definition.Fibred OAlg.Data.Number.N
instance OAlg.Structure.Fibred.Definition.Fibred OAlg.Data.Number.Z
instance OAlg.Structure.Fibred.Definition.Fibred OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Structure.Oriented.Definition.Orientation p)


-- | additive structures, i.e. structures with a <b>partially</b> defined
--   addition <tt>(<a>+</a>)</tt>.
module OAlg.Structure.Additive.Definition

-- | <a>Fibred</a> structures with a <b>partialy</b> defined
--   <b>addition</b> and having <a>zero</a> as the <b>neutral element</b>
--   of the summation. An entity of a <a>Additive</a> structure will be
--   called a <b>summand</b>.
--   
--   <b>Properties</b> Let <b><tt>a</tt></b> be a <a>Additive</a>
--   structure, then holds:
--   
--   <ol>
--   <li>For all <tt>r</tt> in <b><tt><a>Root</a> a</tt></b> holds:
--   <tt><a>root</a> (<a>zero</a> r) <a>==</a> r</tt>.</li>
--   <li>For all <tt>f</tt> and <tt>g</tt> in <b><tt>a</tt></b>
--   holds:<ol><li>If <tt><a>root</a> f <a>==</a> <a>root</a> g</tt> then
--   <tt>f <a>+</a> g</tt> is <a>valid</a> and <tt><a>root</a> (f <a>+</a>
--   g) <a>==</a> <a>root</a> f</tt>.</li><li>If <tt><a>root</a> f
--   <a>/=</a> <a>root</a> g</tt> then <tt>f <a>+</a> g</tt> is not
--   <a>valid</a> and its evaluation will end up in a
--   <a>NotAddable</a>-exception.</li></ol></li>
--   <li>For all <tt>f</tt>, <tt>g</tt> in <b><tt>a</tt></b> with
--   <tt><a>root</a> f <a>==</a> <a>root</a> g</tt> holds: <tt>f <a>+</a> g
--   <a>==</a> g <a>+</a> f</tt>.</li>
--   <li>For all <tt>f</tt> in <b><tt>a</tt></b> holds: <tt>f <a>+</a>
--   <a>zero</a> (<a>root</a> f) <a>==</a> f</tt></li>
--   <li>For all <tt>f</tt>, <tt>g</tt>, <tt>h</tt> in <b><tt>a</tt></b>
--   with <tt><a>root</a> f <a>==</a> <a>root</a> g <a>==</a> <a>root</a>
--   h</tt> holds: <tt>(f <a>+</a> g) <a>+</a> h <a>==</a> f <a>+</a> (g
--   <a>+</a> h)</tt>.</li>
--   <li>For all <tt>f</tt> in <tt>a</tt> and <tt>n</tt> in <b><a>N</a></b>
--   holds: <tt><a>ntimes</a> 0 f == <a>zero</a> (<a>root</a> f)</tt> and
--   <tt><a>ntimes</a> (n <a>+</a> 1) f <a>==</a> f <a>+</a> <a>ntimes</a>
--   n f</tt>.</li>
--   </ol>
class Fibred a => Additive a

-- | the neutral element associated to each <a>root</a>. If there is no
--   ambiguity for <tt><a>zero</a> r</tt> we will briefly denote it by
--   <tt>0 r</tt> or just <tt>0</tt>.
zero :: Additive a => Root a -> a

-- | the addition for two summands.
(+) :: Additive a => a -> a -> a

-- | <tt>n</tt> times of a summand.
ntimes :: Additive a => N -> a -> a
infixl 6 +

-- | the <a>zero</a> to a given root. The type <tt>p c</tt> serves only as
--   proxy and <a>zero'</a> is lazy in it.
--   
--   <b>Note</b> As <a>Point</a> may be a non-injective type family, the
--   type checker needs some times a little bit more information to pic the
--   right <a>zero</a>.
zero' :: Additive a => p a -> Root a -> a

-- | type representing the class of <a>Additive</a> structures.
data Add

-- | transformable to <a>Additive</a> structure.
class (ForgetfulFbr s, Transformable s Add) => ForgetfulAdd s

-- | <a>Additive</a> structures having for each summand an <b><i>additve
--   inverse</i></b>.
--   
--   <b>Properties</b> Let <b><tt>a</tt></b> be a <a>Additive</a>
--   structure, then holds:
--   
--   <ol>
--   <li>For all <tt>f</tt> in <b><tt>a</tt></b> holds: <tt><a>root</a>
--   (<a>negate</a> f) <a>==</a> <a>root</a> f</tt>.</li>
--   <li>For all <tt>f</tt> in <b><tt>a</tt></b> holds: <tt>f <a>+</a>
--   <a>negate</a> f == <a>zero</a> (<a>root</a> f)</tt>.</li>
--   <li>For all <tt>f</tt> and <tt>g</tt> in <b><tt>a</tt></b>
--   holds:<ol><li>If <tt><a>root</a> f <a>==</a> <a>root</a> g</tt> then
--   <tt>f <a>-</a> g</tt> is <a>valid</a> and <tt><a>root</a> (f <a>-</a>
--   g) <a>==</a> <a>root</a> f</tt>.</li><li>If <tt><a>root</a> f
--   <a>/=</a> <a>root</a> g</tt> then <tt>f <a>-</a> g</tt> is not
--   <a>valid</a> and its evaluation will end up in a
--   <a>NotAddable</a>-exception.</li></ol></li>
--   <li>For <tt>f</tt> and <tt>g</tt> in <b><tt>a</tt></b> with
--   <tt><a>root</a> f <a>==</a> <a>root</a> g</tt> holds: <tt>f <a>-</a> g
--   <a>==</a> f <a>+</a> <a>negate</a> g</tt>.</li>
--   <li>For all <tt>z</tt> in <a>Z</a> and <tt>f</tt> in <b><tt>a</tt></b>
--   holds:<ol><li>If <tt>0 <a>&lt;=</a> z</tt> then <tt><a>ztimes</a> z f
--   <a>==</a> <a>ntimes</a> (<a>prj</a> z) f</tt>.</li><li>If <tt>z
--   <a>&lt;</a> 0</tt> then <tt><a>ztimes</a> z f <a>==</a> <a>negate</a>
--   (<a>ntimes</a> (<a>prj</a> z) f)</tt>.</li></ol></li>
--   </ol>
class Additive a => Abelian a

-- | negation of a summand.
negate :: Abelian a => a -> a

-- | subtraction of two summands.
--   
--   <b>Properties</b>
(-) :: Abelian a => a -> a -> a

-- | <tt>z</tt> times of a sumand.
ztimes :: Abelian a => Z -> a -> a
infixl 6 -

-- | check for beeing <a>zero</a>.
isZero :: Additive a => a -> Bool

-- | type representing the class of <a>Abelian</a> structures.
data Abl

-- | transformable to <a>Abelian</a> structure.
class (ForgetfulFbr s, ForgetfulAdd s, Transformable s Abl) => ForgetfulAbl s
instance OAlg.Structure.Additive.Definition.ForgetfulAbl OAlg.Structure.Additive.Definition.Abl
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Additive.Definition.Abl OAlg.Structure.Definition.Typ
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Additive.Definition.Abl OAlg.Entity.Definition.Ent
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Additive.Definition.Abl OAlg.Structure.Fibred.Definition.Fbr
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Additive.Definition.Abl OAlg.Structure.Additive.Definition.Add
instance OAlg.Structure.Definition.ForgetfulTyp OAlg.Structure.Additive.Definition.Abl
instance OAlg.Structure.Fibred.Definition.ForgetfulFbr OAlg.Structure.Additive.Definition.Abl
instance OAlg.Structure.Additive.Definition.ForgetfulAdd OAlg.Structure.Additive.Definition.Abl
instance OAlg.Structure.Additive.Definition.ForgetfulAdd OAlg.Structure.Additive.Definition.Add
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Additive.Definition.Add OAlg.Structure.Definition.Typ
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Additive.Definition.Add OAlg.Entity.Definition.Ent
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Additive.Definition.Add OAlg.Structure.Fibred.Definition.Fbr
instance OAlg.Structure.Definition.ForgetfulTyp OAlg.Structure.Additive.Definition.Add
instance OAlg.Structure.Fibred.Definition.ForgetfulFbr OAlg.Structure.Additive.Definition.Add
instance OAlg.Structure.Additive.Definition.Abelian ()
instance OAlg.Structure.Additive.Definition.Abelian GHC.Types.Int
instance OAlg.Structure.Additive.Definition.Abelian GHC.Num.Integer.Integer
instance OAlg.Structure.Additive.Definition.Abelian OAlg.Data.Number.Z
instance OAlg.Structure.Additive.Definition.Abelian OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Additive.Definition.Abelian (OAlg.Structure.Oriented.Definition.Orientation p)
instance (OAlg.Structure.Additive.Definition.Abelian a, OAlg.Structure.Fibred.Definition.FibredOriented a) => OAlg.Structure.Additive.Definition.Abelian (OAlg.Data.Opposite.Op a)
instance OAlg.Structure.Additive.Definition.Additive ()
instance OAlg.Structure.Additive.Definition.Additive GHC.Types.Int
instance OAlg.Structure.Additive.Definition.Additive GHC.Num.Integer.Integer
instance OAlg.Structure.Additive.Definition.Additive OAlg.Data.Number.N
instance OAlg.Structure.Additive.Definition.Additive OAlg.Data.Number.Z
instance OAlg.Structure.Additive.Definition.Additive OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Additive.Definition.Additive (OAlg.Structure.Oriented.Definition.Orientation p)
instance (OAlg.Structure.Additive.Definition.Additive a, OAlg.Structure.Fibred.Definition.FibredOriented a) => OAlg.Structure.Additive.Definition.Additive (OAlg.Data.Opposite.Op a)
instance OAlg.Structure.Additive.Definition.Additive a => OAlg.Data.Canonical.Projectible a (OAlg.Structure.Fibred.Definition.Sheaf a)


-- | distributive structures, i.e. multiplicative structures with a
--   suitable additive structure.
module OAlg.Structure.Distributive.Definition

-- | <a>FibredOriented</a> structures equipped with an <a>Additive</a> and
--   <a>Multiplicative</a> structure satisfying the laws of
--   <b><i>distributivity</i></b>.
--   
--   <b>Properties</b> Let <tt><b>d</b></tt> be a <a>Distributive</a>
--   structure, then holds:
--   
--   <ol>
--   <li>For all <tt>g</tt> in <tt><b>d</b></tt> and <tt>r</tt> in
--   <tt><a>Root</a> <b>d</b></tt> with <tt><a>end</a> g <a>==</a>
--   <a>start</a> r</tt> holds: <tt><a>zero</a> r <a>*</a> g <a>==</a>
--   <a>zero</a> r'</tt> where <tt>r' <a>==</a> <a>start</a> g <a>:&gt;</a>
--   <a>end</a> r</tt>.</li>
--   <li>For all <tt>g</tt>, <tt>a</tt> and <tt>b</tt> in <tt><b>d</b></tt>
--   with <tt><a>root</a> a <a>==</a> <a>root</a> b</tt> and
--   <tt><a>start</a> a <a>==</a> <a>end</a> g</tt> holds: <tt>(a <a>+</a>
--   b) <a>*</a> g == a<a>*</a>g <a>+</a> b<a>*</a>g</tt>.</li>
--   <li>For all <tt>f</tt> in <tt><b>d</b></tt> and <tt>r</tt> in
--   <tt><a>Root</a> <b>d</b></tt> with <tt><a>start</a> f <a>==</a>
--   <a>end</a> r</tt> holds: <tt>f <a>*</a> <a>zero</a> r <a>==</a>
--   <a>zero</a> r'</tt> where <tt>r' = <a>start</a> r <a>:&gt;</a>
--   <a>end</a> f</tt>.</li>
--   <li>For all <tt>f</tt>, <tt>a</tt> and <tt>b</tt> in <tt><b>d</b></tt>
--   with <tt><a>root</a> a <a>==</a> <a>root</a> b</tt> and
--   <tt><a>start</a> f <a>==</a> <a>end</a> a</tt> holds: <tt>f<a>*</a>(a
--   <a>+</a> b) == f<a>*</a>a <a>+</a> f<a>*</a>b</tt>.</li>
--   </ol>
--   
--   <b>Note</b> If <tt><b>d</b></tt> is interpreted as a small category
--   <tt><b>C</b></tt> then it is usually called <b>preadditive</b>. If
--   <tt><b>d</b></tt> is also <a>Abelian</a> then <tt><b>C</b></tt> is
--   also usually called <b>abelian</b>.
class (FibredOriented d, Additive d, Multiplicative d) => Distributive d

-- | type representing the class of <a>Distributive</a> structures.
data Dst

-- | transformable to <a>Distributive</a> structure.
class (ForgetfulOrt s, ForgetfulMlt s, ForgetfulFbr s, ForgetfulAdd s, ForgetfulFbrOrt s, Transformable s Dst) => ForgetfulDst s

-- | transposable distributive structures.
--   
--   <b>Property</b> Let <tt><b>d</b></tt> be a
--   <a>TransposableDistributive</a> structure, then holds:
--   
--   <ol>
--   <li>For all <tt>r</tt> in <tt><a>Root</a> d</tt> holds:
--   <tt><a>transpose</a> (<a>zero</a> r) <a>==</a> <a>zero</a>
--   (<a>transpose</a> r)</tt></li>
--   <li>For all <tt>a</tt>, <tt>b</tt> in <tt><b>d</b></tt> with
--   <tt><a>root</a> a <a>==</a> <a>root</a> b</tt> holds:
--   <tt><a>transpose</a> (a <a>+</a> b) <a>==</a> <a>transpose</a> a
--   <a>+</a> <a>transpose</a> b</tt>.</li>
--   </ol>
class (TransposableMultiplicative d, Distributive d) => TransposableDistributive d
instance OAlg.Structure.Distributive.Definition.ForgetfulDst OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Distributive.Definition.Dst OAlg.Structure.Definition.Typ
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Distributive.Definition.Dst OAlg.Entity.Definition.Ent
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Distributive.Definition.Dst OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Distributive.Definition.Dst OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Distributive.Definition.Dst OAlg.Structure.Fibred.Definition.Fbr
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Distributive.Definition.Dst OAlg.Structure.Fibred.Definition.FbrOrt
instance OAlg.Structure.Definition.Transformable OAlg.Structure.Distributive.Definition.Dst OAlg.Structure.Additive.Definition.Add
instance OAlg.Structure.Definition.Transformable1 OAlg.Data.Opposite.Op OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Structure.Definition.TransformableOp OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Structure.Definition.ForgetfulTyp OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Structure.Multiplicative.Definition.ForgetfulMlt OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Structure.Fibred.Definition.ForgetfulFbr OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Structure.Additive.Definition.ForgetfulAdd OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Distributive.Definition.TransposableDistributive (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Distributive.Definition.TransposableDistributive OAlg.Data.Number.N
instance OAlg.Structure.Distributive.Definition.TransposableDistributive OAlg.Data.Number.Z
instance OAlg.Structure.Distributive.Definition.TransposableDistributive OAlg.Data.Number.Q
instance OAlg.Structure.Distributive.Definition.Distributive ()
instance OAlg.Structure.Distributive.Definition.Distributive GHC.Types.Int
instance OAlg.Structure.Distributive.Definition.Distributive GHC.Num.Integer.Integer
instance OAlg.Structure.Distributive.Definition.Distributive OAlg.Data.Number.N
instance OAlg.Structure.Distributive.Definition.Distributive OAlg.Data.Number.Z
instance OAlg.Structure.Distributive.Definition.Distributive OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Distributive.Definition.Distributive (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Distributive.Definition.Distributive d => OAlg.Structure.Distributive.Definition.Distributive (OAlg.Data.Opposite.Op d)


-- | propositions on <a>Fibred</a> structures.
module OAlg.Structure.Fibred.Proposition

-- | validity for <a>Fibred</a> structures.
prpFbr :: Fibred f => XFbr f -> Statement

-- | random variable for validating <a>Fibred</a> structures.
type XFbr = X

-- | validity for <a>FibredOriented</a> structures.
prpFbrOrt :: FibredOriented f => XFbrOrt f -> Statement

-- | random variable type for validating <a>FibredOriented</a> structures.
type XFbrOrt = X

-- | random variable for the <a>Fibred</a> structure of
--   <tt><a>Orientation</a> p</tt>.
xFbrOrnt :: X p -> XFbr (Orientation p)

-- | random variable for the <a>FibredOriented</a> structure of
--   <tt><a>Orientation</a> p</tt>.
xFbrOrtOrnt :: X p -> XFbrOrt (Orientation p)

-- | random variable of <a>XStalk</a> on <tt><a>Orientation</a>
--   <b>p</b></tt>.
xStalkOrnt :: X p -> XStalk (Orientation p)

-- | random variable for stalks.
data XStalk x
XStalk :: X (Root x) -> (Root x -> X x) -> XStalk x

-- | the underlying random variable of <a>root</a>s.
xRoot :: XStalk x -> X (Root x)

-- | random variable of sheafs in a <a>Fibred</a> structure all rooted in
--   the given root and with a length of either 0 - for empty <a>root</a>s
--   - or with the given length.
xSheafRootMax :: Fibred f => XStalk f -> N -> Root f -> X (Sheaf f)

-- | random variable of sheafs, all based on the given <a>root</a> and with
--   the given length.
xSheafRoot :: Additive a => XStalk a -> N -> Root a -> X (Sheaf a)

-- | random variable of sheafs, based on the underlying random variable of
--   roots, with a length of either 0 - for empty <a>root</a>s - or with
--   the given length.
xSheafMax :: Fibred f => XStalk f -> N -> X (Sheaf f)

-- | random variable of sheafs with the given length.
xSheaf :: Additive a => XStalk a -> N -> X (Sheaf a)

-- | the associated random variable for validating <a>Fibred</a>
--   structures.
xoFbr :: XOrtOrientation f -> XFbr f

-- | the associated random variable for validation <a>FibredOriented</a>
--   structures.
xoFbrOrt :: XOrtOrientation f -> XFbrOrt f


-- | fibred structures.
module OAlg.Structure.Fibred


-- | propositions on <a>Additive</a> structures.
module OAlg.Structure.Additive.Proposition

-- | relation of <a>isZero</a>.
relIsZero :: Additive a => a -> Statement

-- | validity of the <a>Additive</a> structure of <tt><b>a</b></tt>.
--   
--   <b>Note</b> For a good choice of <tt><a>X</a> <a>N</a></tt> see the
--   note of <a>prpAdd6</a>.
prpAdd :: Additive a => XAdd a -> Statement

-- | validtiy of <a>root</a> according to
--   <a>OAlg.Structure.Additive.Definition#Add1</a>.
prpAdd1 :: Additive a => p a -> X (Root a) -> Statement

-- | validtiy of two summands according to
--   <a>OAlg.Structure.Additive.Definition#Add2</a>.
prpAdd2 :: Additive a => X (a, a) -> Statement

-- | validity of <a>+</a> for two addable summands according to
--   <a>OAlg.Structure.Additive.Definition#Add2_1</a>.
prpAdd2_1 :: Additive a => Adbl2 a -> Statement

-- | validity of <a>+</a> for two not addable summands according to
--   <a>OAlg.Structure.Additive.Definition#Add2_2</a>.
prpAdd2_2 :: Additive a => a -> a -> Statement

-- | validtiy of two adable summands according to
--   <a>OAlg.Structure.Additive.Definition#Add3</a>.
prpAdd3 :: Additive a => X (Adbl2 a) -> Statement

-- | validtiy according to <a>OAlg.Structure.Additive.Definition#Add4</a>.
prpAdd4 :: Additive a => X a -> Statement

-- | validtiy of three adable summands according to
--   <a>OAlg.Structure.Additive.Definition#Add5</a>.
prpAdd5 :: Additive a => X (Adbl3 a) -> Statement

-- | validity of <a>ntimes</a> according to
--   <a>OAlg.Structure.Additive.Definition#Add6</a>.
prpAdd6 :: Additive a => X N -> X a -> Statement

-- | validity of the <a>Abelian</a> structure of <b><tt>a</tt></b>.
prpAbl :: Abelian a => XAbl a -> Statement

-- | validity according to <a>OAlg.Structure.Additive.Definition#Abl1</a>.
prpAbl1 :: Abelian a => X a -> Statement

-- | validity according to <a>OAlg.Structure.Additive.Definition#Abl2</a>.
prpAbl2 :: Abelian a => X a -> Statement

-- | validity of two summands according to
--   <a>OAlg.Structure.Additive.Definition#Abl3</a>.
prpAbl3 :: Abelian a => X (a, a) -> Statement

-- | validity of <a>-</a> for two addable summands according to
--   <a>OAlg.Structure.Additive.Definition#Abl3_1</a>.
prpAbl3_1 :: Abelian a => Adbl2 a -> Statement

-- | validity of <a>-</a> for two not addable summands according to
--   <a>OAlg.Structure.Additive.Definition#Abl3_2</a>.
prpAbl3_2 :: Abelian a => a -> a -> Statement

-- | validity of two summands according to
--   <a>OAlg.Structure.Additive.Definition#Abl4</a>.
prpAbl4 :: Abelian a => X (Adbl2 a) -> Statement

-- | validity of two summands according to
--   <a>OAlg.Structure.Additive.Definition#Abl5</a>.
prpAbl5 :: Abelian a => X Z -> X a -> Statement

-- | random variable for validating <a>Additive</a> structures.
data XAdd a
XAdd :: X N -> X (Root a) -> X a -> X (Adbl2 a) -> X (Adbl3 a) -> XAdd a

-- | predicate for two addable summands.
data Adbl2 a
Adbl2 :: a -> a -> Adbl2 a

-- | predicate for three addable summands.
data Adbl3 a
Adbl3 :: a -> a -> a -> Adbl3 a

-- | standard random variable for <a>Additive</a> structures.
class XStandardAdd a
xStandardAdd :: XStandardAdd a => XAdd a

-- | random variable for validating <a>Abelian</a> structures.
data XAbl a
XAbl :: X Z -> X a -> X (Adbl2 a) -> XAbl a

-- | random variable for total <a>Additive</a> structures.
xAddTtl :: Singleton (Root a) => X N -> X a -> XAdd a

-- | the induced random variable for <a>Additive</a> structures with the
--   given random variable to validate <a>ntimes</a>.
xoAdd :: FibredOriented a => X N -> XOrtOrientation a -> XAdd a

-- | the induced random variables for roots.
xoRoot :: FibredOriented a => XOrtOrientation a -> X (Root a)

-- | the induced random variable for two addable summands.
xoAdbl2 :: FibredOriented a => XOrtOrientation a -> X (Adbl2 a)

-- | the induced random variable for three addable summands.
xoAdbl3 :: FibredOriented a => XOrtOrientation a -> X (Adbl3 a)

-- | the induced random variable for <a>Abelian</a> structures with the
--   given random variable to validate <a>ztimes</a>.
xoAbl :: FibredOriented a => X Z -> XOrtOrientation a -> XAbl a

-- | the associated random variable for validating <a>Fibred</a>
--   structures.
xoFbr :: XOrtOrientation f -> XFbr f

-- | random variable for the <a>Additive</a> structure of
--   <tt><a>Orientation</a> <b>p</b></tt>.
xAddOrnt :: Entity p => X N -> X p -> XAdd (Orientation p)

-- | random variable for <a>Additive</a> structure.
xAddStalk :: Additive a => XStalk a -> X N -> XAdd a

-- | random variable of two addable summands rooted at the given root.
xStalkAdbl2 :: Additive a => XStalk a -> Root a -> X (Adbl2 a)

-- | random variable of three addable summands rooted in the given root.
xStalkAdbl3 :: Additive a => XStalk a -> Root a -> X (Adbl3 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (OAlg.Structure.Additive.Proposition.Adbl2 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (OAlg.Structure.Additive.Proposition.Adbl2 a)
instance GHC.Show.Show a => GHC.Show.Show (OAlg.Structure.Additive.Proposition.Adbl2 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (OAlg.Structure.Additive.Proposition.Adbl3 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (OAlg.Structure.Additive.Proposition.Adbl3 a)
instance GHC.Show.Show a => GHC.Show.Show (OAlg.Structure.Additive.Proposition.Adbl3 a)
instance OAlg.Structure.Additive.Definition.Additive a => OAlg.Data.Validable.Validable (OAlg.Structure.Additive.Proposition.XAbl a)
instance OAlg.Structure.Additive.Proposition.XStandardAdd OAlg.Data.Number.N
instance OAlg.Structure.Additive.Proposition.XStandardAdd OAlg.Data.Number.Z
instance OAlg.Structure.Additive.Proposition.XStandardAdd OAlg.Data.Number.Q
instance (OAlg.Entity.Definition.Entity p, OAlg.Data.Validable.XStandard p) => OAlg.Structure.Additive.Proposition.XStandardAdd (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Additive.Definition.Additive a => OAlg.Data.Validable.Validable (OAlg.Structure.Additive.Proposition.XAdd a)
instance OAlg.Structure.Fibred.Definition.Fibred a => OAlg.Data.Validable.Validable (OAlg.Structure.Additive.Proposition.Adbl3 a)
instance OAlg.Structure.Fibred.Definition.FibredOriented a => OAlg.Data.Dualisable.Dualisable (OAlg.Structure.Additive.Proposition.Adbl3 a)
instance OAlg.Structure.Fibred.Definition.Fibred a => OAlg.Data.Validable.Validable (OAlg.Structure.Additive.Proposition.Adbl2 a)
instance OAlg.Structure.Fibred.Definition.FibredOriented a => OAlg.Data.Dualisable.Dualisable (OAlg.Structure.Additive.Proposition.Adbl2 a)


-- | <a>Additive</a> structures.
module OAlg.Structure.Additive


-- | propositions about <a>Distributive</a> structure.
module OAlg.Structure.Distributive.Proposition

-- | validity for the <a>Distributive</a> structure of the type <tt>a</tt>.
prpDst :: Distributive d => XDst d -> Statement

-- | random variable for validating <a>Distributive</a> structures.
data XDst d
XDst :: X (DstRootSide LeftSide d) -> X (DstSide LeftSide d) -> X (DstRootSide RightSide d) -> X (DstSide RightSide d) -> XDst d

-- | validity according to <a>OAlg.Structure.Distributive#Dst1</a>.
prpDst1 :: Distributive d => X (DstRootSide LeftSide d) -> Statement

-- | validity according to <a>OAlg.Structure.Distributive#Dst2</a>.
prpDst2 :: Distributive d => X (DstSide LeftSide d) -> Statement

-- | validity according to <a>OAlg.Structure.Distributive#Dst3</a>.
prpDst3 :: Distributive d => X (DstRootSide RightSide d) -> Statement

-- | validity according to <a>OAlg.Structure.Distributive#Dst4</a>.
prpDst4 :: Distributive d => X (DstSide RightSide d) -> Statement

-- | predicate for a root and a factor at the root.
--   
--   <b>Properties</b> Let <tt>p</tt> be in <tt><a>DstRootSide</a> <b>s</b>
--   <b>d</b></tt> for a <a>Distributive</a> structure <tt><b>d</b></tt>,
--   then holds:
--   
--   <ol>
--   <li>If <tt>p</tt> matches <tt><a>LDstRoot</a> r f</tt> then holds:
--   <tt><a>start</a> r <a>==</a> <a>end</a> f</tt>.</li>
--   <li>If <tt>p</tt> matches <tt><a>RDstRoot</a> f r</tt> then holds:
--   <tt><a>start</a> f <a>==</a> <a>end</a> r</tt>.</li>
--   </ol>
data DstRootSide (s :: Side) d
[LDstRoot] :: Root d -> d -> DstRootSide LeftSide d
[RDstRoot] :: d -> Root d -> DstRootSide RightSide d

-- | predicate for two addable summands together with a matching factor.
--   
--   <b>Properties</b> Let <tt>p</tt> be in <tt><a>DstSide</a> <b>s</b>
--   <b>d</b></tt> for a <a>Distributive</a> structure, then holds:
--   
--   <ol>
--   <li>If <tt>p</tt> matches <tt><a>LDst</a> (a,b) g</tt> then
--   holds:<ol><li><tt><a>root</a> a <a>==</a> <a>root</a>
--   b</tt>.</li><li><tt><a>start</a> a <a>==</a> <a>end</a>
--   g</tt>.</li></ol></li>
--   <li>If <tt>p</tt> matches <tt><a>RDst</a> f (a,b)</tt> then
--   holds:<ol><li><tt><a>root</a> a <a>==</a> <a>root</a>
--   b</tt>.</li><li><tt><a>start</a> f <a>==</a> <a>end</a>
--   a</tt>.</li></ol></li>
--   </ol>
data DstSide (s :: Side) d
[LDst] :: (d, d) -> d -> DstSide LeftSide d
[RDst] :: d -> (d, d) -> DstSide RightSide d

-- | standard random variable for <a>Distributive</a> structures.
class XStandardDst d
xStandardDst :: XStandardDst d => XDst d

-- | the induced random variable for <a>Distributive</a> structures.
xDstStalkStartEnd :: Distributive m => XStalk m -> XOrtSite From m -> XOrtSite To m -> XDst m

-- | random variable to validate <a>Total</a> <a>Distributive</a>
--   structures.
xDstTtl :: Singleton (Root m) => X m -> XDst m

-- | random variable for the <a>Distributive</a> structure of
--   <tt><a>Orientation</a> <b>p</b></tt>.
xDstOrnt :: Entity p => X p -> XDst (Orientation p)

-- | the induced random variable for <a>Distributive</a> structures.
xoDst :: Distributive d => XOrtOrientation d -> XOrtSite From d -> XOrtSite To d -> XDst d

-- | distribution of <tt><a>XDst</a> <b>d</b></tt>.
dstDst :: Distributive d => Int -> XDst d -> IO ()
instance OAlg.Structure.Distributive.Definition.Distributive d => GHC.Show.Show (OAlg.Structure.Distributive.Proposition.DstRootSide s d)
instance OAlg.Structure.Distributive.Definition.Distributive d => GHC.Show.Show (OAlg.Structure.Distributive.Proposition.DstSide s d)
instance OAlg.Structure.Distributive.Proposition.XStandardDst OAlg.Data.Number.N
instance OAlg.Structure.Distributive.Proposition.XStandardDst OAlg.Data.Number.Z
instance OAlg.Structure.Distributive.Proposition.XStandardDst OAlg.Data.Number.Q
instance (OAlg.Entity.Definition.Entity p, OAlg.Data.Validable.XStandard p) => OAlg.Structure.Distributive.Proposition.XStandardDst (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Distributive.Definition.Distributive d => OAlg.Data.Dualisable.Dualisable (OAlg.Structure.Distributive.Proposition.DstSide 'OAlg.Data.Dualisable.RightSide d)
instance OAlg.Structure.Distributive.Definition.Distributive d => OAlg.Data.Validable.Validable (OAlg.Structure.Distributive.Proposition.DstSide s d)
instance OAlg.Structure.Distributive.Definition.Distributive d => OAlg.Data.Dualisable.Dualisable (OAlg.Structure.Distributive.Proposition.DstRootSide 'OAlg.Data.Dualisable.RightSide d)
instance OAlg.Structure.Distributive.Definition.Distributive d => OAlg.Data.Validable.Validable (OAlg.Structure.Distributive.Proposition.DstRootSide s d)


-- | <a>Distributive</a> structures.
module OAlg.Structure.Distributive


-- | definition of homomorphisms between <a>Oriented</a> structures.
module OAlg.Hom.Oriented.Definition

-- | type family of homomorphisms between <a>Oriented</a> structures.
--   
--   <b>Property</b> Let <tt><b>h</b></tt> be an instance of
--   <a>HomOriented</a>, then for all <tt><b>a</b></tt>, <tt><b>b</b></tt>
--   and <tt>f</tt> in <tt><b>h</b></tt> <tt><b>a</b></tt>
--   <tt><b>b</b></tt> and <tt>x</tt> in <tt><b>a</b></tt> holds:
--   <tt><a>start</a> (<a>amap</a> f x) <a>==</a> <a>pmap</a> f
--   (<a>start</a> x)</tt> and <tt><a>end</a> (<a>amap</a> f x) <a>==</a>
--   <a>pmap</a> f (<a>end</a> x)</tt>.
--   
--   We call such a <tt><b>h</b></tt> a <b><i>family of homomorphisms
--   between oriented structures</i></b> and an entity <tt>f</tt> in
--   <tt><b>h</b></tt> <tt><b>a</b></tt> <tt><b>b</b></tt> a
--   <b><i>covariant oriented homomorphism</i></b> - or <b><i>oriented
--   homomorphism</i></b> for short - <b><i>between</i></b>
--   <tt><b>a</b></tt> <b><i>and</i></b> <tt><b>b</b></tt>. A covariant
--   oriented homomorphism <tt>f</tt> in <tt><b>h</b> (<a>Op</a> <b>a</b>)
--   <b>b</b></tt> or <tt><b>h</b> <b>a</b> (<a>Op</a> <b>b</b>)</tt> will
--   be called a <b><i>contravariant oriented homomorphism between</i></b>
--   <tt><b>a</b></tt> <b><i>and</i></b> <tt><b>b</b></tt>.
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>As <tt><b>h</b></tt> is an instance of
--   <tt><a>EmbeddableMorphism</a> <b>h</b> <a>Ort</a></tt> it follows that
--   for all <tt><b>a</b></tt>, <tt><b>b</b></tt> and <tt>f</tt> in
--   <tt><b>h a b</b></tt> holds: <tt><a>tauHom</a> (<a>homomorphous</a> f)
--   :: <a>Homomorphous</a> <a>Ort</a> <b>a</b> <b>b</b></tt> and thus
--   <tt><b>a</b></tt> and <tt><b>b</b></tt> are <a>Oriented</a>
--   structures! How to work with this concretely see the implementation of
--   <a>prpHomOrt</a> where the property above is stated.</li>
--   <li>The constraint <a>EmbeddableMorphismTyp</a> for a family
--   <tt><b>h</b></tt> of homomorphisms between <a>Oriented</a> structures
--   ensures that the type <tt><a>Path</a> <b>h</b></tt> is a instances of
--   <a>Eq2</a>.</li>
--   </ol>
class (EmbeddableMorphism h Ort, Applicative h, Entity2 h, EmbeddableMorphismTyp h, Transformable1 Op (ObjectClass h)) => HomOriented h
pmap :: HomOriented h => h a b -> Point a -> Point b

-- | the induced mapping of <a>Orientation</a>.
omap :: HomOriented h => h a b -> Orientation (Point a) -> Orientation (Point b)

-- | <tt>s</tt>-isomoprhisms.
type IsoOrt s h = (FunctorialHomOriented h, Cayleyan2 h, Hom s h)

-- | isomorphisms between <a>Oriented</a> structures.
type IsoOriented h = (FunctorialHomOriented h, Cayleyan2 h)

-- | functorial application on <a>Oriented</a> structures.
--   
--   <b>Properties</b> Let <tt><b>h</b></tt> be an instance of the class
--   <a>FunctorialHomOriented</a>, then holds:
--   
--   <ol>
--   <li>For all types <tt><b>a</b></tt> and <tt>s</tt> in
--   <tt><a>Struct</a> (<a>ObjectClass</a> <b>h</b>) <b>a</b></tt> holds:
--   <tt><a>pmap</a> (<a>cOne</a> s) = <a>id</a></tt>.</li>
--   <li>For all types <tt><b>a</b></tt>, <tt><b>b</b></tt>,
--   <tt><b>c</b></tt> and <tt>f</tt> in <tt><b>h</b></tt>
--   <tt><b>b</b></tt> <tt><b>c</b></tt>, <tt>g</tt> in <tt><b>h</b></tt>
--   <tt><b>a</b></tt> <tt><b>b</b></tt> holds: <tt><a>pmap</a> (f <a>.</a>
--   g) = <a>pmap</a> f <a>.</a> <a>pmap</a> g</tt>.</li>
--   </ol>
class (Category h, Functorial h, HomOriented h) => FunctorialHomOriented h

-- | identity morphism.
data IdHom s a b
[IdHom] :: Structure s a => IdHom s a a

-- | induced homomorphism on <a>Op</a>.
data OpHom h x y
[OpHom] :: Transformable1 Op (ObjectClass h) => h x y -> OpHom h (Op x) (Op y)

-- | some basic contravariant isomorphisms between
--   <tt><b>s</b></tt>-structures with there <a>invert2</a>.
data HomOp s a b
[FromOpOp] :: (Structure s (Op (Op a)), Structure s a) => HomOp s (Op (Op a)) a
[ToOpOp] :: (Structure s (Op (Op a)), Structure s a) => HomOp s a (Op (Op a))
[OpPath] :: (Structure s a, Structure s (Op (Path a)), Structure s (Path (Op a))) => HomOp s (Op (Path a)) (Path (Op a))
[OpPathInv] :: (Structure s a, Structure s (Op (Path a)), Structure s (Path (Op a))) => HomOp s (Path (Op a)) (Op (Path a))
[Opposite] :: (Structure s (Op (Orientation p)), Structure s (Orientation p)) => HomOp s (Op (Orientation p)) (Orientation p)
[OppositeInv] :: (Structure s (Op (Orientation p)), Structure s (Orientation p)) => HomOp s (Orientation p) (Op (Orientation p))

-- | isomorphisms induced by paths of <a>HomOp</a>.
data IsoOp s a b

-- | paths of <a>HomOp</a>.
type PathHomOp s a b = Path (HomOp s) a b

-- | the induced isomorphism given by <a>OpPath</a>.
opPathOrt :: Oriented a => IsoOp Ort (Op (Path a)) (Path (Op a))

-- | the induced isomorphism of <a>Oriented</a> structures given by
--   <a>FromOpOp</a>.
--   
--   <b>Examples</b>
--   
--   <pre>
--   let tOS = invert2 (isoFromOpOpOrt :: IsoOp Ort (Op (Op OS)) OS)
--   let f = isoFromOpOpOrt :: Oriented a =&gt;IsoOp Ort (Op (Op a)) a
--   let t = invert2 f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tOS
--   IsoOp Path[ToOpOp]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; t . t . tOS
--   IsoOp Path[ToOpOp,ToOpOp,ToOpOp]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f . f . t . f . t . tOS
--   IsoOp Path[]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f . f . t . f . t . tOS == cOne Struct
--   True
--   </pre>
isoFromOpOpOrt :: Oriented a => IsoOp Ort (Op (Op a)) a

-- | isomorphisms induced by paths of <a>OpMap</a>.
data IsoOpMap f s a b

-- | paths of <a>OpMap</a>.
type PathOpMap f s = Path (OpMap f s)

-- | contravariant <tt><b>s</b></tt>-isomorphisms between <tt><b>f</b>
--   <b>x</b></tt> and <tt><b>f</b> (<a>Op</a> <b>x</b>)</tt>.
data OpMap f s a b

-- | contravariant <tt><b>s</b></tt>-isomorphism from <b><tt>f x</tt></b>
--   to <tt><b>f</b> (<a>Op</a> <b>x</b>)</tt>.
[ToOp1] :: (Structure s (Op (f x)), Structure s (f (Op x)), Structure s x) => OpMap f s (Op (f x)) (f (Op x))

-- | the inverse of <a>ToOp1</a>.
[FromOp1] :: (Structure s (Op (f x)), Structure s (f (Op x)), Structure s x) => OpMap f s (f (Op x)) (Op (f x))

-- | structural attest for <a>ToOp1</a>.
toOp1Struct :: OpMap f s (Op (f x)) (f (Op x)) -> Struct s x

-- | structural attest for <a>FromOp1</a>.
fromOp1Struct :: OpMap f s (f (Op x)) (Op (f x)) -> Struct s x

-- | contravariant isomorphism from <tt><a>Path</a> <b>x</b></tt> to
--   <tt><a>Path</a> (<a>Op</a><b>x</b>)</tt> .
isoCoPath :: Oriented x => IsoOpMap Path Ort (Op (Path x)) (Path (Op x))
instance (OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Entity.Definition.Entity2 (OAlg.Hom.Oriented.Definition.IsoOp s)
instance (OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => OAlg.Entity.Definition.Entity (OAlg.Hom.Oriented.Definition.IsoOp s a b)
instance OAlg.Structure.Definition.ForgetfulTyp s => OAlg.Data.Equal.Eq2 (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Structure.Definition.ForgetfulTyp s => GHC.Classes.Eq (OAlg.Hom.Oriented.Definition.IsoOp s a b)
instance OAlg.Data.Validable.Validable2 (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Data.Validable.Validable (OAlg.Hom.Oriented.Definition.IsoOp s a b)
instance OAlg.Data.Show.Show2 (OAlg.Hom.Oriented.Definition.IsoOp s)
instance GHC.Show.Show (OAlg.Hom.Oriented.Definition.IsoOp s a b)
instance (OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable s) => OAlg.Entity.Definition.Entity2 (OAlg.Hom.Oriented.Definition.IsoOpMap f s)
instance (OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => OAlg.Entity.Definition.Entity (OAlg.Hom.Oriented.Definition.IsoOpMap f s a b)
instance OAlg.Structure.Definition.ForgetfulTyp s => OAlg.Data.Equal.Eq2 (OAlg.Hom.Oriented.Definition.IsoOpMap f s)
instance OAlg.Structure.Definition.ForgetfulTyp s => GHC.Classes.Eq (OAlg.Hom.Oriented.Definition.IsoOpMap f s a b)
instance OAlg.Data.Validable.Validable2 (OAlg.Hom.Oriented.Definition.IsoOpMap f s)
instance OAlg.Data.Validable.Validable (OAlg.Hom.Oriented.Definition.IsoOpMap f s a b)
instance OAlg.Data.Show.Show2 (OAlg.Hom.Oriented.Definition.IsoOpMap f s)
instance GHC.Show.Show (OAlg.Hom.Oriented.Definition.IsoOpMap f s a b)
instance GHC.Show.Show (OAlg.Hom.Oriented.Definition.IdHom s a b)
instance GHC.Classes.Eq (OAlg.Hom.Oriented.Definition.IdHom s a b)
instance GHC.Show.Show (OAlg.Hom.Oriented.Definition.HomOp s a b)
instance GHC.Classes.Eq (OAlg.Hom.Oriented.Definition.HomOp s a b)
instance GHC.Show.Show (OAlg.Hom.Oriented.Definition.OpMap f s a b)
instance GHC.Classes.Eq (OAlg.Hom.Oriented.Definition.OpMap f s a b)
instance OAlg.Data.Show.Show2 h => OAlg.Data.Show.Show2 (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Data.Equal.Eq2 h => OAlg.Data.Equal.Eq2 (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Data.Validable.Validable2 h => OAlg.Data.Validable.Validable2 (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Entity.Definition.Entity2 h => OAlg.Entity.Definition.Entity2 (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Category.Definition.Morphism h => OAlg.Category.Definition.Morphism (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Category.Applicative.Applicative h => OAlg.Category.Applicative.Applicative (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Category.Definition.EmbeddableMorphism h OAlg.Structure.Oriented.Definition.Ort => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.OpHom h) OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Category.Definition.EmbeddableMorphism h OAlg.Structure.Definition.Typ => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.OpHom h) OAlg.Structure.Definition.Typ
instance OAlg.Category.Definition.EmbeddableMorphism h OAlg.Structure.Multiplicative.Definition.Mlt => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.OpHom h) OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Category.Definition.EmbeddableMorphism h OAlg.Structure.Fibred.Definition.Fbr => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.OpHom h) OAlg.Structure.Fibred.Definition.Fbr
instance OAlg.Category.Definition.EmbeddableMorphism h OAlg.Structure.Fibred.Definition.FbrOrt => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.OpHom h) OAlg.Structure.Fibred.Definition.FbrOrt
instance OAlg.Category.Definition.EmbeddableMorphism h OAlg.Structure.Additive.Definition.Add => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.OpHom h) OAlg.Structure.Additive.Definition.Add
instance OAlg.Category.Definition.EmbeddableMorphism h OAlg.Structure.Distributive.Definition.Dst => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.OpHom h) OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Category.Definition.EmbeddableMorphismTyp h => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Hom.Oriented.Definition.HomOriented h => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Data.Constructable.Exposable (OAlg.Hom.Oriented.Definition.IsoOpMap f s a b)
instance OAlg.Data.Constructable.Constructable (OAlg.Hom.Oriented.Definition.IsoOpMap f s a b)
instance OAlg.Category.Definition.Morphism (OAlg.Hom.Oriented.Definition.IsoOpMap f s)
instance OAlg.Structure.Definition.Transformable s t => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.IsoOpMap f s) t
instance OAlg.Structure.Definition.ForgetfulTyp s => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Hom.Oriented.Definition.IsoOpMap f s)
instance OAlg.Category.Definition.Category (OAlg.Hom.Oriented.Definition.IsoOpMap f s)
instance OAlg.Structure.Definition.ForgetfulTyp s => OAlg.Category.Definition.Cayleyan2 (OAlg.Hom.Oriented.Definition.IsoOpMap f s)
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt s => OAlg.Category.Applicative.Applicative (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Structure.Oriented.Definition.Path s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Oriented.Definition.ForgetfulOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Structure.Oriented.Definition.Path s)
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt s => OAlg.Category.Definition.Functorial (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Structure.Oriented.Definition.Path s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Oriented.Definition.ForgetfulOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.FunctorialHomOriented (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Structure.Oriented.Definition.Path s)
instance OAlg.Data.Reducible.Reducible (OAlg.Hom.Oriented.Definition.PathOpMap f s a b)
instance OAlg.Category.Definition.Morphism (OAlg.Hom.Oriented.Definition.OpMap f s)
instance OAlg.Structure.Definition.Transformable s t => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.OpMap f s) t
instance OAlg.Structure.Definition.ForgetfulTyp s => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Hom.Oriented.Definition.OpMap f s)
instance OAlg.Data.Show.Show2 (OAlg.Hom.Oriented.Definition.OpMap f s)
instance OAlg.Data.Equal.Eq2 (OAlg.Hom.Oriented.Definition.OpMap f s)
instance OAlg.Data.Validable.Validable (OAlg.Hom.Oriented.Definition.OpMap f s a b)
instance OAlg.Data.Validable.Validable2 (OAlg.Hom.Oriented.Definition.OpMap f s)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => OAlg.Entity.Definition.Entity (OAlg.Hom.Oriented.Definition.OpMap f s a b)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable s) => OAlg.Entity.Definition.Entity2 (OAlg.Hom.Oriented.Definition.OpMap f s)
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt s => OAlg.Category.Applicative.Applicative (OAlg.Hom.Oriented.Definition.OpMap OAlg.Structure.Oriented.Definition.Path s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Oriented.Definition.ForgetfulOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Hom.Oriented.Definition.OpMap OAlg.Structure.Oriented.Definition.Path s)
instance OAlg.Data.Constructable.Exposable (OAlg.Hom.Oriented.Definition.IsoOp s a b)
instance OAlg.Data.Constructable.Constructable (OAlg.Hom.Oriented.Definition.IsoOp s a b)
instance OAlg.Category.Definition.Morphism (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Structure.Definition.Transformable s t => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.IsoOp s) t
instance OAlg.Structure.Definition.ForgetfulTyp s => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Category.Definition.Category (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Structure.Definition.ForgetfulTyp s => OAlg.Category.Definition.Cayleyan2 (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt s => OAlg.Category.Applicative.Applicative (OAlg.Hom.Oriented.Definition.IsoOp s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Oriented.Definition.ForgetfulOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt s => OAlg.Category.Definition.Functorial (OAlg.Hom.Oriented.Definition.IsoOp s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Oriented.Definition.ForgetfulOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.FunctorialHomOriented (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Data.Reducible.Reducible (OAlg.Hom.Oriented.Definition.PathHomOp s a b)
instance OAlg.Category.Definition.Morphism (OAlg.Hom.Oriented.Definition.HomOp s)
instance OAlg.Structure.Definition.Transformable s t => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.HomOp s) t
instance OAlg.Structure.Definition.ForgetfulTyp s => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Hom.Oriented.Definition.HomOp s)
instance OAlg.Data.Show.Show2 (OAlg.Hom.Oriented.Definition.HomOp s)
instance OAlg.Data.Equal.Eq2 (OAlg.Hom.Oriented.Definition.HomOp s)
instance OAlg.Data.Validable.Validable (OAlg.Hom.Oriented.Definition.HomOp s a b)
instance OAlg.Data.Validable.Validable2 (OAlg.Hom.Oriented.Definition.HomOp s)
instance (Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => OAlg.Entity.Definition.Entity (OAlg.Hom.Oriented.Definition.HomOp s a b)
instance Data.Typeable.Internal.Typeable s => OAlg.Entity.Definition.Entity2 (OAlg.Hom.Oriented.Definition.HomOp s)
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt s => OAlg.Category.Applicative.Applicative (OAlg.Hom.Oriented.Definition.HomOp s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Oriented.Definition.ForgetfulOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Hom.Oriented.Definition.HomOp s)
instance OAlg.Category.Definition.Morphism (OAlg.Hom.Oriented.Definition.IdHom s)
instance OAlg.Structure.Definition.Transformable s t => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Hom.Oriented.Definition.IdHom s) t
instance OAlg.Structure.Definition.ForgetfulTyp s => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Hom.Oriented.Definition.IdHom s)
instance OAlg.Data.Show.Show2 (OAlg.Hom.Oriented.Definition.IdHom s)
instance OAlg.Data.Equal.Eq2 (OAlg.Hom.Oriented.Definition.IdHom s)
instance OAlg.Data.Validable.Validable (OAlg.Hom.Oriented.Definition.IdHom s a b)
instance OAlg.Data.Validable.Validable2 (OAlg.Hom.Oriented.Definition.IdHom s)
instance (Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => OAlg.Entity.Definition.Entity (OAlg.Hom.Oriented.Definition.IdHom s a b)
instance Data.Typeable.Internal.Typeable s => OAlg.Entity.Definition.Entity2 (OAlg.Hom.Oriented.Definition.IdHom s)
instance OAlg.Category.Definition.Category (OAlg.Hom.Oriented.Definition.IdHom s)
instance OAlg.Category.Definition.Cayleyan2 (OAlg.Hom.Oriented.Definition.IdHom s)
instance OAlg.Category.Applicative.Applicative (OAlg.Hom.Oriented.Definition.IdHom s)
instance OAlg.Category.Definition.Functorial (OAlg.Hom.Oriented.Definition.IdHom s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Oriented.Definition.ForgetfulOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Hom.Oriented.Definition.IdHom s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Oriented.Definition.ForgetfulOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.FunctorialHomOriented (OAlg.Hom.Oriented.Definition.IdHom s)
instance OAlg.Hom.Oriented.Definition.FunctorialHomOriented h => OAlg.Hom.Oriented.Definition.FunctorialHomOriented (OAlg.Category.Path.Path h)
instance OAlg.Hom.Oriented.Definition.HomOriented h => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Category.Path.Path h)
instance (OAlg.Hom.Oriented.Definition.HomOriented h, OAlg.Structure.Definition.Transformable1 OAlg.Data.Opposite.Op t, OAlg.Structure.Oriented.Definition.ForgetfulOrt t, OAlg.Structure.Definition.ForgetfulTyp t, Data.Typeable.Internal.Typeable t) => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Category.Definition.Forget t h)


-- | propositions on homomorphisms between <a>Oriented</a> structures.
module OAlg.Hom.Oriented.Proposition

-- | validity of <tt><a>IdHom</a> <a>Ort</a></tt> to be a family of
--   <a>Oriented</a> homomorphisms between <tt><a>Orientation</a>
--   <a>Symbol</a></tt> and <a>Z</a>.
prpIdHomOrt :: Statement

-- | validity of <tt><a>HomOp</a> <a>Ort</a></tt> according to
--   <a>HomOriented</a> on <tt><a>Orientation</a> <a>Symbol</a></tt>.
prpHomOpOrt :: Statement

-- | validity of <tt><a>IsoOp</a> <a>Ort</a></tt> according to
--   <a>Category</a> on <tt><a>Orientation</a> <a>Symbol</a></tt>.
prpIsoOpOrtCategory :: Statement

-- | validity of <tt><a>IsoOp</a> <a>Ort</a></tt> according
--   <a>Functorial</a>.
prpIsoOpOrtFunctorial :: Statement

-- | validity of homomorphisms between <a>Oriented</a> structures based on
--   the given random variable.
prpHomOrt :: Hom Ort h => XHomOrt h -> Statement

-- | random variable to validate homomorphisms between <a>Oriented</a>
--   structures.
type XHomOrt h = XAppl h

-- | validity of homomorphisms between <a>Oriented</a> structures based on
--   the given random variable.
prpHomOrt' :: Hom Ort h => h a b -> XOrt a -> Statement

-- | validity of homomorphisms between <a>Oriented</a> structures based on
--   the given values.
prpHomOrt1 :: Hom Ort h => h a b -> a -> Statement

-- | validity of homomorphisms between <a>Oriented</a> for a given value in
--   the domain.
relHomOrtHomomorphous :: Hom Ort h => Homomorphous Ort a b -> h a b -> a -> Statement

-- | random variale of <tt><a>IsoOp</a> <a>Ort</a></tt>.
xIsoOpOrtFrom :: XFnctMrphSite From (IsoOp Ort)


-- | homomorphism between <a>Oriented</a> structures.
module OAlg.Hom.Oriented


-- | homomorphisms between <a>Fibred</a> structures
module OAlg.Hom.Fibred

-- | type family of homomorphisms between <a>Fibred</a> structures.
--   
--   <b>Property</b> Let <tt>h</tt> be an instance of <a>HomFibred</a> then
--   for all <tt><b>a</b></tt>, <tt><b>b</b></tt> and <tt>f</tt> in
--   <tt><b>h</b> <b>a</b> <b>b</b></tt> and <tt>x</tt> in
--   <tt><b>a</b></tt> holds: <tt><a>root</a> (<a>amap</a> f x) <a>==</a>
--   <a>rmap</a> f (<a>root</a> x)</tt>.
class (EmbeddableMorphism h Fbr, Applicative h, Entity2 h, EmbeddableMorphismTyp h) => HomFibred h
rmap :: HomFibred h => h a b -> Root a -> Root b
rmap :: (HomFibred h, EmbeddableMorphism h FbrOrt, HomOriented h) => h a b -> Root a -> Root b

-- | functorial application of <a>Fibred</a> homomorphisms.
class (Category h, Functorial h, HomFibred h) => FunctorialHomFibred h

-- | type family of homomorphisms between <a>FibredOriented</a> structures.
--   
--   <b>Property</b> Let <tt>h</tt> be an instance of
--   <a>HomFibredOriented</a> then for all <tt><b>a</b></tt>,
--   <tt><b>b</b></tt> and <tt>f</tt> in <tt><b>h</b> <b>a</b>
--   <b>b</b></tt> and <tt>r</tt> in <tt><a>Root</a> <b>a</b></tt> holds:
--   <tt><a>rmap</a> f r <a>==</a> <a>omap</a> f r</tt>.
class (EmbeddableMorphism h FbrOrt, HomFibred h, HomOriented h) => HomFibredOriented h

-- | validity according to <a>HomFibredOriented</a>.
prpHomFbrOrt :: HomFibredOriented h => h a b -> Root a -> Statement
instance OAlg.Hom.Fibred.HomFibredOriented h => OAlg.Hom.Fibred.HomFibredOriented (OAlg.Category.Path.Path h)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibredOriented (OAlg.Hom.Oriented.Definition.IdHom s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibredOriented (OAlg.Hom.Oriented.Definition.HomOp s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibredOriented (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Hom.Fibred.HomFibredOriented h => OAlg.Hom.Fibred.HomFibred (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Hom.Fibred.HomFibredOriented h => OAlg.Hom.Fibred.HomFibredOriented (OAlg.Hom.Oriented.Definition.OpHom h)
instance OAlg.Hom.Fibred.FunctorialHomFibred h => OAlg.Hom.Fibred.FunctorialHomFibred (OAlg.Category.Path.Path h)
instance OAlg.Hom.Fibred.HomFibred h => OAlg.Hom.Fibred.HomFibred (OAlg.Category.Path.Path h)
instance (OAlg.Structure.Fibred.Definition.ForgetfulFbr s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibred (OAlg.Hom.Oriented.Definition.IdHom s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibred (OAlg.Hom.Oriented.Definition.HomOp s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibred (OAlg.Hom.Oriented.Definition.IsoOp s)


-- | homomorphisms between <a>Additive</a> structures
module OAlg.Hom.Additive

-- | type family of homomorphisms between <a>Additive</a> structures.
--   
--   <b>Property</b> Let <tt><b>h</b></tt> be a type instance of the class
--   <a>HomAdditive</a>, then for all <tt><b>a</b></tt>, <tt><b>b</b></tt>
--   and <tt>f</tt> in <tt><b>h</b></tt> <tt><b>a</b></tt>
--   <tt><b>b</b></tt> holds:
--   
--   <ol>
--   <li>For all <tt>r</tt> in <tt><a>Root</a> <b>a</b></tt> holds:
--   <tt><a>amap</a> f (<a>zero</a> r) <a>==</a> <a>zero</a> (<a>rmap</a> f
--   r)</tt>.</li>
--   <li>For all <tt>x</tt> and <tt>y</tt> in <tt><b>a</b></tt> with
--   <tt><a>root</a> x <a>==</a> <a>root</a> y</tt> holds: <tt><a>amap</a>
--   f (x <a>+</a> y) ) <a>==</a> <a>amap</a> f x <a>+</a> <a>amap</a> f
--   y</tt>.</li>
--   </ol>
--   
--   Such a <tt><b>h</b></tt> will be called a <b><i>family of
--   homomorphisms between additive structures</i></b> and an entity
--   <tt>f</tt> of <tt><b>h</b></tt> <tt><b>a</b></tt> <tt><b>b</b></tt> a
--   <b><i>additive homomorphism</i></b> between <tt><b>a</b></tt> and
--   <tt><b>b</b></tt>.
class (EmbeddableMorphism h Add, HomFibred h) => HomAdditive h

-- | validity according to <a>OAlg.Hom.Additive#HomAdd1</a>.
prpHomAdd1 :: HomAdditive h => h a b -> Root a -> Statement

-- | validity according to <a>OAlg.Hom.Additive#HomAdd2</a>.
prpHomAdd2 :: HomAdditive h => h a b -> Adbl2 a -> Statement
instance OAlg.Hom.Additive.HomAdditive h => OAlg.Hom.Additive.HomAdditive (OAlg.Category.Path.Path h)
instance (OAlg.Structure.Additive.Definition.ForgetfulAdd s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Additive.HomAdditive (OAlg.Hom.Oriented.Definition.IdHom s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt s, OAlg.Structure.Additive.Definition.ForgetfulAdd s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Additive.HomAdditive (OAlg.Hom.Oriented.Definition.HomOp s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt s, OAlg.Structure.Additive.Definition.ForgetfulAdd s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Additive.HomAdditive (OAlg.Hom.Oriented.Definition.IsoOp s)
instance (OAlg.Hom.Additive.HomAdditive h, OAlg.Hom.Fibred.HomFibredOriented h) => OAlg.Hom.Additive.HomAdditive (OAlg.Hom.Oriented.Definition.OpHom h)


-- | definition of homomorphisms between <a>Multiplicative</a> structures.
module OAlg.Hom.Multiplicative.Definition

-- | type family of homomorphisms between <a>Multiplicative</a> structures.
--   
--   <b>Propoerty</b> Let <b><tt>h</tt></b> be a type instance of the class
--   <a>HomMultiplicative</a>, then for all <b><tt>a</tt></b>,
--   <b><tt>b</tt></b> and <tt>f</tt> in <b><tt>h</tt></b>
--   <b><tt>a</tt></b> <b><tt>b</tt></b> holds:
--   
--   <ol>
--   <li>For all <tt>p</tt> in <tt><a>Point</a> <b>a</b></tt> holds:
--   <tt><a>amap</a> f (<a>one</a> p) <a>==</a> <a>one</a> (<a>pmap</a> f
--   p)</tt>.</li>
--   <li>For all <tt>x</tt>, <tt>y</tt> in <b><tt>a</tt></b> with
--   <tt><a>start</a> x <a>==</a> <a>end</a> y</tt> holds: <tt><a>amap</a>
--   f (x <a>*</a> y) <a>==</a> <a>amap</a> f x <a>*</a> <a>amap</a> f
--   y</tt>.</li>
--   </ol>
--   
--   Such a <b><tt>h</tt></b> will be called a <b><i>family of
--   homomorphisms between multiplicative structures</i></b> and an entity
--   <tt>f</tt> of <b><tt>h</tt></b> <b><tt>a</tt></b> <b><tt>b</tt></b> a
--   <b><i>multiplicative homomorphism</i></b> between <b><tt>a</tt></b>
--   and <b><tt>b</tt></b>.
--   
--   <b>Note</b> If we interpret the types <tt><b>a</b></tt> and
--   <tt><b>b</b></tt> as small categories (see note at
--   <a>Multiplicative</a>) then we can interpret the type family
--   <tt><b>h</b></tt> as a family of covariant functors.
class (EmbeddableMorphism h Mlt, HomOriented h) => HomMultiplicative h

-- | isomorphisms between <a>Multiplicative</a> structures.
type IsoMultiplicative h = (FunctorialHomOriented h, Cayleyan2 h, HomMultiplicative h)

-- | the induced isomorphism of <a>Multiplicative</a> structures given by
--   <a>FromOpOp</a>.
isoFromOpOpMlt :: Multiplicative a => IsoOp Mlt (Op (Op a)) a

-- | the induced isomorphism of <a>Oriented</a> structures given by
--   <a>Opposite</a>.
isoOppositeMlt :: Entity p => IsoOp Mlt (Op (Orientation p)) (Orientation p)
instance OAlg.Hom.Multiplicative.Definition.HomMultiplicative h => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Category.Path.Path h)
instance (OAlg.Hom.Multiplicative.Definition.HomMultiplicative h, OAlg.Structure.Definition.Transformable1 OAlg.Data.Opposite.Op t, OAlg.Structure.Multiplicative.Definition.ForgetfulMlt t, OAlg.Structure.Definition.ForgetfulTyp t, Data.Typeable.Internal.Typeable t) => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Category.Definition.Forget t h)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Multiplicative.Definition.ForgetfulMlt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Hom.Oriented.Definition.IdHom s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Multiplicative.Definition.ForgetfulMlt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Hom.Oriented.Definition.HomOp s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Multiplicative.Definition.ForgetfulMlt s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Hom.Multiplicative.Definition.HomMultiplicative h => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Hom.Oriented.Definition.OpHom h)


-- | propositions on homomorphisms between <a>Multiplicative</a>
--   structures.
module OAlg.Hom.Multiplicative.Proposition

-- | validity of <tt><a>HomOp</a> <a>Mlt</a></tt> to be a family of
--   <a>Multiplicative</a> homomorphisms.
prpHomOpMlt :: Statement

-- | validity of homomorphisms between <a>Multiplicative</a> structures
--   according to <a>OAlg.Hom.Multiplicative#HomMlt</a>.
prpHomMlt :: Hom Mlt h => XHomMlt h -> Statement

-- | random variable for validating a type family <tt><b>h</b></tt>
--   according to <a>HomMultiplicative</a>.
data XHomMlt h
XHomMlt :: X (SomeApplPnt h) -> X (SomeApplMltp2 h) -> XHomMlt h

-- | to the dual of <tt><a>XHomMlt</a> <b>h</b></tt> with its inverse
--   <a>coXHomMltInv</a>.
coXHomMlt :: HomMultiplicative h => XHomMlt h -> Dual (XHomMlt h)

-- | from the dual of <tt><a>Dual</a> (<a>XHomMlt</a> <b>h</b>)</tt> with
--   its inverse <a>coXHomMlt</a>.
coXHomMltInv :: HomMultiplicative h => Dual (XHomMlt h) -> XHomMlt h

-- | some application on a point.
data SomeApplPnt h
[SomeApplPnt] :: h a b -> Point a -> SomeApplPnt h

-- | to the dual of <tt><a>SomeApplPnt</a> <b>h</b></tt> with its inverse
--   <a>coSomeApplPntInv</a>.
coSomeApplPnt :: Transformable1 Op (ObjectClass h) => SomeApplPnt h -> Dual (SomeApplPnt h)

-- | from the dual of <tt><a>Dual</a> (<a>SomeApplPnt</a> <b>h</b>)</tt>
--   with its inverse <a>coSomeApplPnt</a>.
coSomeApplPntInv :: Dual (SomeApplPnt h) -> SomeApplPnt h

-- | some application on multiplicable factors.
data SomeApplMltp2 h
[SomeApplMltp2] :: h a b -> Mltp2 a -> SomeApplMltp2 h

-- | to the dual of <tt><a>SomeApplMltp2</a> <b>h</b></tt> with its inverse
--   <a>coSomeApplMltp2Inv</a>.
coSomeApplMltp2 :: HomMultiplicative h => SomeApplMltp2 h -> Dual (SomeApplMltp2 h)

-- | from the dual of <tt><a>Dual</a> (<a>SomeApplMltp2</a> <b>h</b>)</tt>
--   with its inverse <a>coSomeApplMltp2</a>.
coSomeApplMltp2Inv :: HomMultiplicative h => Dual (SomeApplMltp2 h) -> SomeApplMltp2 h

-- | validity according to <a>OAlg.Hom.Multiplicative#HomMlt1</a>.
prpHomMlt1 :: Hom Mlt h => h a b -> Point a -> Statement

-- | validity according to <a>OAlg.Hom.Multiplicative#HomMlt2</a>.
prpHomMlt2 :: Hom Mlt h => h a b -> Mltp2 a -> Statement

-- | the induced random variable of <a>XHomMlt</a>, given by
--   <a>SomeApplMlt</a>.
xHomMlt :: Hom Mlt h => SomeApplMlt d h -> XHomMlt h

-- | the induced random variable of <a>XHomMlt</a>.
xHomMlt' :: h a b -> XMlt a -> XHomMlt h

-- | random variable for some application on a point given by a
--   <a>SomeApplMlt</a>.
xSomeApplPnt :: SomeApplMlt d h -> X (SomeApplPnt h)

-- | random variable for some application on multiplicable factors given by
--   a <a>SomeApplMlt</a>.
xSomeApplMltp2 :: Hom Mlt h => SomeApplMlt d h -> X (SomeApplMltp2 h)


-- | homomorphisms between <a>Multiplicative</a> structures.
module OAlg.Hom.Multiplicative


-- | propositions on homomorphisms between algerbaic structure.
module OAlg.Hom.Proposition

-- | validity of <tt><a>IdHom</a> <b>s</b></tt> according to
--   <a>Category</a> and <a>HomOriented</a>.
prpIdHom :: Statement

-- | validity of <tt><a>HomOp</a> <b>s</b></tt> according to
--   <a>Category</a>, <a>HomOriented</a> and <a>HomMultiplicative</a>.
prpHomOp :: Statement

-- | validity of <tt><a>IsoOp</a> <a>Ort</a></tt> according to
--   <a>Category</a> and <a>Functorial</a>.
prpIsoOpOrt :: Statement


-- | homomorphisms between <a>Distributive</a> structure.
module OAlg.Hom.Distributive

-- | type family of homomorphisms between <a>Distributive</a> structures.
class (EmbeddableMorphism h Dst, HomFibredOriented h, HomMultiplicative h, HomAdditive h) => HomDistributive h

-- | isomorphisms between <a>Distributive</a> structures.
type IsoDistributive h = (FunctorialHomOriented h, Cayleyan2 h, HomDistributive h)

-- | the induced isomorphism of <a>Distributive</a> structures given by
--   <a>FromOpOp</a>.
isoFromOpOpDst :: Distributive a => IsoOp Dst (Op (Op a)) a
instance OAlg.Hom.Distributive.HomDistributive h => OAlg.Hom.Distributive.HomDistributive (OAlg.Category.Path.Path h)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Distributive.HomDistributive (OAlg.Hom.Oriented.Definition.IdHom s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Distributive.HomDistributive (OAlg.Hom.Oriented.Definition.HomOp s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Distributive.HomDistributive (OAlg.Hom.Oriented.Definition.IsoOp s)
instance OAlg.Hom.Distributive.HomDistributive h => OAlg.Hom.Distributive.HomDistributive (OAlg.Hom.Oriented.Definition.OpHom h)


-- | natural numbers promotable to type-level. They serve to parameterize
--   the length of finite lists on type-level (see
--   <a>OAlg.Entity.FinList</a>).
--   
--   <b>Note</b> We need the language extension
--   <tt>UndecidableInstances</tt> for type checking the definition
--   
--   <pre>
--   N0 * m = N0
--   S n * m = m + n * m
--   </pre>
--   
--   for the type family <a>*</a>.
--   
--   Using <tt>UndecidableInstances</tt> could cause the type checker to
--   not terminate, but this will obviously not happen for the given
--   definition (we also use the same definition for the multiplicative
--   structure of <a>N'</a>).
module OAlg.Entity.Natural

-- | natural number promotable to type-level.
data N'
N0 :: N'
S :: N' -> N'

-- | mapping a natural number in <a>N</a> to <a>N'</a>.
toN' :: N -> N'

-- | addition of natural numbers.
type family (+) (n :: N') (m :: k) :: N'
infixr 6 +

-- | multiplication of natural numbers.
type family (*) (n :: k) (m :: N') :: N'
infixr 7 *

-- | attest for any natural number.
class Typeable n => Attestable n
attest :: Attestable n => W n

-- | witness of being attestable.
data Ats n
[Ats] :: Attestable n => Ats n

-- | the corresponding natural number in <a>N</a> of a type parameterized
--   by <tt><b>n</b></tt>.
nValue :: Attestable n => p n -> N

-- | witness for a natural number and serves for inductively definable
--   elements (see <a>induction</a>).
data W n
[W0] :: W N0
[SW] :: W n -> W (n + 1)

-- | comparing of two witnesses.
cmpW :: W n -> W m -> Ordering

-- | addition of witnesses.
(++) :: W n -> W m -> W (n + m)
infixr 6 ++

-- | multiplication of witnesses.
(**) :: W n -> W m -> W (n * m)
infixr 7 **

-- | union of all witnesses, which is isomorphic to <a>N</a> and <a>N'</a>.
data W'
W' :: W n -> W'

-- | mapping a natural value in <a>N</a> to <a>W'</a>.
toW' :: N -> W'

-- | witnesse of some natural.
data SomeNatural
[SomeNatural] :: Attestable n => W n -> SomeNatural

-- | successor of some natural number.
succSomeNatural :: SomeNatural -> SomeNatural

-- | mapping <a>N</a> to <a>SomeNatural</a>.
--   
--   <b>Note</b> The implementation of this mapping is quite inefficent for
--   high values of <a>N</a>.
someNatural :: N -> SomeNatural

-- | the infinite list of some naturals.
naturals :: [SomeNatural]

-- | induction for general type functions.
induction :: Any n -> f N0 -> (forall i. f i -> f (i + 1)) -> f n

-- | predicate for any natural number.
type Any = W

-- | some witness.
type Some = W'

-- | reflexivity.
refl :: Any x -> x :~: x

-- | well definition of parameterized types.
lemma1 :: (x :~: y) -> f x :~: f y

-- | substitution rule for addition.
sbstAdd :: (a :~: a') -> (b :~: b') -> (a + b) :~: (a' + b')

-- | <tt>0</tt> is right neural for the addition.
prpAdd0 :: (a + 0) :~: a

-- | adding <tt>1</tt> is equal to the successor.
prpAdd1 :: (a + 1) :~: S a

-- | adding <tt>2</tt> is equal to the successor of the successor.
prpAdd2 :: (a + 2) :~: S (S a)

-- | equality of the underlying natural number.
prpEqlAny :: (Any n :~: Any m) -> n :~: m

-- | <a>Any</a> is as parameterized type is well defined.
prpEqlAny' :: (n :~: m) -> Any n :~: Any m

-- | successor is injective.
prpSuccInjective :: (S n :~: S m) -> n :~: m

-- | <a>N0</a> is left neutral for the addition.
prpAddNtrlL :: p a -> (N0 + a) :~: a

-- | <a>N0</a> is the right neutral for the addition.
prpAddNtrlR :: Any a -> (a + N0) :~: a

-- | addition is associative.
prpAddAssoc :: Any a -> Any b -> Any c -> ((a + b) + c) :~: (a + (b + c))

-- | lemma 1 for the addition.
lemmaAdd1 :: Any a -> Any b -> (S a + b) :~: (a + S b)

-- | addition is commutative.
prpAddComm :: Any a -> Any b -> (a + b) :~: (b + a)

-- | <a>N1</a> is left neutral for the multiplication.
prpMltNtrlL :: Any a -> (N1 * a) :~: a

-- | <a>N1</a> is right neutral for the multiplication.
prpMltNtrlR :: Any a -> (a * N1) :~: a

-- | law of left distributivity holds.
prpDstrL :: Any a -> Any b -> Any c -> ((a + b) * c) :~: ((a * c) + (b * c))

-- | multiplication is associative.
prpMltAssoc :: Any a -> Any b -> Any c -> ((a * b) * c) :~: (a * (b * c))

-- | right multiplication of <a>N0</a> is <a>N0</a>.
lemmaMlt1 :: Any a -> (a * N0) :~: N0

-- | lemma 2 for addition.
lemmaAdd2 :: Any a -> Any b -> Any c -> (a + (b + c)) :~: (b + (a + c))

-- | law of right distributivity holds.
prpDstrR :: Any a -> Any b -> Any c -> (a * (b + c)) :~: ((a * b) + (a * c))

-- | multiplication is commutative.
prpMltComm :: Any a -> Any b -> (a * b) :~: (b * a)

-- | <tt>codeW n m</tt> generates the haskell code for the witnesses
--   <a>W</a> of <a>N'</a> from <tt>n</tt> to <tt>m</tt>.
codeW :: N -> N -> String

-- | <tt>itfW n m</tt> generates the haskell interface for the witnesses
--   <a>W</a> from <tt>n</tt> to <tt>m</tt>.
itfW :: N -> N -> String

-- | <tt>0</tt>.
type N0 = 'N0

-- | <tt>1</tt>.
type N1 = S N0

-- | <tt>2</tt>.
type N2 = S N1

-- | <tt>3</tt>.
type N3 = S N2

-- | <tt>4</tt>.
type N4 = S N3

-- | <tt>5</tt>.
type N5 = S N4

-- | <tt>6</tt>.
type N6 = S N5

-- | <tt>7</tt>.
type N7 = S N6

-- | <tt>8</tt>.
type N8 = S N7

-- | <tt>9</tt>.
type N9 = S N8

-- | <tt>10</tt>.
type N10 = S N9

-- | the induced random variable for some natural number.
xSomeNatural :: X N -> X SomeNatural
instance GHC.Show.Show OAlg.Entity.Natural.N'
instance GHC.Classes.Ord OAlg.Entity.Natural.N'
instance GHC.Classes.Eq OAlg.Entity.Natural.N'
instance GHC.Classes.Eq (OAlg.Entity.Natural.W n)
instance GHC.Show.Show OAlg.Entity.Natural.W'
instance GHC.Show.Show OAlg.Entity.Natural.SomeNatural
instance GHC.Classes.Eq OAlg.Entity.Natural.SomeNatural
instance OAlg.Data.Validable.Validable OAlg.Entity.Natural.SomeNatural
instance OAlg.Entity.Natural.Attestable OAlg.Entity.Natural.N0
instance OAlg.Entity.Natural.Attestable n => OAlg.Entity.Natural.Attestable ('OAlg.Entity.Natural.S n)
instance GHC.Classes.Eq OAlg.Entity.Natural.W'
instance GHC.Classes.Ord OAlg.Entity.Natural.W'
instance OAlg.Data.Number.LengthN OAlg.Entity.Natural.W'
instance GHC.Enum.Enum OAlg.Entity.Natural.W'
instance OAlg.Data.Validable.Validable OAlg.Entity.Natural.W'
instance OAlg.Entity.Definition.Entity OAlg.Entity.Natural.W'
instance OAlg.Structure.Oriented.Definition.Oriented OAlg.Entity.Natural.W'
instance OAlg.Structure.Multiplicative.Definition.Multiplicative OAlg.Entity.Natural.W'
instance OAlg.Structure.Fibred.Definition.Fibred OAlg.Entity.Natural.W'
instance OAlg.Structure.Fibred.Definition.FibredOriented OAlg.Entity.Natural.W'
instance OAlg.Structure.Additive.Definition.Additive OAlg.Entity.Natural.W'
instance OAlg.Structure.Distributive.Definition.Distributive OAlg.Entity.Natural.W'
instance OAlg.Structure.Multiplicative.Definition.Commutative OAlg.Entity.Natural.W'
instance OAlg.Structure.Oriented.Definition.Total OAlg.Entity.Natural.W'
instance GHC.Show.Show (OAlg.Entity.Natural.W n)
instance OAlg.Data.Validable.Validable (OAlg.Entity.Natural.W n)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Natural.W n)
instance OAlg.Data.Number.LengthN OAlg.Entity.Natural.N'
instance GHC.Enum.Enum OAlg.Entity.Natural.N'
instance OAlg.Data.Validable.Validable OAlg.Entity.Natural.N'
instance OAlg.Entity.Definition.Entity OAlg.Entity.Natural.N'
instance OAlg.Structure.Oriented.Definition.Oriented OAlg.Entity.Natural.N'
instance OAlg.Structure.Multiplicative.Definition.Multiplicative OAlg.Entity.Natural.N'
instance OAlg.Structure.Fibred.Definition.Fibred OAlg.Entity.Natural.N'
instance OAlg.Structure.Fibred.Definition.FibredOriented OAlg.Entity.Natural.N'
instance OAlg.Structure.Additive.Definition.Additive OAlg.Entity.Natural.N'
instance OAlg.Structure.Distributive.Definition.Distributive OAlg.Entity.Natural.N'
instance OAlg.Structure.Multiplicative.Definition.Commutative OAlg.Entity.Natural.N'
instance OAlg.Structure.Oriented.Definition.Total OAlg.Entity.Natural.N'


-- | finite lists, parameterized by there length.
module OAlg.Entity.FinList

-- | finite lists, parameterized by there length.
data FinList (n :: N') a
[Nil] :: FinList N0 a
[:|] :: a -> FinList n a -> FinList (n + 1) a
infixr 5 :|

-- | the underlying witness.
toW :: FinList n a -> W n

-- | the head of a non empty finite list.
head :: FinList (n + 1) a -> a

-- | the tail of a non empty finite list.
tail :: FinList (n + 1) a -> FinList n a

-- | zips two sequences of the same length.
zip :: FinList n a -> FinList n b -> FinList n (a, b)

-- | zips three sequences of the same length.
zip3 :: FinList n a -> FinList n b -> FinList n c -> FinList n (a, b, c)

-- | appending an element at the end of the finite list.
(|:) :: FinList n a -> a -> FinList (n + 1) a
infixl 5 |:

-- | appending two finite lists.
(++) :: FinList n a -> FinList m a -> FinList (n + m) a
infixr 5 ++

-- | the product of two finite lists.
(**) :: FinList n a -> FinList m b -> FinList (n * m) (a, b)

-- | the constant sequence.
repeat :: Any n -> a -> FinList n a

-- | indexing finite lists, starting at the given natural number.
iFinList :: N -> FinList n a -> FinList n (a, N)

-- | adjoins to each element its index, starting from '0'.
iFinList0 :: FinList n a -> FinList n (a, N)

-- | the sequence 0,1 .. n-1.
iFinList' :: Any n -> FinList n N

-- | maps a sequnece <tt>as = a0..a(n-1)</tt> of length <tt>n</tt> to the
--   corresponding array <tt>a</tt> with <tt>ai <a>==</a> a<a>$</a>i</tt>
--   for <tt>i = 0..(n-1)</tt>.
toArray :: FinList n a -> Array N a

-- | the associated finite list.
someFinList :: [a] -> SomeFinList a

-- | some finite list.
data SomeFinList a
SomeFinList :: FinList n a -> SomeFinList a

-- | concatenation.
(<++>) :: SomeFinList x -> SomeFinList x -> SomeFinList x
infixr 5 <++>

-- | induction for sequences.
inductionS :: Any n -> FinList N0 a -> (forall i. FinList i a -> FinList (i + 1) a) -> FinList n a

-- | Wrapper to switch the parameters.
newtype FinList' a n
FinList' :: FinList n a -> FinList' a n
instance GHC.Show.Show a => GHC.Show.Show (OAlg.Entity.FinList.FinList n a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (OAlg.Entity.FinList.FinList n a)
instance Data.Foldable.Foldable (OAlg.Entity.FinList.FinList n)
instance GHC.Classes.Ord x => GHC.Classes.Ord (OAlg.Entity.FinList.FinList n x)
instance GHC.Show.Show a => GHC.Show.Show (OAlg.Entity.FinList.SomeFinList a)
instance GHC.Base.Functor OAlg.Entity.FinList.SomeFinList
instance GHC.Base.Functor (OAlg.Entity.FinList.FinList n)
instance OAlg.Data.Validable.Validable a => OAlg.Data.Validable.Validable (OAlg.Entity.FinList.FinList n a)
instance (Data.Typeable.Internal.Typeable n, OAlg.Entity.Definition.Entity a) => OAlg.Entity.Definition.Entity (OAlg.Entity.FinList.FinList n a)


-- | the underlying <a>Quiver</a> of a <a>Diagram</a>.
module OAlg.Entity.Diagram.Quiver

-- | quiver of <tt>n</tt> points and <tt>m</tt> arrows.
--   
--   <b>Property</b> Let <tt>Quiver w o</tt> be in <tt><a>Quiver</a>
--   <b>n</b> <b>m</b></tt>, then holds: For all <tt>0 <a>&lt;=</a> j
--   <a>&lt;</a> m</tt> holds: <tt>s j <a>&lt;</a> n</tt> and <tt>e j
--   <a>&lt;</a> n</tt> where <tt>n = <a>lengthN</a> w</tt>, <tt>s j =
--   <a>start</a> (o j)</tt> and <tt>e j = <a>end</a> (o j)</tt>.
data Quiver n m
Quiver :: Any n -> FinList m (Orientation N) -> Quiver n m

-- | the orientation of the arrows of a quiver.
qvOrientations :: Quiver n m -> FinList m (Orientation N)

-- | the dual of a quiver, with inverse <a>coQuiverInv</a>.
coQuiver :: Quiver n m -> Dual (Quiver n m)

-- | from the dual quiver, with inverse <a>coQuiver</a>.
coQuiverInv :: Dual (Quiver n m) -> Quiver n m
instance GHC.Classes.Eq (OAlg.Entity.Diagram.Quiver.Quiver n m)
instance GHC.Show.Show (OAlg.Entity.Diagram.Quiver.Quiver n m)
instance OAlg.Data.Validable.Validable (OAlg.Entity.Diagram.Quiver.Quiver n m)
instance (Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Entity.Definition.Entity (OAlg.Entity.Diagram.Quiver.Quiver n m)


-- | definition of <a>Diagram</a>s on <a>Oriented</a> structures.
module OAlg.Entity.Diagram.Definition

-- | diagram for a <a>Oriented</a> structure <b><tt>a</tt></b> of type
--   <b><tt>t</tt></b> having <b><tt>n</tt></b> points and
--   <b><tt>m</tt></b> arrows.
--   
--   <b>Properties</b> Let <tt>d</tt> be in <tt><a>Diagram</a> <b>t</b>
--   <b>n</b> <b>m</b> <b>a</b></tt> for a <a>Oriented</a> structure
--   <b><tt>a</tt></b>, then holds:
--   
--   <ol>
--   <li>If <tt>d</tt> matches <tt><a>DiagramChainTo</a> e as</tt> then
--   holds: <tt>e <a>==</a> <a>end</a> a0</tt> and <tt><a>start</a> ai
--   <a>==</a> <a>end</a> ai+1</tt> for all <tt>i = 0..m-2</tt> where
--   <tt>a0<a>:|</a>..<a>:|</a>ai<a>:|</a>..<a>:|</a>am-1<a>:|</a><a>Nil</a>
--   = as</tt>.</li>
--   <li>If <tt>d</tt> matches <tt><a>DiagramChainFrom</a> s as</tt> then
--   holds: <tt>s <a>==</a> <a>start</a> a0</tt> and <tt><a>end</a> ai
--   <a>==</a> <a>start</a> ai+1</tt> for all <tt>i = 0..m-2</tt> where
--   <tt>a0<a>:|</a>..<a>:|</a>ai<a>:|</a>..<a>:|</a>am-1<a>:|</a><a>Nil</a>
--   = as</tt>.</li>
--   <li>If <tt>d</tt> matches <tt><a>DiagramParallelLR</a> l r as</tt>
--   then holds: <tt><a>orientation</a> a <a>==</a> l<a>:&gt;</a>r</tt> for
--   all <tt>a</tt> in <tt>as</tt>.</li>
--   <li>If <tt>d</tt> matches <tt><a>DiagramParallelRL</a> l r as</tt>
--   then holds: <tt><a>orientation</a> a <a>==</a> r<a>:&gt;</a>l</tt> for
--   all <tt>a</tt> in <tt>as</tt>.</li>
--   <li>If <tt>d</tt> matches <tt><a>DiagramSink</a> e as</tt> then holds:
--   <tt>e <a>==</a> <a>end</a> a</tt> for all <tt>a</tt> in
--   <tt>as</tt>.</li>
--   <li>If <tt>d</tt> matches <tt><a>DiagramSource</a> s as</tt> then
--   holds: <tt>s <a>==</a> <a>start</a> a</tt> for all <tt>a</tt> in
--   <tt>as</tt>.</li>
--   <li>If <tt>d</tt> matches <tt><a>DiagramGeneral</a> ps aijs</tt> then
--   holds<tt> </tt>pi <a>==</a> <a>start</a> aij<tt> and </tt>pj <a>==</a>
--   <a>end</a> aij<tt> for all </tt>aij<tt> in </tt>aijs<tt> and </tt>ps =
--   p0..pn-1@.</li>
--   </ol>
data Diagram t n m a
[DiagramEmpty] :: Diagram 'Empty N0 N0 a
[DiagramDiscrete] :: FinList n (Point a) -> Diagram Discrete n N0 a
[DiagramChainTo] :: Point a -> FinList m a -> Diagram (Chain To) (m + 1) m a
[DiagramChainFrom] :: Point a -> FinList m a -> Diagram (Chain From) (m + 1) m a
[DiagramParallelLR] :: Point a -> Point a -> FinList m a -> Diagram (Parallel LeftToRight) N2 m a
[DiagramParallelRL] :: Point a -> Point a -> FinList m a -> Diagram (Parallel RightToLeft) N2 m a
[DiagramSink] :: Point a -> FinList m a -> Diagram (Star To) (m + 1) m a
[DiagramSource] :: Point a -> FinList m a -> Diagram (Star From) (m + 1) m a
[DiagramGeneral] :: FinList n (Point a) -> FinList m (a, Orientation N) -> Diagram General n m a

-- | the types of a <a>Diagram</a>.
data DiagramType
Empty :: DiagramType
Discrete :: DiagramType
Chain :: Site -> DiagramType
Parallel :: Direction -> DiagramType
Star :: Site -> DiagramType
General :: DiagramType

-- | <a>Dual</a> is well defined on diagram types.
rt' :: forall (t :: DiagramType). (Dual (Dual t) :~: t) -> Dual (Dual (Dual t)) :~: Dual t

-- | the type of a diagram.
dgType :: Diagram t n m a -> DiagramType

-- | reflexivity of the underlying diagram type.
dgTypeRefl :: Diagram t n m a -> Dual (Dual t) :~: t

-- | the points of a diagram.
dgPoints :: Oriented a => Diagram t n m a -> FinList n (Point a)

-- | the center point of a <a>Star</a>-diagram.
dgCenter :: Diagram (Star t) n m c -> Point c

-- | the arrows of a diagram.
dgArrows :: Diagram t n m a -> FinList m a

-- | mapping of a diagram via a homomorphism on <a>Oriented</a> structures.
dgMap :: Hom Ort h => h a b -> Diagram t n m a -> Diagram t n m b

-- | the underlying quiver of a diagram.
dgQuiver :: Diagram t n m a -> Quiver n m

-- | the last point of the chain.
chnToStart :: Oriented a => Diagram (Chain To) n m a -> Point a

-- | the first point of the chain.
chnFromStart :: Diagram (Chain From) n m a -> Point a

-- | adjoins a <a>zero</a> arrow as the first parallel arrow.
dgPrlAdjZero :: Distributive a => Diagram (Parallel LeftToRight) n m a -> Diagram (Parallel LeftToRight) n (m + 1) a

-- | the _<i>tail</i>__ of a parallel diagram.
dgPrlTail :: Diagram (Parallel d) n (m + 1) a -> Diagram (Parallel d) n m a

-- | subtracts to every arrow of the parallel diagram the first arrow.
dgPrlDiffHead :: Abelian a => Diagram (Parallel d) n (m + 1) a -> Diagram (Parallel d) n (m + 1) a

-- | subtracts the first arrow to all the others an drops it.
dgPrlDiffTail :: Abelian a => Diagram (Parallel d) n (m + 1) a -> Diagram (Parallel d) n m a

-- | to <tt><b>g</b> (<a>Op</a> <b>a</b>)</tt>.
dgToOp :: DiagramDuality f g a -> f a -> g (Op a)

-- | from <tt><b>g</b> (<a>Op</a> <b>a</b>)</tt>.
dgFromOp :: DiagramDuality f g a -> g (Op a) -> f a

-- | <a>Op</a>-duality between diagrams.
data DiagramDuality f g a
[DiagramDuality] :: Oriented a => (f a :~: Diagram t n m a) -> (g (Op a) :~: Dual (Diagram t n m a)) -> (Dual (Dual t) :~: t) -> DiagramDuality f g a

-- | the co diagram with its inverse <a>coDiagramInv</a>.
--   
--   <b>Property</b> Let <tt>d</tt> be in <tt><a>Diagram</a> <b>t</b>
--   <b>n</b> <b>m</b> <b>a</b></tt> for a <a>Oriented</a> structure
--   <b><tt>a</tt></b> then holds: <tt><a>dgPoints</a> (<a>coDiagram</a> d)
--   <a>==</a> <a>dgPoints</a> d</tt>.
coDiagram :: Diagram t n m a -> Dual (Diagram t n m a)

-- | from the dual diagram, with inverse of <a>coDiagram</a>.
coDiagramInv :: Oriented a => (Dual (Dual t) :~: t) -> Dual (Diagram t n m a) -> Diagram t n m a

-- | from <tt><a>Op</a> <a>.</a> <a>Op</a></tt>.
dgFromOpOp :: Oriented a => Diagram t n m (Op (Op a)) -> Diagram t n m a

-- | some diagram.
data SomeDiagram a
[SomeDiagram] :: Diagram t n m a -> SomeDiagram a

-- | mapping of some diagram via a homomorphism on <a>Oriented</a>
--   structures.
sdgMap :: Hom Ort h => h a b -> SomeDiagram a -> SomeDiagram b

-- | from <tt><a>Op</a> <a>.</a> <a>Op</a></tt>.
sdgFromOpOp :: Oriented a => SomeDiagram (Op (Op a)) -> SomeDiagram a

-- | the dual of some diagram, with inverse <a>coSomeDiagramInv</a>.
coSomeDiagram :: SomeDiagram a -> Dual (SomeDiagram a)

-- | from the dual of some diagram, with inverse <a>coSomeDiagram</a>.
coSomeDiagramInv :: Oriented a => Dual (SomeDiagram a) -> SomeDiagram a

-- | generator for random variables of diagrams.
data XDiagram t n m a
[XDiagramEmpty] :: XDiagram 'Empty N0 N0 a
[XDiagramDiscrete] :: Any n -> X (Point a) -> XDiagram Discrete n N0 a
[XDiagramChainTo] :: Any m -> XOrtSite To a -> XDiagram (Chain To) (m + 1) m a
[XDiagramChainFrom] :: Any m -> XOrtSite From a -> XDiagram (Chain From) (m + 1) m a
[XDiagramParallelLR] :: Any m -> XOrtOrientation a -> XDiagram (Parallel LeftToRight) N2 m a
[XDiagramParallelRL] :: Any m -> XOrtOrientation a -> XDiagram (Parallel RightToLeft) N2 m a
[XDiagramSink] :: Any m -> XOrtSite To a -> XDiagram (Star To) (m + 1) m a
[XDiagramSource] :: Any m -> XOrtSite From a -> XDiagram (Star From) (m + 1) m a

-- | the induced random variables of diagrams.
xDiagram :: Oriented a => (Dual (Dual t) :~: t) -> XDiagram t n m a -> X (Diagram t n m a)

-- | the induced random variable of some diagrams.
xSomeDiagram :: Oriented a => X SomeNatural -> XOrtSite To a -> XOrtSite From a -> XOrtOrientation a -> X (SomeDiagram a)

-- | distribution of a random variable of some diagrams.
dstSomeDiagram :: Oriented a => Int -> X (SomeDiagram a) -> IO ()

-- | random variable of some diagram of <tt><a>Orientation</a>
--   <b>p</b></tt>.
xSomeDiagramOrnt :: Entity p => X SomeNatural -> X p -> X (SomeDiagram (Orientation p))
instance GHC.Classes.Ord OAlg.Entity.Diagram.Definition.DiagramType
instance GHC.Classes.Eq OAlg.Entity.Diagram.Definition.DiagramType
instance GHC.Show.Show OAlg.Entity.Diagram.Definition.DiagramType
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Show.Show (OAlg.Entity.Diagram.Definition.Diagram t n m a)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Classes.Eq (OAlg.Entity.Diagram.Definition.Diagram t n m a)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Show.Show (OAlg.Entity.Diagram.Definition.SomeDiagram a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Data.Validable.Validable (OAlg.Entity.Diagram.Definition.SomeDiagram a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, n GHC.Types.~ OAlg.Entity.Natural.N0, m GHC.Types.~ OAlg.Entity.Natural.N0) => OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram 'OAlg.Entity.Diagram.Definition.Empty n m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, m GHC.Types.~ OAlg.Entity.Natural.N0, OAlg.Structure.Oriented.Definition.XStandardPoint a, OAlg.Entity.Natural.Attestable n) => OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram 'OAlg.Entity.Diagram.Definition.Discrete n m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To a, OAlg.Entity.Natural.Attestable m) => OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram ('OAlg.Entity.Diagram.Definition.Chain 'OAlg.Data.Dualisable.To) ('OAlg.Entity.Natural.S m) m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From a, OAlg.Entity.Natural.Attestable m) => OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram ('OAlg.Entity.Diagram.Definition.Chain 'OAlg.Data.Dualisable.From) ('OAlg.Entity.Natural.S m) m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, n GHC.Types.~ OAlg.Entity.Natural.N2, OAlg.Structure.Oriented.Definition.XStandardOrtOrientation a, OAlg.Entity.Natural.Attestable m) => OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram ('OAlg.Entity.Diagram.Definition.Parallel 'OAlg.Data.Dualisable.LeftToRight) n m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, n GHC.Types.~ OAlg.Entity.Natural.N2, OAlg.Structure.Oriented.Definition.XStandardOrtOrientation a, OAlg.Entity.Natural.Attestable m) => OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram ('OAlg.Entity.Diagram.Definition.Parallel 'OAlg.Data.Dualisable.RightToLeft) n m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To a, OAlg.Entity.Natural.Attestable m) => OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram ('OAlg.Entity.Diagram.Definition.Star 'OAlg.Data.Dualisable.To) ('OAlg.Entity.Natural.S m) m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From a, OAlg.Entity.Natural.Attestable m) => OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram ('OAlg.Entity.Diagram.Definition.Star 'OAlg.Data.Dualisable.From) ('OAlg.Entity.Natural.S m) m a)
instance OAlg.Hom.Oriented.Definition.HomOriented h => OAlg.Category.Applicative.Applicative1 h (OAlg.Entity.Diagram.Definition.Diagram t n m)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Data.Validable.Validable (OAlg.Entity.Diagram.Definition.Diagram t n m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Entity.Definition.Entity (OAlg.Entity.Diagram.Definition.Diagram t n m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, Data.Typeable.Internal.Typeable d, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Diagram.Definition.Diagram ('OAlg.Entity.Diagram.Definition.Parallel d) n m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Diagram.Definition.Diagram ('OAlg.Entity.Diagram.Definition.Chain t) n m a)


-- | propositions on diagrams on <a>Oriented</a> structures.
module OAlg.Entity.Diagram.Proposition

-- | validity of diagrams on <a>Symbol</a>s.
prpDiagramOrntSymbol :: Statement

-- | the point list is stable under <a>coDiagram</a>.
prpCoDiagram :: Oriented a => Diagram t n m a -> Statement


-- | propositions on basic algebraic structures.
module OAlg.Structure.Proposition

-- | validity of the algebraic structure of <a>N</a>.
prpStructureN :: Statement

-- | validity of the algebraic structure of <a>Z</a>.
prpStructureZ :: Statement

-- | validity of the algebraic structure of <a>Q</a>.
prpStructureQ :: Statement

-- | validity of the algebraic structure of <a>OS</a>.
prpStructureOS :: Statement


-- | definition of <a>Ring</a>s.
module OAlg.Structure.Ring.Definition

-- | distributive structure where <a>*</a> and <tt><a>+</a></tt> are total.
--   
--   <b>Note</b> If <tt><b>r</b></tt> is <a>Total</a> and
--   <a>Distributive</a> then <tt><a>Root</a> <b>r</b></tt> is
--   <a>Singleton</a>.
type Semiring r = (Distributive r, Total r)

-- | the neutral element according to <a>*</a>, i.e. <tt>rOne == <a>one</a>
--   <a>unit</a></tt>.
rOne :: Semiring r => r

-- | the neutral element according to <a>+</a>, i.e. <tt>rZero ==
--   <a>zero</a> <a>unit</a></tt>.
rZero :: Semiring r => r

-- | check being the additive inverse of <a>rOne</a>.
isMinusOne :: Semiring r => r -> Bool

-- | abelian semi rings.
type Ring r = (Semiring r, Abelian r)

-- | <b>Note</b> Not every element not equal to <a>zero</a> has to be
--   invertible. As such <a>Z</a> is <a>Galoisian</a>.
type Galoisian r = (Ring r, Commutative r, Invertible r)

-- | not degenerated commutative rings where every element not equal to
--   zero has a multiplicative inverse.
--   
--   <b>Properties</b>
--   
--   <ol>
--   <li><tt><a>rZero</a> /= <a>rOne</a></tt>.</li>
--   <li>For all <tt>x</tt> and <tt>y</tt> in <tt><b>r</b></tt>
--   holds:<ol><li>If <tt>y /= <a>rZero</a></tt> then <tt>x <a>/</a> y</tt>
--   is <a>valid</a></li><li>If <tt>y <a>==</a> <a>rZero</a></tt> then
--   <tt>x <a>/</a> y</tt> is not <a>valid</a> and its evaluation will end
--   up in a <a>NotInvertible</a>-exception.</li></ol></li>
--   <li>For all <tt>x</tt> and <tt>y</tt> in <tt><b>r</b></tt> with <tt>y
--   /= <a>rZero</a></tt> holds: <tt>y <a>*</a> (x <a>/</a> y) <a>==</a>
--   x</tt>.</li>
--   </ol>
class Galoisian r => Field r

-- | division.
(/) :: Field r => r -> r -> r
infixl 7 /
instance OAlg.Structure.Ring.Definition.Field OAlg.Data.Number.Q


-- | <a>Ring</a>s.
module OAlg.Structure.Ring


-- | definition of numbers as ordered <a>Semiring</a> with infinitely many
--   elements.
module OAlg.Structure.Number.Definition

-- | ordered commutative semi ring where <a>+</a> and <a>*</a> respect the
--   given ordering.
--   
--   <b>Definitions</b>
--   
--   <ol>
--   <li>A number <tt>x</tt> is called <b><i>positive</i></b> if <tt>0 &lt;
--   x</tt> and <b><i>negative</i></b> if <tt>x &lt; 0</tt>.</li>
--   <li>A number structure is called <b><i>positive</i></b> if it contains
--   no negative elements.</li>
--   </ol>
--   
--   <b>Properties</b>
--   
--   <ol>
--   <li><tt>1</tt> is positive.</li>
--   <li>For all <tt>x &lt; y</tt> and <tt>z</tt> holds: <tt>x <a>+</a> z
--   &lt; y <a>+</a> z</tt></li>
--   <li>For all <tt>0 &lt; x</tt>, <tt>0 &lt; y</tt> holds: <tt>0 &lt; x
--   <a>*</a> y</tt>.</li>
--   <li>For all <tt>x</tt> holds: <tt>x == <a>signum</a> x <a>*</a>
--   <a>abs</a> x</tt>.</li>
--   <li>For all <tt>x</tt> holds: <tt><a>floor</a> x <a>+</a>
--   <a>fraction</a> x == x</tt>.</li>
--   </ol>
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>A not positive structure of numbers contain always also the
--   additive inverse of <tt>1</tt> which is negative.</li>
--   <li>Structures of numbers have infinitely many values, because from
--   the properties above follows that <tt>0 &lt; 1 &lt; 2 &lt; .. &lt;
--   <a>ntimes</a> n 1 &lt; <a>ntimes</a> (n <a>+</a> 1) 1 &lt; .. </tt>
--   for all <tt>0 &lt;= n</tt>.</li>
--   </ol>
class (Semiring r, Commutative r, Ord r) => Number r

-- | the additive inverse of <tt>1</tt> - if it exists - and will be
--   denoted by <tt>-1</tt> (see the note above).
minusOne :: Number r => Maybe r

-- | sign of a number.
--   
--   <b>Property</b> For all <tt>x</tt> holds: if <tt>0 &lt; x</tt> then
--   <tt>signum x == 1</tt> and if <tt>x == 0</tt> then <tt>signum x ==
--   0</tt> and if <tt>x &lt; 0</tt> then <tt>signum x == -1</tt> (for
--   <tt>-1</tt> see <tt><a>minusOne</a></tt>).
--   
--   <b>Note</b> The default implementation is:
--   
--   <pre>
--   signum x = case rZero <a>compare</a> x of
--                GT -&gt; rOne
--                EQ -&gt; rZero
--                LT -&gt; e where Just e = minusOne
--   </pre>
signum :: Number r => r -> r

-- | absolute value of a number.
--   
--   <b>Definition</b> The <b><i>absolute value</i></b> of a <tt>x</tt> is
--   defined by <tt>abs x = <a>signum</a> x <a>*</a> x</tt> (which serves
--   as the default implementation).
--   
--   <b>Properties</b> For all <tt>x</tt> holds:
--   
--   <ol>
--   <li><tt>0 &lt;= abs x</tt>.</li>
--   <li>if <tt>0 &lt;= x</tt> then <tt>abs x == x</tt>.</li>
--   </ol>
abs :: Number r => r -> r

-- | floor of a value of a number.
--   
--   <b>Properties</b>
--   
--   <ol>
--   <li><tt>floor 0 == 0</tt>.</li>
--   <li>For all <tt>x</tt> holds: <tt>floor (x <a>+</a> 1) = floor x
--   <a>+</a> 1</tt>.</li>
--   </ol>
floor :: Number r => r -> r

-- | fractional part of a number.
--   
--   <b>Property</b> For all <tt>x</tt> holds: 0 &lt;= fraction x &lt; 1.
fraction :: Number r => r -> r

-- | simultaneous evaluation of <tt><a>floor</a></tt> - represented as an
--   integer - and its <tt><a>fraction</a></tt>.
--   
--   <b>Properties</b> For all <tt>x</tt> holds:
--   
--   <ol>
--   <li><tt><a>floor</a> x == <a>ntimes</a> (<a>prj</a> <a>$</a> fst
--   <a>$</a> <a>zFloorFraction</a> <a>$</a> x) (<a>signum</a>
--   x)</tt>.</li>
--   <li><tt><a>fraction</a> x == <a>snd</a> <a>.</a>
--   <a>zFloorFraction</a></tt>.</li>
--   </ol>
--   
--   <b>Note</b> This properties are used for the default implementation of
--   <tt><a>floor</a></tt> and <tt><a>fraction</a></tt>.
zFloorFraction :: Number r => r -> (Z, r)

-- | floor to <a>Z</a>.
zFloor :: Number r => r -> Z

-- | the digital representation of <tt>x</tt> in the base <tt>b</tt>.
--   
--   Let <tt><a>Digits</a> s xs ys = <a>toDigits</a> r</tt> then
--   
--   <ul>
--   <li><tt>s</tt> is the <tt><a>signum</a> x</tt>.</li>
--   <li><tt>xs</tt> is the digital representation of <tt><a>abs</a>
--   (<a>floor</a> x)</tt> .</li>
--   <li><tt>ys</tt> is the - possibly infinite - digital representation of
--   <tt><a>abs</a> (<a>fraction</a> x)</tt> in the base <tt>b</tt>.</li>
--   </ul>
--   
--   <b>Examples</b>
--   
--   <pre>
--   &gt;&gt;&gt; toDigits (1/3) :: Digits 10 Q
--   Digits 1 [] [3,3,3..]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toDigits (-4/3) :: Digits 3 Q
--   Digits (-1) [1] [1]
--   </pre>
--   
--   <b>Note</b> To get the first <tt>n</tt> digits of the fractional part
--   <tt>ys</tt> for the digital representation of <tt>x</tt> use
--   <tt><a>toDigitsFinite</a> n x</tt>.
toDigits :: (Number r, KnownNat b, 2 <= b) => r -> Digits b r

-- | digital representation of numbers for the given base <tt>b</tt>.
--   
--   <b>Note</b>
--   
--   <ol>
--   <li><a>dgsFlr</a> is a finite list</li>
--   <li><a>dgsFrc</a> maybe a infinite list and as such <a>valid</a> could
--   end up in an infinite proposition!</li>
--   </ol>
data Digits (b :: Nat) r
[Digits] :: 2 <= b => r -> [N] -> [N] -> Digits b r

-- | <tt>toDigitsFinite n</tt> is like <a>toDigits</a> but the fractional
--   part is limited to the length of <tt>n</tt> and is given by
--   <tt><a>dgsFrcTake</a> n <a>.</a> <a>toDigits</a></tt>.
toDigitsFinite :: (Number r, KnownNat b, 2 <= b) => N -> r -> Digits b r

-- | <tt>fromDigits n dgs@(<a>Digits</a> s xs ys)</tt> is given by <tt>s
--   <a>*</a> (xm <a>*</a> b<a>^</a>m <a>+</a> .. <a>+</a> xi <a>*</a>
--   b<a>^</a>i <a>+</a> .. <a>+</a> x0 <a>*</a> b<a>^</a>0 <a>+</a> y1
--   <a>*</a> r<a>^</a>1 <a>+</a> .. <a>+</a> yj <a>*</a> r<a>^</a>j
--   <a>+</a> .. <a>+</a> yn <a>*</a> r<a>^</a>n</tt> where <tt>b =
--   <a>dgsBase</a> dgs</tt>, <tt>xs = [xm..xi..x0]</tt>, <tt>ys =
--   [y1,y2..yj..yn..]</tt> and <tt>r = <a>invert</a> b</tt>.
--   
--   <b>Property</b> Let <tt>1 <a>&lt;</a> b</tt> and <tt>dgs =
--   <a>Digits</a> s xs ys</tt> where <tt>s</tt> is either 1 or -1 and
--   <tt>0 <a>&lt;=</a> xi <a>&lt;</a> b</tt> for all <tt>i</tt> and <tt>0
--   <a>&lt;=</a> yj <a>&lt;</a> b</tt> for all <tt>j</tt> then for all
--   <tt>n</tt> holds: <tt><a>toDigits</a> b n (<a>fromDigits</a> b n dgs)
--   <a>==</a> dgs</tt>.
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>All the elements of the above formula are lifted to the type
--   <tt>r</tt> via <tt>\x -&gt; <a>ntimes</a> x <a>rOne</a></tt>.</li>
--   <li>Because the type <tt>r</tt> is acyclic, the expression
--   <tt><a>invert</a> b</tt> - which is actually <tt><a>invert</a>
--   (<a>ntimes</a> b <a>rOne</a>)</tt> - is regular.</li>
--   <li>If <tt>b</tt> is not bigger then 1 then an exception
--   <a>Undefined</a> will be thrown.</li>
--   </ol>
fromDigits :: (Number r, Acyclic r, KnownNat b) => N -> Digits b r -> r

-- | the base of a digit, i.e. the corresponding natural number of the type
--   literal <tt>b</tt>.
dgsBase :: KnownNat b => Digits b r -> N

-- | the proxy with the same type <tt>b</tt>.
dgsProxy :: Digits b r -> Proxy b

-- | limits the fractional part <a>dgsFrc</a> to the length of <tt>n</tt>.
dgsFrcTake :: N -> Digits b r -> Digits b r

-- | discrete numbers.
--   
--   <b>Property</b> For all <tt>x</tt> holds: <tt><a>fraction</a> x
--   <a>==</a> 0</tt>.
class Number a => Integral a
divMod :: Integral a => a -> a -> (a, a)
div :: Integral a => a -> a -> a
mod :: Integral a => a -> a -> a

-- | the list of prime numbers.
primes :: [N]

-- | distributive structure with entities scaleable by <a>Q</a>.
--   
--   <b>Property</b> For every <tt>0 <a>&lt;</a> n</tt> and point
--   <tt>p</tt> holds: <tt><a>ntimes</a> n (<a>one</a> p)</tt> is
--   invertible.
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>The cyclic rings <tt><a>Mod</a> n</tt> for <tt>2 &lt;= n</tt> are
--   not scaleable by <tt><a>Q</a></tt>, because <tt>1 <a>/=</a> 0</tt> and
--   <tt><a>ntimes</a> n 1 <a>==</a> 0</tt>!</li>
--   <li>If for every point <tt>p</tt> holds that <tt><a>zero</a>
--   (p<a>:&gt;</a>p) <a>==</a> <a>one</a> p</tt> then the structure is
--   scaleable by <a>Q</a> (e.g. <tt><a>Orientation</a> p</tt>).</li>
--   </ol>
class (Distributive a, Abelian a, Invertible a) => Acyclic a

-- | <tt><a>qtimes</a> q a <a>==</a> <a>ztimes</a> z a <a>*</a>
--   <a>invert</a> (<a>ntimes</a> n (<a>one</a> (<a>start</a> a)))</tt>.
--   where <tt>z = <a>numerator</a> q</tt> and <tt>n = <a>denominator</a>
--   q</tt>.
qtimes :: Acyclic a => Q -> a -> a

-- | continuous numbers, i.e acyclic and negateable numbers. They induce a
--   sub <tt><a>Q</a></tt>-vectorial structures of the real numbers.
--   
--   <b>Note</b> We will distinguish here instances of
--   <tt><a>Fractional</a></tt> and the mathematical entities of real
--   numbers!
type Fractional r = (Number r, Abelian r, Acyclic r)

-- | measurable entities.
class (Entity a, Number r) => Measurable a r

-- | distance of two points.
--   
--   <b>Properties</b> Let <tt><b>a</b></tt> <tt><b>r</b></tt> be
--   <a>Measurable</a>, then holds:
--   
--   <ol>
--   <li>For all <tt>x</tt> and <tt>y</tt> in <tt><b>a</b></tt> holds:
--   <tt>0 &lt;= dist x y</tt></li>
--   <li>For all <tt>x</tt> and <tt>y</tt> in <tt><b>a</b></tt> holds:
--   <tt>dist x y == 0</tt> if and only if <tt>x == y</tt>.</li>
--   <li>For all <tt>x</tt> and <tt>y</tt> in <tt><b>a</b></tt> holds:
--   <tt>dist x y == dist y x</tt>.</li>
--   <li>For all <tt>x</tt>, <tt>y</tt> and <tt>z</tt> in <tt><b>a</b></tt>
--   holds: <tt>dist x z</tt> &lt;= <tt>dist x y</tt> <a>+</a> <tt>dist y
--   z</tt></li>
--   </ol>
dist :: Measurable a r => a -> a -> r
instance GHC.Show.Show r => GHC.Show.Show (OAlg.Structure.Number.Definition.Digits b r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (OAlg.Structure.Number.Definition.Digits b r)
instance GHC.Classes.Ord r => GHC.Classes.Ord (OAlg.Structure.Number.Definition.Digits b r)
instance OAlg.Data.Validable.Validable r => OAlg.Data.Validable.Validable (OAlg.Structure.Number.Definition.Digits b r)
instance (GHC.TypeNats.KnownNat b, OAlg.Entity.Definition.Entity r) => OAlg.Entity.Definition.Entity (OAlg.Structure.Number.Definition.Digits b r)
instance (OAlg.Structure.Number.Definition.Number r, OAlg.Structure.Additive.Definition.Abelian r) => OAlg.Structure.Number.Definition.Measurable r r
instance OAlg.Structure.Number.Definition.Measurable OAlg.Data.Number.N OAlg.Data.Number.Z
instance OAlg.Structure.Number.Definition.Acyclic ()
instance OAlg.Structure.Number.Definition.Acyclic OAlg.Data.Number.Q
instance OAlg.Structure.Number.Definition.Integral OAlg.Data.Number.N
instance OAlg.Structure.Number.Definition.Integral OAlg.Data.Number.Z
instance OAlg.Structure.Number.Definition.Number OAlg.Data.Number.N
instance OAlg.Structure.Number.Definition.Number GHC.Num.Integer.Integer
instance OAlg.Structure.Number.Definition.Number OAlg.Data.Number.Z
instance OAlg.Structure.Number.Definition.Number OAlg.Data.Number.Q


-- | numbers as ordered <a>Semiring</a> with infinitely many elements.
module OAlg.Structure.Number


-- | sets of ordered entities.
module OAlg.Entity.Sequence.Set

-- | set of ordered entities in <tt><b>x</b></tt>.
--   
--   <b>Property</b> Let <tt>s = <a>Set</a> xs</tt> be in <tt><a>Set</a>
--   <b>x</b></tt> for a ordered <a>Entity</a> type <tt><b>x</b></tt>, then
--   holds:
--   
--   <ol>
--   <li>For all <tt>..x<tt>:</tt>y..</tt> in <tt>xs</tt> holds: <tt>x
--   <a>&lt;</a> y</tt>.</li>
--   <li><tt><a>lengthN</a> s <a>==</a> <a>lengthN</a> xs</tt>.</li>
--   </ol>
newtype Set x
Set :: [x] -> Set x

-- | makes a set from the given list.
set :: Ord x => [x] -> Set x

-- | the span of a set.
setSpan :: Set x -> Span x

-- | the elements of a set.
setxs :: Set x -> [x]

-- | mapping a set.
setSqc :: Ord x => (i -> Maybe x) -> Set i -> Set x

-- | mapping of sets.
--   
--   <b>Note</b> This works only for finite sets!
setMap :: Ord y => (x -> y) -> Set x -> Set y

-- | checks for being a sub set.
isSubSet :: Ord x => Set x -> Set x -> Bool

-- | the empty set.
setEmpty :: Set x

-- | the union of two sets.
setUnion :: Ord x => Set x -> Set x -> Set x

-- | the index of an element, where the elements of the given set are
--   indexed from <tt>0</tt>.
--   
--   <b>Examples</b>
--   
--   <pre>
--   &gt;&gt;&gt; setIndex (Set ['a'..'x']) 'c'
--   Just 2
--   </pre>
setIndex :: Ord x => Set x -> x -> Maybe N

-- | random variable of sets with maximal the given length.
xSet :: Ord x => N -> X x -> X (Set x)

-- | validity for the union operator of sets.
prpSetUnion :: (Ord x, Show x) => X (Set x) -> Statement
instance Data.Foldable.Foldable OAlg.Entity.Sequence.Set.Set
instance OAlg.Data.Number.LengthN (OAlg.Entity.Sequence.Set.Set x)
instance GHC.Classes.Eq x => GHC.Classes.Eq (OAlg.Entity.Sequence.Set.Set x)
instance GHC.Show.Show x => GHC.Show.Show (OAlg.Entity.Sequence.Set.Set x)
instance (OAlg.Data.Validable.Validable x, GHC.Classes.Ord x, GHC.Show.Show x) => OAlg.Data.Validable.Validable (OAlg.Entity.Sequence.Set.Set x)
instance (OAlg.Entity.Definition.Entity x, GHC.Classes.Ord x) => OAlg.Entity.Definition.Entity (OAlg.Entity.Sequence.Set.Set x)
instance GHC.Classes.Ord x => OAlg.Data.Ord.POrd (OAlg.Entity.Sequence.Set.Set x)


-- | graphs of entities in <tt><b>x</b></tt>.
module OAlg.Entity.Sequence.Graph

-- | mapping from an ordered <i>index</i> type <tt><b>i</b></tt> to a
--   <a>Entity</a> type <tt><b>x</b></tt>.
--   
--   <b>Property</b> Let <tt>g = <a>Graph</a> ixs</tt> be in
--   <tt><a>Graph</a> <b>i</b> <b>x</b></tt> for a ordered <a>Entity</a>
--   type <tt><b>i</b></tt> and <a>Entity</a> type <tt><b>x</b></tt>, then
--   holds:
--   
--   <ol>
--   <li>For all <tt>..(i,_)<tt>:</tt>(j,_)..</tt> in <tt>ixs</tt> holds:
--   <tt>i <a>&lt;</a> j</tt>.</li>
--   <li><tt><a>lengthN</a> g <a>==</a> <a>lengthN</a> ixs</tt>.</li>
--   </ol>
newtype Graph i x
Graph :: [(i, x)] -> Graph i x

-- | the length of a graph.
gphLength :: Graph i x -> N

-- | the underlying associations.
gphxs :: Graph i x -> [(i, x)]

-- | the induced graph given by a set of indices and a mapping.
gphSqc :: (i -> Maybe x) -> Set i -> Graph i x

-- | looks up the mapping of an index.
gphLookup :: Ord i => Graph i x -> i -> Maybe x
instance OAlg.Data.Number.LengthN (OAlg.Entity.Sequence.Graph.Graph i x)
instance (GHC.Classes.Eq i, GHC.Classes.Eq x) => GHC.Classes.Eq (OAlg.Entity.Sequence.Graph.Graph i x)
instance (GHC.Show.Show i, GHC.Show.Show x) => GHC.Show.Show (OAlg.Entity.Sequence.Graph.Graph i x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Data.Validable.Validable (OAlg.Entity.Sequence.Graph.Graph i x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Definition.Entity (OAlg.Entity.Sequence.Graph.Graph i x)
instance GHC.Base.Functor (OAlg.Entity.Sequence.Graph.Graph i)


-- | basic definitions for sequences as mappings of an index to an entity.
module OAlg.Entity.Sequence.Definition

-- | sequences as mappings of an index.
--   
--   <b>Definition</b> Let <tt><b>s</b></tt>, <tt><b>i</b></tt>,
--   <tt><b>x</b></tt> be an instance of <a>Sequence</a> and <tt>xs</tt> be
--   in <tt><b>s</b> <b>x</b></tt>, then we call <tt>xs</tt>
--   <b><i>finite</i></b> if and only if the evaluation of
--   <tt><a>lengthN</a> xs</tt> terminates and will not end up in an
--   exception.
--   
--   <b>Property</b> Let <tt><b>s</b></tt>, <tt><b>i</b></tt>,
--   <tt><b>x</b></tt> be an instance of <a>Sequence</a>, then holds:
--   
--   <ol>
--   <li>For all <tt>xs</tt> in <tt><b>s</b> <b>x</b></tt>
--   holds:<ol><li><a>graph</a> is constant in its first
--   parameter.</li><li>If <tt>xs</tt> is finite, then <tt><a>lengthN</a>
--   xs <a>==</a> <a>lengthN</a> (<a>graph</a> p xs)</tt> for any
--   <tt>p</tt>.</li></ol></li>
--   <li>For all <tt>xs</tt> in <tt><b>s</b> <b>x</b></tt>
--   holds:<ol><li><a>list</a> is constant in its first
--   parameter.</li><li>For all <tt>..(x,i)<tt>:</tt>(x,j)..</tt> in
--   <tt>xs</tt> holds: <tt>i <a>&lt;</a> j</tt>.</li><li>If <tt>xs</tt> is
--   finite, then <tt><a>lengthN</a> xs <a>==</a> <a>lengthN</a>
--   (<a>list</a> p xs)</tt> for any <tt>p</tt>.</li></ol></li>
--   <li>Let <tt>xs</tt> be in <tt><b>s</b> <b>x</b></tt> and <tt>i</tt> in
--   <tt><b>i</b></tt>, then holds: there exists an <tt>x</tt> in
--   <tt><b>x</b></tt> with <tt>xs <a>?</a> i</tt> matches <tt><a>Just</a>
--   x</tt> if and only if there exists an <tt>(i',x)</tt> in
--   <tt><a>graph</a> (Just i) xs</tt> such that <tt>i <a>==</a>
--   i'</tt>.</li>
--   </ol>
--   
--   <b>Note</b> The first parameter of <a>graph</a> - respectively
--   <a>list</a> - serves only as a <i>proxy</i> and as such it is only
--   relevant on the type level.
class (LengthN (s x), Ord i) => Sequence s i x

-- | the associated graph of a sequence
graph :: Sequence s i x => p i -> s x -> Graph i x

-- | the associated list of its items together with there index.
list :: Sequence s i x => p i -> s x -> [(x, i)]

-- | the <tt>i</tt>-th item.
(??) :: Sequence s i x => s x -> i -> Maybe x

-- | the indexed list of the sequence.
listN :: Sequence s N x => s x -> [(x, N)]

-- | the <tt>i</tt>-th element of the sequence.
--   
--   <b>Property</b> Let <tt>xs</tt> be in <tt><b>s</b> <b>x</b></tt> and
--   <tt>i</tt> in <tt><b>i</b></tt> for a instance of <tt><a>Sequence</a>
--   <b>s</b> <b>i</b> <b>x</b></tt>, then holds: If <tt>i</tt> is in the
--   <a>support</a> of <tt>xs</tt> then <tt>xs <a>?</a> i</tt> is the
--   <tt>i</tt>-th item of <tt>xs</tt>, else its evaluation will end up by
--   throwing a <a>IndexOutOfSupport</a>-exception.
(?) :: Sequence s i x => s x -> i -> x

-- | checks for being empty.
isEmpty :: Sequence s i x => p i -> s x -> Bool

-- | the span of a sequence.
span :: Sequence s i x => p i -> s x -> Span i

-- | the support of a sequence, i.e. all the indices which are not mapped
--   to <a>Nothing</a>.
support :: Sequence s i x => p i -> s x -> Set i

-- | the image of a sequence, i.e. all the entities are hit by the mapping.
image :: (Sequence s i x, Ord x) => p i -> s x -> Set x

-- | constructable sequences.
class (Entity x, Entity i, Sequence s i x) => ConstructableSequence s i x

-- | constructs a sequence.
sequence :: ConstructableSequence s i x => (i -> Maybe x) -> Set i -> s x

-- | restricts a sequence.
(<&) :: ConstructableSequence s i x => s x -> Set i -> s x
infixl 7 <&

-- | mapping the indices according to the given set.
sqcIndexMap :: (ConstructableSequence s i x, Sequence s j x) => Set i -> (i -> j) -> s x -> s x

-- | sequence exceptions which are sub exceptions from
--   <a>SomeOAlgException</a>.
data SequenceException
IndexOutOfSupport :: SequenceException
instance GHC.Show.Show OAlg.Entity.Sequence.Definition.SequenceException
instance GHC.Classes.Eq OAlg.Entity.Sequence.Definition.SequenceException
instance (OAlg.Structure.Number.Definition.Integral r, GHC.Enum.Enum r, OAlg.Entity.Definition.Entity x) => OAlg.Entity.Sequence.Definition.ConstructableSequence [] r x
instance (OAlg.Structure.Number.Definition.Integral r, GHC.Enum.Enum r, OAlg.Entity.Definition.Entity x, GHC.Classes.Ord x) => OAlg.Entity.Sequence.Definition.ConstructableSequence OAlg.Entity.Sequence.Set.Set r x
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Sequence.Definition.ConstructableSequence (OAlg.Entity.Sequence.Graph.Graph i) i x
instance (OAlg.Structure.Number.Definition.Integral r, GHC.Enum.Enum r) => OAlg.Entity.Sequence.Definition.Sequence [] r x
instance (OAlg.Structure.Number.Definition.Integral r, GHC.Enum.Enum r) => OAlg.Entity.Sequence.Definition.Sequence OAlg.Entity.Sequence.Set.Set r x
instance GHC.Classes.Ord i => OAlg.Entity.Sequence.Definition.Sequence (OAlg.Entity.Sequence.Graph.Graph i) i x
instance GHC.Exception.Type.Exception OAlg.Entity.Sequence.Definition.SequenceException


-- | partially defined sequences of items in <tt><b>x</b></tt> with a
--   totally ordered index type <tt><b>i</b></tt>.
module OAlg.Entity.Sequence.PSequence

-- | partially defined sequences <tt>(x0,i0),(x1,i1)..</tt> of index items
--   in <tt><b>x</b></tt> with a totally ordered index type
--   <tt><b>i</b></tt>.
--   
--   <b>Property</b> Let <tt><a>PSequence</a> xis</tt> be in
--   <tt><a>PSequence</a> <b>i</b> <b>x</b></tt> then holds: <tt>i
--   <a>&lt;</a> j</tt> for all <tt>..(_,i)<tt>:</tt>(_,j)..</tt> in
--   <tt>xis</tt>.
--   
--   <b>Examples</b>
--   
--   <pre>
--   &gt;&gt;&gt; PSequence [('a',3),('b',7),('c',12)] :: PSequence N Char
--   PSequence [('a',3),('b',7),('c',12)]
--   </pre>
--   
--   and
--   
--   <pre>
--   &gt;&gt;&gt; validate (valid (PSequence [('a',3),('b',7),('c',12)] :: PSequence N Char))
--   Valid
--   </pre>
--   
--   but
--   
--   <pre>
--   &gt;&gt;&gt; validate (valid (PSequence [('a',3),('b',15),('c',12)] :: PSequence N Char))
--   Invalid
--   </pre>
--   
--   as <a>Char</a> is a totally ordered type it can serve as index type
--   
--   <pre>
--   &gt;&gt;&gt; validate (valid (PSequence [(12,'c'),(3,'e'),(8,'x')] :: PSequence Char Z))
--   Valid
--   </pre>
--   
--   and they admit a total right operation <a>&lt;*</a> of
--   <tt><a>Permutation</a> <b>i</b></tt>
--   
--   <pre>
--   &gt;&gt;&gt; (PSequence [(12,'c'),(3,'e'),(8,'x')] :: PSequence Char Z) &lt;* pmtSwap 'e' 'x'
--   PSequence [(12,'c'),(8,'e'),(3,'x')]
--   </pre>
--   
--   <b>Note</b> As we keep the constructor public, it is crucial for there
--   further use to ensure that they are <a>valid</a>!
newtype PSequence i x
PSequence :: [(x, i)] -> PSequence i x

-- | proxy of the second type valiable <tt><b>i</b></tt>.
iProxy :: s i x -> Proxy i

-- | the span.
psqSpan :: Ord i => PSequence i x -> Span i

-- | the empty partially defined sequence.
psqEmpty :: PSequence i x

-- | checks of being empty.
psqIsEmpty :: PSequence i x -> Bool

-- | the underlying list of indexed values.
psqxs :: PSequence i x -> [(x, i)]

-- | the partial sequenc given by a aggregation function an a list of value
--   index pairs, which will be sorted and accordingly aggregated by
--   thegiven aggregation function.
psequence :: Ord i => (x -> x -> x) -> [(x, i)] -> PSequence i x

-- | the head of a partial sequence.
psqHead :: PSequence i x -> (x, i)

-- | the tail.
psqTail :: PSequence i x -> PSequence i x

-- | maps the entries, where the indices are preserved.
psqMap :: (x -> y) -> PSequence i x -> PSequence i y

-- | maps and shifts a partial sequence.
psqMapShift :: Number i => i -> ((x, i) -> y) -> PSequence i x -> PSequence i y

-- | filters the partially defiend sequence accordingly the given
--   predicate.
psqFilter :: (x -> Bool) -> PSequence i x -> PSequence i x

-- | splits the sequence as long as the given predicate holds.
psqSplitWhile :: ((x, i) -> Bool) -> PSequence i x -> (PSequence i x, PSequence i x)

-- | interlaces the tow partially defined sequences according to the given
--   mappings.
psqInterlace :: Ord i => (x -> y -> z) -> (x -> z) -> (y -> z) -> PSequence i x -> PSequence i y -> PSequence i z

-- | composition of the two partially defined sequences.
--   
--   <b>Property</b> Let <tt>f</tt> be in <tt><a>PSequence</a> <b>i</b>
--   <b>x</b></tt> and <tt>g</tt> be in <tt><a>PSequence</a> <b>j</b>
--   <b>i</b></tt> then <tt>f <a>`psqCompose`</a> g</tt> is given by
--   <tt><a>join</a> <a>.</a> <a>fmap</a> ((<a>??</a>) f) <a>.</a>
--   (<a>??</a>) g</tt>.
psqCompose :: (Ord i, Ord j) => PSequence i x -> PSequence j i -> PSequence j x

-- | appends the second partially defined sequence to the first.
--   
--   <b>Property</b> Let <tt>zs = <a>psqAppend</a> xs ys</tt> where
--   <tt>..(x,l) = xs</tt> and <tt>(y,f).. = ys</tt> then holds:
--   
--   <ul>
--   <li><i>If</i> <tt>l <a>&lt;</a> f</tt></li>
--   <li><i>Then</i> <tt>zs</tt> is <a>valid</a>.</li>
--   </ul>
psqAppend :: PSequence i x -> PSequence i x -> PSequence i x

-- | shears the two entries at the given position and leafs the others
--   untouched.
--   
--   <b>Property</b> Let <tt>x' = psqShear (sk,k) (sl,l) x</tt>, then holds
--   
--   <ul>
--   <li><i>If</i> <tt>k <a>&lt;</a> l</tt></li>
--   <li><i>Then</i></li>
--   </ul>
--   
--   <ol>
--   <li><tt>x' k <a>==</a> sk (x k) (x l)</tt> and <tt>x' l <a>==</a> sl
--   (x k) (x l)</tt>.</li>
--   <li><tt>x' i <a>==</a> x i</tt> for all <tt>i <a>/=</a> k,
--   l</tt>.</li>
--   </ol>
psqShear :: Ord i => (Maybe a -> Maybe a -> Maybe a, i) -> (Maybe a -> Maybe a -> Maybe a, i) -> PSequence i a -> PSequence i a

-- | swaps the the <tt>k</tt>-th and the <tt>l</tt>-th entry.
--   
--   <b>Property</b> Let <tt>x' = psqSwap k l x</tt>, then holds:
--   
--   <ul>
--   <li><i>If</i> <tt>k &lt; l</tt></li>
--   <li><i>Then</i></li>
--   </ul>
--   
--   <ol>
--   <li><tt>x' k <a>==</a> x l</tt> and <tt>x' l <a>==</a> x k</tt>.</li>
--   <li><tt>x' i <a>==</a> x i</tt> for all <tt>i <a>/=</a> k,
--   l</tt>.</li>
--   </ol>
psqSwap :: Ord i => i -> i -> PSequence i a -> PSequence i a

-- | <tt><a>xPSequence</a> n m</tt> random variable of partially defined
--   sequences with maximal length <tt><a>min</a> n m</tt>.
xPSequence :: Ord i => N -> N -> X x -> X i -> X (PSequence i x)
instance Data.Foldable.Foldable (OAlg.Entity.Sequence.PSequence.PSequence i)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Sequence.PSequence.PSequence i x)
instance (GHC.Classes.Ord x, GHC.Classes.Ord i) => GHC.Classes.Ord (OAlg.Entity.Sequence.PSequence.PSequence i x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq i) => GHC.Classes.Eq (OAlg.Entity.Sequence.PSequence.PSequence i x)
instance (GHC.Show.Show x, GHC.Show.Show i) => GHC.Show.Show (OAlg.Entity.Sequence.PSequence.PSequence i x)
instance OAlg.Data.Canonical.Embeddable [x] (OAlg.Entity.Sequence.PSequence.PSequence OAlg.Data.Number.N x)
instance OAlg.Data.Canonical.Projectible [x] (OAlg.Entity.Sequence.PSequence.PSequence OAlg.Data.Number.N x)
instance GHC.Classes.Ord i => OAlg.Entity.Sequence.Definition.Sequence (OAlg.Entity.Sequence.PSequence.PSequence i) i x
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Sequence.Definition.ConstructableSequence (OAlg.Entity.Sequence.PSequence.PSequence i) i x
instance GHC.Base.Functor (OAlg.Entity.Sequence.PSequence.PSequence i)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Data.Validable.Validable (OAlg.Entity.Sequence.PSequence.PSequence i x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Definition.Entity (OAlg.Entity.Sequence.PSequence.PSequence i x)


-- | <a>Multiplicative</a> structures with a power function
--   <tt>(<a>^</a>)</tt>.
module OAlg.Structure.Exponential

-- | <a>Multiplicative</a> structures with a <b>partially</b> defined power
--   function with numbers as exponents.
--   
--   <b>Properties</b>
--   
--   <ol>
--   <li>For all <tt>f</tt> and <tt>a</tt> holds:<ol><li>If
--   <tt><a>start</a> f <a>==</a> <a>end</a> f</tt> or <tt>a</tt> is an
--   element of <tt>[-1,1]</tt> then <tt>f<a>^</a>a</tt> is
--   <a>valid</a>.</li><li>If <tt><a>start</a> f <a>/=</a> <a>end</a>
--   f</tt> and <tt>a</tt> is not an element of <tt>[-1,1]</tt> then
--   <tt>f<a>^</a>a</tt> is not <a>valid</a> and its evaluation will end up
--   in a <a>NotExponential</a>-exception.</li></ol></li>
--   <li>For all <tt>f</tt> holds: <tt>f<a>^</a>1 <a>==</a> f</tt>.</li>
--   <li>For all <tt>f</tt> holds: <tt>f<a>^</a>(-1) <a>==</a>
--   <a>invert</a> f</tt>.</li>
--   <li>For all <tt>f</tt> and <tt>a</tt> with <tt><a>start</a> f
--   <a>==</a> <a>end</a> f</tt> and <tt>a</tt> not in <tt>[-1,1]</tt>
--   holds: <tt><a>start</a> (f<a>^</a>a) <a>==</a> <a>start</a> f</tt> and
--   <tt><a>end</a> (f<a>^</a>a) <a>==</a> <a>end</a> f</tt>.</li>
--   <li>For all <tt>f</tt>, <tt>a</tt> and <tt>b</tt> with
--   <tt><a>start</a> f <a>==</a> <a>end</a> f</tt> holds:
--   <tt>f<a>^</a>(a<a>*</a>b) <a>==</a> (f<a>^</a>a)<a>^</a> b</tt>.</li>
--   <li>For all <tt>f</tt> with <tt><a>start</a> f <a>==</a> <a>end</a>
--   f</tt> holds: <tt>f<a>^</a>0 == <a>one</a> (<a>end</a> f)</tt>.</li>
--   <li>For all <tt>f</tt>, <tt>a</tt> and <tt>b</tt> with
--   <tt><a>start</a> f <a>==</a> <a>end</a> f</tt> holds: <tt>f<a>^</a>(a
--   <a>+</a> b) <a>==</a> f<a>^</a>a <a>*</a> f<a>^</a>b</tt>.</li>
--   <li>For all <tt>a</tt> and <tt>p</tt> holds: <tt>(<a>one</a>
--   p)<a>^</a>a <a>==</a> <a>one</a> p</tt>.</li>
--   <li>For all <tt>f</tt>, <tt>g</tt> and <tt>a</tt> with
--   <tt><a>start</a> f <a>==</a> <a>end</a> f</tt>, <tt><a>start</a> g
--   <a>==</a> <a>end</a> g</tt> <tt><a>start</a> f <a>==</a> <a>start</a>
--   g</tt> and <tt>f <a>*</a> g <a>==</a> g <a>*</a> f</tt> holds: <tt>(f
--   <a>*</a> g)<a>^</a>a <a>==</a> f<a>^</a>a <a>*</a>
--   g<a>^</a>a</tt>.</li>
--   </ol>
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>The phrase ..<tt>a</tt> <i>is an element of</i> <tt>[-1,1]</tt>..
--   for the properties of <a>^</a> is meant to be: <tt><a>isOne</a> a</tt>
--   or <tt><a>isMinusOne</a> a</tt>.</li>
--   <li>If <tt>-1</tt> is an instance of <tt><a>Exponent</a> f</tt> (see
--   <a>minusOne</a>) then <tt>f</tt> has to be <a>Cayleyan</a>.</li>
--   </ol>
class (Multiplicative f, Number (Exponent f)) => Exponential f where {
    
    -- | the exponent.
    type Exponent f;
}

-- | the power of a factor to an exponent.
(^) :: Exponential f => f -> Exponent f -> f
infixl 9 ^

-- | the power of an orientation by an number.
--   
--   <b>Note</b> <a>opower</a> fulfill the properties of <a>Exponential</a>
--   for any number structure.
opower :: (Entity p, Number r) => Orientation p -> r -> Orientation p

-- | reals.
class Multiplicative f => Real f
power :: (Real f, Number r) => f -> r -> f
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Exponential.Real (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Multiplicative.Definition.Multiplicative c => OAlg.Structure.Exponential.Exponential (OAlg.Structure.Multiplicative.Definition.Inv c)


-- | definition of vectorial structures, i.e. <a>Additive</a> structures
--   with a scalar multiplication <tt>(<a>!</a>)</tt>.
module OAlg.Structure.Vectorial.Definition

-- | <a>Additive</a> structures with a <b>total</b> defined <b>scalar
--   multiplication</b> from the left by a <b>commutative semi ring</b>.
--   The entities of <b><tt>v</tt></b> are called <b>vector</b>.
--   
--   <b>Properties</b> Let <b><tt>v</tt></b> b a <a>Vectorial</a>
--   structure, then holds:
--   
--   <ol>
--   <li>For all <tt>s</tt> in <tt><a>Scalar</a> <b>v</b></tt> and
--   <tt>v</tt> in <b><tt>v</tt></b> holds: <tt>s<a>!</a>v</tt> is
--   <a>valid</a> and <tt><a>root</a> (s<a>!</a>v) <a>==</a> <a>root</a>
--   v</tt>.</li>
--   <li>For all <tt>v</tt> in <b><tt>v</tt></b> holds: <tt>0<a>!</a>v
--   <a>==</a> <a>zero</a> (<a>root</a> v)</tt>.</li>
--   <li>For all <tt>s</tt> in <tt><a>Scalar</a> <b>v</b></tt> and
--   <tt>r</tt> in <tt><a>Root</a> <b>v</b></tt> holds
--   <tt>s<a>!</a><a>zero</a> r <a>==</a> <a>zero</a> r</tt>.</li>
--   <li>For all <tt>r</tt>, <tt>s</tt> in <tt><a>Scalar</a> <b>v</b></tt>
--   and <tt>v</tt> in <b><tt>v</tt></b> holds: <tt>(r <a>+</a> s)<a>!</a>v
--   <a>==</a> r<a>!</a>v <a>+</a> s<a>!</a>v</tt>.</li>
--   <li>For all <tt>s</tt> in <tt><a>Scalar</a> <b>v</b></tt> and
--   <tt>v</tt>, <tt>w</tt> in <b><tt>v</tt></b> with <tt><a>root</a> v
--   <a>==</a> <a>root</a> w</tt> holds: <tt>s<a>!</a>(v <a>+</a> w)
--   <a>==</a> s<a>!</a>v <a>+</a> s<a>!</a>w</tt>.</li>
--   <li>For all <tt>v</tt> in <b><tt>v</tt></b> holds: <tt>1<a>!</a>v
--   <a>==</a> v</tt>.</li>
--   <li>For all <tt>r</tt>, <tt>s</tt> in <tt><a>Scalar</a> <b>v</b></tt>
--   and <tt>v</tt> in <b><tt>v</tt></b> holds: <tt>(r<a>*</a>s)<a>!</a>v
--   <a>==</a> r<a>!</a>(s<a>!</a>v)</tt>.</li>
--   </ol>
class (Semiring (Scalar v), Commutative (Scalar v), Additive v) => Vectorial v where {
    
    -- | the type of scalars.
    type Scalar v;
}

-- | scalar multiplication of a vector.
(!) :: Vectorial v => Scalar v -> v -> v
infixr 8 !

-- | type representing the class of <tt><b>k</b>-<a>Vectorial</a></tt>
--   structures.
data Vec k

-- | transformable to <tt><b>k</b>-<a>Vectorial</a></tt> structure.
class (ForgetfulFbr (s k), ForgetfulAdd (s k), Transformable (s k) (Vec k)) => ForgetfulVec k s

-- | <a>Vectorial</a> structures with a <b>partially</b> defined scalar
--   product.
--   
--   <b>Properties</b>
--   
--   <ol>
--   <li>For all <tt>v</tt>, <tt>w</tt> holds: if <tt><a>root</a> v
--   <a>==</a> <a>root</a> w</tt> then <tt>v <a>&lt;!&gt;</a> w</tt> is
--   <a>valid</a>, otherwise a <a>UndefinedScalarproduct</a>-exception will
--   be thrown.</li>
--   <li>For all <tt>u</tt> holds: <tt>u <a>&lt;!&gt;</a> <a>zero</a>
--   (<a>root</a> u) <a>==</a> <a>rZero</a></tt>.</li>
--   <li>For all <tt>u</tt>, <tt>v</tt> and <tt>w</tt> with <tt><a>root</a>
--   u <a>==</a> <a>root</a> w</tt> and <tt><a>root</a> w <a>==</a>
--   <a>root</a> v </tt> holds: <tt>u <a>&lt;!&gt;</a> (v <a>+</a> w)
--   <a>==</a> u <a>&lt;!&gt;</a> v <a>+</a> u <a>&lt;!&gt;</a>
--   w</tt>.</li>
--   <li>For all <tt>w</tt> holds: <tt><a>zero</a> (<a>root</a> w)
--   <a>&lt;!&gt;</a> w <a>==</a> <a>rZero</a></tt>.</li>
--   <li>For all <tt>u</tt>, <tt>v</tt> and <tt>w</tt> with <tt><a>root</a>
--   w <a>==</a> <a>root</a> u</tt> and <tt><a>root</a> u <a>==</a>
--   <a>root</a> v </tt> holds: <tt>(u <a>+</a> v) <a>&lt;!&gt;</a> w
--   <a>==</a> u <a>&lt;!&gt;</a> w <a>+</a> v' <a>!</a>' w</tt>.</li>
--   </ol>
class Vectorial v => Euclidean v

-- | the scalar product of two vectors.
(<!>) :: Euclidean v => v -> v -> Scalar v
infix 7 <!>
instance OAlg.Structure.Vectorial.Definition.ForgetfulVec k OAlg.Structure.Vectorial.Definition.Vec
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Vectorial.Definition.Vec k) OAlg.Structure.Definition.Typ
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Vectorial.Definition.Vec k) OAlg.Entity.Definition.Ent
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Vectorial.Definition.Vec k) OAlg.Structure.Fibred.Definition.Fbr
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Vectorial.Definition.Vec k) OAlg.Structure.Additive.Definition.Add
instance OAlg.Structure.Definition.ForgetfulTyp (OAlg.Structure.Vectorial.Definition.Vec k)
instance OAlg.Structure.Fibred.Definition.ForgetfulFbr (OAlg.Structure.Vectorial.Definition.Vec k)
instance OAlg.Structure.Additive.Definition.ForgetfulAdd (OAlg.Structure.Vectorial.Definition.Vec k)
instance OAlg.Structure.Vectorial.Definition.Euclidean OAlg.Data.Number.N
instance OAlg.Structure.Vectorial.Definition.Euclidean OAlg.Data.Number.Z
instance OAlg.Structure.Vectorial.Definition.Euclidean OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Vectorial.Definition.Euclidean (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Vectorial.Definition.Vectorial ()
instance OAlg.Structure.Vectorial.Definition.Vectorial GHC.Types.Int
instance OAlg.Structure.Vectorial.Definition.Vectorial GHC.Num.Integer.Integer
instance OAlg.Structure.Vectorial.Definition.Vectorial OAlg.Data.Number.N
instance OAlg.Structure.Vectorial.Definition.Vectorial OAlg.Data.Number.Z
instance OAlg.Structure.Vectorial.Definition.Vectorial OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Vectorial.Definition.Vectorial (OAlg.Structure.Oriented.Definition.Orientation p)
instance (OAlg.Structure.Vectorial.Definition.Vectorial v, OAlg.Structure.Fibred.Definition.FibredOriented v) => OAlg.Structure.Vectorial.Definition.Vectorial (OAlg.Data.Opposite.Op v)


-- | definition of algebraic structures, i.e. <a>Distributive</a>
--   structures with a suitable <a>Vectorial</a> structure.
module OAlg.Structure.Algebraic.Definition

-- | <a>Distributive</a> structures with a suitable <a>Vectorial</a>
--   structure.
--   
--   <b>Property</b> Let <b><tt>a</tt></b> be a <a>Algebraic</a> structure,
--   then holds:
--   
--   <ol>
--   <li>For all <tt>r</tt> in <tt><a>Scalar</a> <b>a</b></tt> and
--   <tt>a</tt>, <tt>b</tt> in <tt><b>a</b></tt> with <tt><a>start</a> a
--   <a>==</a> <a>end</a> b</tt> holds: <tt>r<a>!</a>(a<a>*</a>b) <a>==</a>
--   (r<a>!</a>a)<a>*</a>b</tt> and <tt>r<a>!</a>(a<a>*</a>b) <a>==</a>
--   a<a>*</a>(r<a>!</a>b)</tt>.</li>
--   </ol>
class (Distributive a, Vectorial a) => Algebraic a

-- | type representing the class of <tt><b>k</b>-<a>Algebraic</a></tt>
--   structures.
data Alg k

-- | transformable to <tt><b>k</b>-<a>Algebraic</a></tt> structure.
class (ForgetfulOrt (s k), ForgetfulMlt (s k), ForgetfulFbr (s k), ForgetfulFbrOrt (s k), ForgetfulAdd (s k), ForgetfulDst (s k), ForgetfulVec k s, Transformable (s k) (Alg k)) => ForgetfulAlg k s
instance OAlg.Structure.Algebraic.Definition.ForgetfulAlg k OAlg.Structure.Algebraic.Definition.Alg
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Algebraic.Definition.Alg k) OAlg.Structure.Definition.Typ
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Algebraic.Definition.Alg k) OAlg.Entity.Definition.Ent
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Algebraic.Definition.Alg k) OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Algebraic.Definition.Alg k) OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Algebraic.Definition.Alg k) OAlg.Structure.Fibred.Definition.Fbr
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Algebraic.Definition.Alg k) OAlg.Structure.Fibred.Definition.FbrOrt
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Algebraic.Definition.Alg k) OAlg.Structure.Additive.Definition.Add
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Algebraic.Definition.Alg k) OAlg.Structure.Distributive.Definition.Dst
instance OAlg.Structure.Definition.Transformable (OAlg.Structure.Algebraic.Definition.Alg k) (OAlg.Structure.Vectorial.Definition.Vec k)
instance OAlg.Structure.Definition.Transformable1 OAlg.Data.Opposite.Op (OAlg.Structure.Algebraic.Definition.Alg k)
instance OAlg.Structure.Definition.ForgetfulTyp (OAlg.Structure.Algebraic.Definition.Alg k)
instance OAlg.Structure.Oriented.Definition.ForgetfulOrt (OAlg.Structure.Algebraic.Definition.Alg k)
instance OAlg.Structure.Multiplicative.Definition.ForgetfulMlt (OAlg.Structure.Algebraic.Definition.Alg k)
instance OAlg.Structure.Fibred.Definition.ForgetfulFbr (OAlg.Structure.Algebraic.Definition.Alg k)
instance OAlg.Structure.Fibred.Definition.ForgetfulFbrOrt (OAlg.Structure.Algebraic.Definition.Alg k)
instance OAlg.Structure.Additive.Definition.ForgetfulAdd (OAlg.Structure.Algebraic.Definition.Alg k)
instance OAlg.Structure.Distributive.Definition.ForgetfulDst (OAlg.Structure.Algebraic.Definition.Alg k)
instance OAlg.Structure.Vectorial.Definition.ForgetfulVec k OAlg.Structure.Algebraic.Definition.Alg
instance OAlg.Structure.Algebraic.Definition.Algebraic ()
instance OAlg.Structure.Algebraic.Definition.Algebraic GHC.Types.Int
instance OAlg.Structure.Algebraic.Definition.Algebraic GHC.Num.Integer.Integer
instance OAlg.Structure.Algebraic.Definition.Algebraic OAlg.Data.Number.N
instance OAlg.Structure.Algebraic.Definition.Algebraic OAlg.Data.Number.Z
instance OAlg.Structure.Algebraic.Definition.Algebraic OAlg.Data.Number.Q
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Algebraic.Definition.Algebraic (OAlg.Structure.Oriented.Definition.Orientation p)
instance OAlg.Structure.Algebraic.Definition.Algebraic a => OAlg.Structure.Algebraic.Definition.Algebraic (OAlg.Data.Opposite.Op a)


-- | propositions on <a>Algebraic</a> structures.
module OAlg.Structure.Algebraic.Proposition

-- | validity of the <a>Algebraic</a> structure of <b><tt>a</tt></b>.
prpAlg :: Algebraic a => XAlg a -> Statement

-- | validity according to <a>OAlg.Structure.Algebraic.Definition#Alg1</a>.
prpAlg1 :: Algebraic a => X (Scalar a) -> X (Mltp2 a) -> Statement

-- | random variable to validate <a>Algebraic</a> structures.
data XAlg a
XAlg :: X (Scalar a) -> X (Mltp2 a) -> XAlg a

-- | the induces random variable.
xoAlg :: Algebraic a => X (Scalar a) -> XOrtSite d a -> XAlg a
instance OAlg.Structure.Algebraic.Definition.Algebraic a => OAlg.Data.Validable.Validable (OAlg.Structure.Algebraic.Proposition.XAlg a)


-- | <a>Algebraic</a> structures.
module OAlg.Structure.Algebraic


-- | propositions on <a>Vectorial</a> structures.
module OAlg.Structure.Vectorial.Proposition

-- | validity of the <a>Vectorial</a> structure of <tt><b>v</b></tt>.
prpVec :: Vectorial v => XVec v -> Statement

-- | validity according to <a>OAlg.Structure.Vectorial.Definition#Vec1</a>.
prpVec1 :: Vectorial v => X (Scalar v) -> X v -> Statement

-- | validity according to <a>OAlg.Structure.Vectorial.Definition#Vec2</a>.
prpVec2 :: Vectorial v => X v -> Statement

-- | validity according to <a>OAlg.Structure.Vectorial.Definition#Vec3</a>.
prpVec3 :: Vectorial v => p v -> X (Scalar v) -> X (Root v) -> Statement

-- | validity according to <a>OAlg.Structure.Vectorial.Definition#Vec4</a>.
prpVec4 :: Vectorial v => X (Scalar v) -> X v -> Statement

-- | validity according to <a>OAlg.Structure.Vectorial.Definition#Vec5</a>.
prpVec5 :: Vectorial v => X (Scalar v) -> X (Adbl2 v) -> Statement

-- | validity according to <a>OAlg.Structure.Vectorial.Definition#Vec6</a>.
prpVec6 :: Vectorial v => X v -> Statement

-- | validity according to <a>OAlg.Structure.Vectorial.Definition#Vec7</a>.
prpVec7 :: Vectorial v => X (Scalar v) -> X v -> Statement

-- | random variable to validate <a>Vectorial</a> structures.
data XVec v
XVec :: X (Scalar v) -> X (Root v) -> X v -> X (Adbl2 v) -> XVec v

-- | the induced random variable.
xoVec :: FibredOriented v => X (Scalar v) -> XOrtOrientation v -> XVec v
instance OAlg.Structure.Vectorial.Definition.Vectorial v => OAlg.Data.Validable.Validable (OAlg.Structure.Vectorial.Proposition.XVec v)


-- | <a>Vectorial</a> structures.
module OAlg.Structure.Vectorial


-- | homomorphisms between <a>Vectorial</a> structures having the same
--   associated <a>Scalar</a>.
module OAlg.Hom.Vectorial

-- | type family of homomorphisms between <a>Vectorial</a> structures
--   having the same associated 'Scalar.
--   
--   <b>Property</b> Let <tt><b>h</b></tt> be a type instance of the class
--   <tt><a>HomVectorial</a> <b>k</b></tt>, then for all <tt><b>a</b></tt>,
--   <tt><b>b</b></tt>, <tt>v</tt> in <tt><b>h</b> <b>a</b> <b>b</b></tt>
--   and <tt>x</tt> in <tt><b>k</b></tt> holds: <tt><a>amap</a> h (x
--   <a>!</a> v) <a>==</a> x <a>!</a> <a>amap</a> h v</tt>.
class (EmbeddableMorphism h (Vec k), HomAdditive h) => HomVectorial k h
instance OAlg.Hom.Vectorial.HomVectorial k h => OAlg.Hom.Vectorial.HomVectorial k (OAlg.Category.Path.Path h)
instance (OAlg.Structure.Vectorial.Definition.ForgetfulVec k s, OAlg.Structure.Definition.ForgetfulTyp (s k), Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable k) => OAlg.Hom.Vectorial.HomVectorial k (OAlg.Hom.Oriented.Definition.IdHom (s k))


-- | homomorphisms between <a>Algebraic</a> structures having the same
--   associated <a>Scalar</a>.
module OAlg.Hom.Algebraic

-- | type family of homomorphisms between <a>Algebraic</a> structures
--   having the same associated <a>Scalar</a>.
class (EmbeddableMorphism h (Alg k), HomDistributive h, HomVectorial k h) => HomAlgebraic k h
instance OAlg.Hom.Algebraic.HomAlgebraic k h => OAlg.Hom.Algebraic.HomAlgebraic k (OAlg.Category.Path.Path h)
instance (OAlg.Structure.Definition.TransformableOp (s k), OAlg.Structure.Algebraic.Definition.ForgetfulAlg k s, OAlg.Structure.Definition.ForgetfulTyp (s k), Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable k) => OAlg.Hom.Algebraic.HomAlgebraic k (OAlg.Hom.Oriented.Definition.IdHom (s k))


-- | homomorphisms between algebraic structures.
module OAlg.Hom


-- | defintion of free products over <a>Oriented</a> symbols with exponents
--   in a <a>Number</a>.
--   
--   <b>Note</b> On <a>Oriented</a> structures the canonical injection
--   <a>inj</a> and projection <a>prj</a> are bijections between the
--   <a>valid</a> entities of <a>Path</a> and <tt><a>Product</a>
--   <a>N</a></tt>. This is not true betwenn <a>Path</a> and
--   <tt><a>ProductForm</a> <a>N</a></tt> as
--   
--   <pre>
--   &gt;&gt;&gt; prj (P 3 :^ 2 :: ProductForm N Q) :: Path Q
--   Path () [3,3]
--   </pre>
--   
--   and
--   
--   <pre>
--   &gt;&gt;&gt; prj (P 3 :* P 3 :: ProductForm N Q) :: Path Q
--   Path () [3,3]
--   </pre>
--   
--   both map to the same <a>Path</a>! But
--   
--   <pre>
--   &gt;&gt;&gt; let p = make (P 3) :: Product N Q in p * p == p ^ 2
--   True
--   </pre>
module OAlg.Entity.Product.Definition

-- | free product over <a>Oriented</a> symbols in <tt><b>a</b></tt> with
--   exponents in a <a>Integral</a> <tt><b>r</b></tt>.
--   
--   <b>Definition</b> A <a>Product</a> <tt>p</tt> is <a>valid</a> if and
--   only if its underlying <a>ProductForm</a> <tt>pf</tt> is <a>valid</a>
--   and <tt>pf</tt> is reduced, i.e. <tt>pf == <a>reduce</a> pf</tt>.
data Product r a

-- | number of primary factors where where all simple factors are expanded
--   according to there exponent.
prLength :: Product N a -> N

-- | the <tt>n</tt>-th primary factor where all simple factors are expanded
--   according to there exponent.
prFactor :: Product N a -> N -> a

-- | the list of primary factors.
prFactors :: Product N a -> [a]

-- | restriction of <a>prfwrd</a>.
prwrd :: (Integral r, Oriented a) => Product r a -> Word r a

-- | mapping a product with exponents in <a>N</a> into a
--   <a>Multiplicative</a> structure applying a homomorphism between
--   <a>Oriented</a> structures.
nProduct :: (Hom Ort h, Multiplicative x) => h a x -> Product N a -> x

-- | mapping a product with exponents in <a>Z</a> into a <a>Cayleyan</a>
--   structure applying a homomorphism between <a>Oriented</a> structures.
zProduct :: (Hom Ort h, Cayleyan x) => h a x -> Product Z a -> x

-- | mapping a product.
prdMapTotal :: (Singleton (Point y), Oriented y, Integral r) => (x -> y) -> Product r x -> Product r y

-- | from <a>Op</a> symbols.
--   
--   <b>Property</b> For every <a>Oriented</a> structure <tt><b>a</b></tt>
--   and <a>Integral</a> <tt><b>r</b></tt> the resulting map
--   <a>prFromOp</a> is a <b>contravariant</b> homomorphisms between
--   <a>Multiplicative</a> structures.
prFromOp :: Product r (Op a) -> Product r a

-- | list of symbols in <tt><b>a</b></tt> together with an exponent in
--   <tt><b>r</b></tt>.
newtype Word r a
Word :: [(a, r)] -> Word r a

-- | the underlying list of <tt>a</tt>'s with their exponent.
fromWord :: Word r a -> [(a, r)]

-- | transforming a <a>ProductForm</a> to its corresponding <a>Word</a>.
prfwrd :: Integral r => ProductForm r a -> Word r a

-- | transforming a <a>Word</a> to it corresponding <a>ProductForm</a>.
--   
--   <b>Note</b> the <a>Point</a> is needed for empty <a>Word</a>s.
wrdprf :: Semiring r => Point a -> Word r a -> ProductForm r a

-- | reducing a <a>Word</a> by adding the exponents of consecutive equal
--   symbols and eliminating symbols with zero exponents.
wrdPrfGroup :: (Eq a, Semiring r) => Word r a -> Rdc (Word r a)

-- | factorization of a natural number to powers of primes. For <tt>0</tt>
--   there will be thrown <a>Undefined</a>.
nFactorize :: N -> Word N N

-- | factorization of a natural number to powers of primes smaller then the
--   given bound. For <tt>0</tt> there will be thrown <a>Undefined</a>.
nFactorize' :: N -> N -> Word N N

-- | form for a free product over <a>Oriented</a> symbols in
--   <tt><b>a</b></tt> with exponents in <tt><b>r</b></tt>.
--   
--   <b>Definition</b> Let <tt><b>r</b></tt> be a <a>Number</a>. A
--   <a>ProductForm</a> <tt>pf</tt> is <a>valid</a> if and only if
--   <tt><a>orientation</a> pf</tt> is <a>valid</a> (see definition below)
--   and all its symbols <tt>x</tt> - where <tt><a>P</a> x</tt> occurs in
--   <tt>pf</tt> - are <a>valid</a>.
--   
--   The <a>orientation</a> of <tt>pf</tt> is defined according:
--   
--   <pre>
--   orientation pf = case pf of
--     One p    -&gt; one p
--     P a      -&gt; orientation a
--     f :^ r   -&gt; orientation f ^ r where (^) = power
--     f :* g   -&gt; orientation f * orientation g
--   </pre>
--   
--   <b>Note</b> <a>Number</a> is required for <tt>-1</tt>, <tt>0</tt> and
--   <tt>1</tt> are not degenerated as in <tt>Z/2</tt> or <tt>Z/1</tt>.
data ProductForm r a
One :: Point a -> ProductForm r a
P :: a -> ProductForm r a
(:^) :: ProductForm r a -> r -> ProductForm r a
(:*) :: ProductForm r a -> ProductForm r a -> ProductForm r a
infixr 7 :*
infixl 9 :^

-- | length.
prfLength :: Number r => ProductForm r a -> N

-- | depth.
prfDepth :: ProductForm r a -> N

-- | list of elementary factors.
prfFactors :: ProductForm N a -> [a]

-- | mapping a product form with exponents in <a>N</a> into a
--   <a>Multiplicative</a> structure applying a homomorphism between
--   <a>Oriented</a> structures.
nProductForm :: (Hom Ort h, Multiplicative x) => h a x -> ProductForm N a -> x

-- | mapping a product form with exponents in <a>Z</a> into a
--   <a>Cayleyan</a> structure applying a homomorphism between
--   <a>Oriented</a> structures.
zProductForm :: (Hom Ort h, Cayleyan x) => h a x -> ProductForm Z a -> x

-- | formal inverse
--   
--   Let <tt>p</tt> in <tt><a>ProductForm</a> r a</tt> then:
--   
--   <b>Pre</b> If <tt>p</tt> contains a factor <tt><a>P</a> a</tt> then
--   <tt><a>minusOne</a> <a>/=</a> <a>Nothing</a></tt>.
--   
--   <b>Post</b> the formal inverse.
prfInverse :: Number r => ProductForm r a -> ProductForm r a

-- | from <a>Op</a> symbols.
prfFromOp :: ProductForm r (Op a) -> ProductForm r a

-- | mapping a product form
prfMapTotal :: Singleton (Point y) => (x -> ProductForm r y) -> ProductForm r x -> ProductForm r y

-- | reducing a <a>ProductForm</a> according to <tt><a>prfReduceWith</a>
--   <a>return</a></tt>.
prfReduce :: (Oriented a, Integral r) => ProductForm r a -> ProductForm r a

-- | reduces a product form by the given reduction rules for words until no
--   more reductions are applicable.
prfReduceWith :: (Oriented a, Integral r) => (Word r a -> Rdc (Word r a)) -> ProductForm r a -> ProductForm r a

-- | applicative operation from the right.
prfopr :: (x -> t -> x) -> x -> ProductForm N t -> x

-- | partially strict version of <a>prfopr</a>, i.e. every <tt>n</tt>-th
--   application will be reduced to head normal form.
--   
--   Let <tt>x' = <a>prfopr'</a> n op x p</tt>.
--   
--   <b>Pre</b> <tt>0 <a>&lt;</a> n</tt>.
--   
--   <b>Post</b> <tt>x' <a>==</a> <a>prfopr</a> op x p</tt>.
prfopr' :: N -> (x -> t -> x) -> x -> ProductForm N t -> x

-- | applicative operation from the left.
prfopl :: (t -> x -> x) -> ProductForm N t -> x -> x

-- | partially strict version of <a>prfopl</a>, i.e. every <tt>n</tt>-th
--   application will be reduced to head normal form.
--   
--   Let <tt>x' = <a>prfopl'</a> n op p x</tt>.
--   
--   <b>Pre</b> <tt>0 <a>&lt;</a> n</tt>.
--   
--   <b>Post</b> <tt>x' <a>==</a> <a>prfopl</a> op p x</tt>.
prfopl' :: N -> (t -> x -> x) -> ProductForm N t -> x -> x
instance (OAlg.Data.Validable.Validable a, OAlg.Data.Validable.Validable r) => OAlg.Data.Validable.Validable (OAlg.Entity.Product.Definition.Word r a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq r) => GHC.Classes.Eq (OAlg.Entity.Product.Definition.Word r a)
instance (GHC.Show.Show a, GHC.Show.Show r) => GHC.Show.Show (OAlg.Entity.Product.Definition.Word r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Oriented.Definition.OrdPoint a, GHC.Classes.Ord a, GHC.Classes.Ord r, OAlg.Entity.Definition.Entity r) => GHC.Classes.Ord (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Entity.Definition.Entity r) => GHC.Classes.Eq (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Entity.Definition.Entity r) => GHC.Show.Show (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Entity.Definition.Entity r) => GHC.Show.Show (OAlg.Entity.Product.Definition.ProductForm r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Entity.Definition.Entity r) => GHC.Classes.Eq (OAlg.Entity.Product.Definition.ProductForm r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Entity.Definition.Entity r, GHC.Classes.Ord a, OAlg.Structure.Oriented.Definition.OrdPoint a, GHC.Classes.Ord r) => GHC.Classes.Ord (OAlg.Entity.Product.Definition.ProductForm r a)
instance Data.Foldable.Foldable (OAlg.Entity.Product.Definition.Product OAlg.Data.Number.N)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Product.Definition.Product OAlg.Data.Number.N a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r) => OAlg.Data.Validable.Validable (OAlg.Entity.Product.Definition.Product r a)
instance OAlg.Data.Constructable.Exposable (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r) => OAlg.Data.Constructable.Constructable (OAlg.Entity.Product.Definition.Product r a)
instance OAlg.Entity.Sequence.Definition.Sequence (OAlg.Entity.Product.Definition.Product OAlg.Data.Number.N) OAlg.Data.Number.N a
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r) => OAlg.Data.Canonical.Embeddable a (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r) => OAlg.Data.Canonical.Embeddable (OAlg.Structure.Oriented.Definition.Path a) (OAlg.Entity.Product.Definition.Product r a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Data.Canonical.Projectible (OAlg.Structure.Oriented.Definition.Path a) (OAlg.Entity.Product.Definition.Product OAlg.Data.Number.N a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r) => OAlg.Entity.Definition.Entity (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r) => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r, OAlg.Structure.Ring.Definition.Ring r) => OAlg.Structure.Multiplicative.Definition.Invertible (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r, OAlg.Structure.Ring.Definition.Ring r) => OAlg.Structure.Multiplicative.Definition.Cayleyan (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r) => OAlg.Structure.Exponential.Exponential (OAlg.Entity.Product.Definition.Product r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Number r) => OAlg.Data.Validable.Validable (OAlg.Entity.Product.Definition.ProductForm r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Number r) => OAlg.Entity.Definition.Entity (OAlg.Entity.Product.Definition.ProductForm r a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Number r) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Product.Definition.ProductForm r a)
instance Data.Foldable.Foldable (OAlg.Entity.Product.Definition.ProductForm OAlg.Data.Number.N)
instance OAlg.Data.Canonical.Embeddable (OAlg.Structure.Oriented.Definition.Path a) (OAlg.Entity.Product.Definition.ProductForm r a)
instance OAlg.Data.Canonical.Embeddable a (OAlg.Entity.Product.Definition.ProductForm r a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Data.Canonical.Projectible (OAlg.Structure.Oriented.Definition.Path a) (OAlg.Entity.Product.Definition.ProductForm OAlg.Data.Number.N a)
instance OAlg.Structure.Number.Definition.Integral r => OAlg.Data.Canonical.Embeddable (OAlg.Entity.Product.Definition.ProductForm OAlg.Data.Number.N a) (OAlg.Entity.Product.Definition.ProductForm r a)
instance OAlg.Structure.Number.Definition.Integral r => OAlg.Data.Canonical.Projectible (OAlg.Entity.Product.Definition.ProductForm OAlg.Data.Number.N a) (OAlg.Entity.Product.Definition.ProductForm r a)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Product.Definition.ProductForm OAlg.Data.Number.N a)
instance OAlg.Entity.Sequence.Definition.Sequence (OAlg.Entity.Product.Definition.ProductForm OAlg.Data.Number.N) OAlg.Data.Number.N x
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Number.Definition.Integral r) => OAlg.Data.Reducible.Reducible (OAlg.Entity.Product.Definition.ProductForm r a)


-- | propositions on free products over <a>Oriented</a> symbols with
--   exponents in a <a>Number</a>.
module OAlg.Entity.Product.Proposition

-- | validity of <tt><a>Product</a> <b>r</b> (<a>Orientation</a>
--   <a>Symbol</a>)</tt> for <tt><b>r</b></tt> equal to <a>N</a> and
--   <a>Z</a> respectively
prpProduct :: Statement

-- | validity of <tt><a>Product</a> <a>N</a> (<a>Orientation</a>
--   <a>Symbol</a>)</tt> being <a>Oriented</a>.
prpOrtProductNOrntSymbol :: Statement

-- | validity of <tt><a>Product</a> <a>Z</a> (<a>Orientation</a>
--   <a>Symbol</a>)</tt> being <a>Oriented</a>.
prpOrtProductZOrntSymbol :: Statement

-- | validity of <tt><a>Product</a> <a>N</a> (<a>Orientation</a>
--   <a>Symbol</a>)</tt> being <a>Multiplicative</a>.
prpMltProductNOrntSymbol :: Statement

-- | validity of <tt><a>Product</a> <a>Z</a> (<a>Orientation</a>
--   <a>Symbol</a>)</tt> being <a>Multiplicative</a>.
prpMltProductZOrntSymbol :: Statement

-- | random variable of products generated from product forms with a
--   maximal given <i>depth</i> (<a>:^</a> dose not increases the depth).
xStartProduct :: (Oriented a, Integral r) => XOrtSite From a -> X r -> N -> XOrtSite From (Product r a)

-- | random variable of product forms with maximal <i>depth</i> <tt>d</tt>
--   (a <a>:^</a> constructor dose not increases the depth).
xStartProductForm :: (Oriented a, Number r) => XOrtSite From a -> X r -> N -> XOrtSite From (ProductForm r a)

-- | the induced random variable on <tt><a>Orientation</a>
--   <a>Symbol</a>)</tt>.
xPrdSymStart :: Integral r => N -> X r -> XOrtSite From (Product r (Orientation Symbol))

-- | the induced random variable for validating <a>Multiplicative</a>
--   structures.
xPrdSymMlt :: Integral r => N -> X r -> XMlt (Product r (Orientation Symbol))

-- | example of a <a>XStart</a> for the quiver having two points 'a' and
--   'b' and two arrows <tt>'a':&gt;'a'</tt> and <tt>'a':&gt;'b'</tt>.
xT :: XOrtSite From (Orientation Char)

-- | its distribution
dstT :: Int -> N -> IO ()


-- | free products of symbols in <tt><b>x</b></tt> with index type
--   <a>N</a>.
module OAlg.Entity.Product.ProductSymbol

-- | free product of symbols in <tt><b>x</b></tt> with index type <a>N</a>.
--   
--   <b>Example</b>
--   
--   The expression <tt><a>sy</a> 'a'</tt> constructs a free product of
--   exactly one symbol in <a>Char</a> consisting just of the character
--   <tt>'a'</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; sy 'a'
--   ProductSymbol['a']
--   </pre>
--   
--   they are <a>Total</a> <a>Multiplicative</a>
--   
--   <pre>
--   &gt;&gt;&gt; sy 'a' * sy 'b' * sy 'c'
--   ProductSymbol['a'*'b'*'c']
--   </pre>
--   
--   and admit a listing
--   
--   <pre>
--   &gt;&gt;&gt; list (Proxy :: Proxy N) (sy 'a' * sy 'b' * sy 'c')
--   [('a',0),('b',1),('c',2)]
--   </pre>
--   
--   they have a compact representation for repetitions
--   
--   <pre>
--   &gt;&gt;&gt; sy 'a' * sy 'b' * sy 'b' * sy 'a' * sy 'c'
--   ProductSymbol['a'*'b'^2*'a'*'c']
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sy 'a' * sy 'b' * sy 'b' * sy 'a' * sy 'c' == sy 'a' * sy 'b' ^ 2 * sy 'a' * sy 'c'
--   True
--   </pre>
--   
--   but they are not <a>Commutative</a>
--   
--   <pre>
--   &gt;&gt;&gt; sy 'a' * sy 'b' ^ 2 * sy 'a' * sy 'c' == sy 'a' ^ 2 * sy 'b' ^ 2 * sy 'c'
--   False
--   </pre>
--   
--   and they admit a total right operation <a>&lt;*</a> of
--   <tt><a>Permutation</a> <a>N</a></tt>
--   
--   <pre>
--   &gt;&gt;&gt; (sy 'a' * sy 'b' ^ 2 * sy 'a' * sy 'c') &lt;* (pmtSwap 1 3 :: Permutation N)
--   ProductSymbol['a'^2*'b'^2*'c']
--   </pre>
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>Free products of symbols are finite complete sequences and allow a
--   compact representation for repetitions and serve merely as dimensions
--   for matrices (see <a>OAlg.Entity.Matrix.Dim</a>).</li>
--   <li>Possibly infinite complete sequences are represented by
--   <tt>[<b>x</b>]</tt>.</li>
--   </ol>
newtype ProductSymbol x
ProductSymbol :: Product N (U x) -> ProductSymbol x

-- | symbol of an entity, i.e. the complete sequence of <a>psyLength</a>
--   one consisting just of it.
--   
--   <b>Example</b>
--   
--   <pre>
--   &gt;&gt;&gt; sy 'a'
--   ProductSymbol['a']
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sy 'a' * sy 'b' * sy 'b' ^ 5 * sy 'c'
--   ProductSymbol['a'*'b'^6*'c']
--   </pre>
sy :: Entity x => x -> ProductSymbol x

-- | showing as a product of symbols.
psyShow :: Entity x => ProductSymbol x -> String

-- | the indexed listing of the symbols.
psyxs :: ProductSymbol x -> [(x, N)]

-- | the underlying word.
psywrd :: Entity x => ProductSymbol x -> Word N x

-- | from word.
wrdpsy :: Entity x => Word N x -> ProductSymbol x

-- | proxy for <a>N</a>.
nProxy :: Proxy N

-- | joining complete sequences.
psyJoin :: Entity x => ProductSymbol (ProductSymbol x) -> ProductSymbol x

-- | the induced product of symbols.
productSymbol :: Entity x => [x] -> ProductSymbol x

-- | the length of a complete sequence.
psyLength :: ProductSymbol x -> N

-- | the symbol for the given index.
psyFactor :: ProductSymbol x -> N -> x

-- | mapping free products of symbols.
psyMap :: Entity y => (x -> y) -> ProductSymbol x -> ProductSymbol y

-- | adjoins the point <tt>()</tt> to an entity.
--   
--   <b>Note</b> Serves to build sums or products over symbols in
--   <tt><b>x</b></tt>.
newtype U x
U :: x -> U x

-- | deconstructor.
fromU :: U x -> x

-- | random variable of complete sequences with the given maximal length.
xProductSymbol :: Entity x => N -> X x -> X (ProductSymbol x)
instance Data.Foldable.Foldable OAlg.Entity.Product.ProductSymbol.U
instance OAlg.Data.Validable.Validable x => OAlg.Data.Validable.Validable (OAlg.Entity.Product.ProductSymbol.U x)
instance GHC.Base.Functor OAlg.Entity.Product.ProductSymbol.U
instance GHC.Show.Show x => GHC.Show.Show (OAlg.Entity.Product.ProductSymbol.U x)
instance GHC.Classes.Ord x => GHC.Classes.Ord (OAlg.Entity.Product.ProductSymbol.U x)
instance GHC.Classes.Eq x => GHC.Classes.Eq (OAlg.Entity.Product.ProductSymbol.U x)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance Data.Foldable.Foldable OAlg.Entity.Product.ProductSymbol.ProductSymbol
instance OAlg.Entity.Definition.Entity x => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance OAlg.Entity.Definition.Entity x => OAlg.Entity.Definition.Entity (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance OAlg.Entity.Definition.Entity x => OAlg.Data.Validable.Validable (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance (OAlg.Entity.Definition.Entity x, GHC.Classes.Ord x) => GHC.Classes.Ord (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance OAlg.Entity.Definition.Entity x => GHC.Classes.Eq (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance OAlg.Entity.Definition.Entity x => GHC.Show.Show (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance OAlg.Entity.Definition.Entity x => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance OAlg.Entity.Definition.Entity x => OAlg.Structure.Exponential.Exponential (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance OAlg.Data.Constructable.Exposable (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance OAlg.Entity.Definition.Entity x => OAlg.Data.Constructable.Constructable (OAlg.Entity.Product.ProductSymbol.ProductSymbol x)
instance OAlg.Entity.Sequence.Definition.Sequence OAlg.Entity.Product.ProductSymbol.ProductSymbol OAlg.Data.Number.N x
instance OAlg.Entity.Definition.Entity x => OAlg.Entity.Sequence.Definition.ConstructableSequence OAlg.Entity.Product.ProductSymbol.ProductSymbol OAlg.Data.Number.N x
instance OAlg.Entity.Definition.Entity x => OAlg.Entity.Definition.Entity (OAlg.Entity.Product.ProductSymbol.U x)
instance OAlg.Entity.Definition.Entity x => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Product.ProductSymbol.U x)
instance OAlg.Structure.Oriented.Definition.OrdPoint (OAlg.Entity.Product.ProductSymbol.U x)


-- | completely defined sequences of items in <tt><b>x</b></tt> with index
--   type <a>N</a>.
module OAlg.Entity.Sequence.CSequence

-- | completely defined sequences of items, i.e. free products with index
--   type <a>N</a>.
type CSequence = ProductSymbol

-- | random variable for comletely defined sequences with the given maximal
--   length.
xCSequence :: Entity x => N -> X x -> X (CSequence x)


-- | free products on <a>Oriented</a> symbols with exponents in a
--   <a>Number</a>.
module OAlg.Entity.Product


-- | permutations on totally ordered index types <tt><b>i</b></tt> to
--   permute the items of sequences.
module OAlg.Entity.Sequence.Permutation

-- | permutation of a totally ordered index type <tt><b>i</b></tt> which
--   yield a <i>bijection</i> <a>pmt</a> on <tt><b>i</b></tt>. They are
--   constructed using
--   
--   <ul>
--   <li><a>make</a> of a <a>valid</a> <a>PermutationForm</a>, which
--   defines also the validity for the constructed permutation.</li>
--   <li><a>swap</a> and the <a>Multiplicative</a> structure for
--   permutations.</li>
--   <li><a>permuteBy</a> for <a>PermutableSequence</a>.</li>
--   <li><a>xPermutation</a> to generate randomly permutations.</li>
--   </ul>
--   
--   In the following the total right operation <a>&lt;*</a> of a
--   permutation on several types of sequences will be defined to achieve
--   the permutation of there items.
--   
--   <b>Definitions</b>
--   
--   <ul>
--   <li><i>List</i> Let <tt>xs</tt> be in <tt>[<b>x</b>]</tt> with
--   <tt><a>ConstructableSequence</a> [] <b>r</b> [<b>x</b>]</tt> and
--   <tt>p</tt> a permutation in <tt><a>Permutation</a> <b>r</b></tt>, then
--   <tt>xs <a>&lt;*</a> p</tt> is given by <tt><a>sqcIndexMap</a> is
--   (<a>pmt</a> p) xs</tt>, where <tt>is</tt> is the image of the support
--   of <tt>xs</tt> under the inverse of <tt>p</tt>.</li>
--   <li><i>CSequence</i> Let <tt>xs</tt> be in <tt><a>CSequence</a>
--   <b>x</b></tt> with <tt><a>ConstructableSequence</a> <a>CSequence</a>
--   <a>N</a> <b>x</b></tt> and <tt>p</tt> a permutation in
--   <tt><a>Permutation</a> <a>N</a></tt>, then <tt>xs <a>&lt;*</a> p</tt>
--   is given by <tt><a>sqcIndexMap</a> is (<a>pmt</a> p) xs</tt>, where
--   <tt>is</tt> is the image of the support of <tt>xs</tt> under the
--   inverse of <tt>p</tt>.</li>
--   <li><i>PSequence</i> Let <tt>xs</tt> be in <tt><a>PSequence</a>
--   <b>i</b> <b>x</b></tt> with <tt><a>ConstructableSequence</a>
--   (<a>PSequence</a> <b>i</b>) <b>i</b> <b>x</b></tt> and <tt>p</tt> a
--   permutation in <tt><a>Permutation</a> <b>i</b></tt>, then <tt>xs
--   <a>&lt;*</a> p</tt> is given by <tt><a>sqcIndexMap</a> is (<a>pmt</a>
--   p) xs</tt>, where <tt>is</tt> is the image of the support of
--   <tt>xs</tt> under the inverse of <tt>p</tt>.</li>
--   <li><i>Permutation</i> Let <tt>xs</tt>, <tt>p</tt> be in
--   <tt><a>Permutation</a> <b>i</b></tt>, then <tt>xs <a>&lt;*</a> p</tt>
--   is given by <a>*</a>.</li>
--   </ul>
--   
--   <b>Note</b> The given definitions are not very efficient and only
--   terminate for finite sequences (in fact, a more efficient
--   implementation has been chosen that also terminates for infinite
--   sequences (see example below)). However, they serve on the one hand to
--   define the semantic and to 'prove' the properties for <a>TotalOpr</a>
--   and on the other hand to verify the chosen implementation for finite
--   sequences (see <a>prpOprPermutation</a>).
--   
--   <b>Examples</b>
--   
--   <pre>
--   &gt;&gt;&gt; "abcdef" &lt;* (swap 2 5 :: Permutation N)
--   "abfdec"
--   </pre>
--   
--   the support of a sequence and the relevant image of a permutation may
--   be disjoint which will leave the sequence untouched
--   
--   <pre>
--   &gt;&gt;&gt; "abcdef" &lt;* (swap 7 10 :: Permutation N)
--   "abcdef"
--   </pre>
--   
--   the intersection of the support of a sequence with the relevant image
--   of a permutation may be a non empty proper sub set
--   
--   <pre>
--   &gt;&gt;&gt; "abcdef" &lt;* swap 2 10 :: Permutation N)
--   "abdefc"
--   </pre>
--   
--   the result can be interpreted as: first, put <tt>c</tt> at position
--   <tt>10</tt> and <a>Nothing</a> (which is the item at position
--   <tt>10</tt>) at position <tt>2</tt>. Second, strip all nothings form
--   it.
--   
--   Although the given definition of the permutation of sequences dose not
--   terminate for infinite sequences, its implementation will terminate
--   
--   <pre>
--   &gt;&gt;&gt; takeN 5 $ (([0..] :: [N]) &lt;* (swap 1 2 :: Permutation N)
--   [0,2,1,3,4]
--   </pre>
data Permutation i

-- | the bijection on <tt><b>i</b></tt> for a given permutation and is
--   defined via <tt><a>restrict</a> <a>pmf</a></tt>.
pmt :: Ord i => Permutation i -> i -> i

-- | swapping.
--   
--   <b>Property</b> Let <tt>p = <a>swap</a> n (i,j)</tt>, then holds: If
--   <tt>i,j <a>&lt;</a> n</tt> then <tt>p</tt> is the permutation given by
--   swapping <tt>i</tt> with <tt>j</tt>, otherwise a exception will be
--   thrown.
swap :: (Entity i, Ord i) => i -> i -> Permutation i

-- | total right operations of permutations on sequences, admitting the
--   following properties:
--   
--   <b>Property</b> Let <tt><b>s</b></tt>, <tt><b>i</b></tt>,
--   <tt><b>x</b></tt> be an instance of <tt><a>PermutableSequence</a>
--   <b>s</b> <b>i</b> <b>x</b></tt>, then holds:
--   
--   <ol>
--   <li>Let <tt>xs</tt> be in <tt><b>s</b> <b>x</b></tt>, <tt>p</tt> in
--   <tt><a>Permutation</a> <b>i</b></tt> with <tt><a>image</a> z p
--   <a>&lt;&lt;=</a> <a>support</a> z xs</tt> for some <tt>z</tt> in
--   <tt><b>z</b> <b>i</b></tt>, then holds: <tt>(xs <a>&lt;*</a> p)
--   <a>??</a> i <a>==</a> ((xs <a>??</a>) <a>.</a> <a>pmt</a> p) i</tt>
--   for all <tt>i</tt> in <tt><a>support</a> z xs</tt>.</li>
--   <li>Let <tt>xs</tt> be in <tt><b>s</b> <b>x</b></tt>, <tt>w</tt> in
--   <tt><b>x</b> -&gt; <b>w</b></tt>, <tt>c</tt> in <tt><b>w</b> -&gt;
--   <b>w</b> -&gt; <a>Ordering</a></tt> and <tt>z</tt> in <tt><b>z</b>
--   <b>i</b></tt>, then holds: Let <tt>(xs',p) = <a>permuteBy</a> z c w
--   xs</tt> in<ol><li><tt>xs' <a>==</a> xs <a>&lt;*</a>
--   p</tt>.</li><li><tt>xs'</tt> is ordered according to <tt>c</tt> by
--   applying <tt>w</tt> to its items.</li><li><tt><a>image</a> z p
--   <a>&lt;&lt;=</a> <a>support</a> z xs</tt>.</li></ol></li>
--   </ol>
--   
--   <b>Examples</b>
--   
--   <pre>
--   &gt;&gt;&gt; fst $ permuteBy nProxy compare isUpper "abCd1eFgH"
--   "abd1egCFH"
--   </pre>
--   
--   as <tt><a>False</a> <a>&lt;</a> <a>True</a></tt>
--   
--   <pre>
--   &gt;&gt;&gt; fst $ permuteBy nProxy (coCompare compare) isUpper "abCd1eFgH"
--   "CFHabd1eg"
--   </pre>
--   
--   which orders it in the reverse ordering.
class (Sequence s i x, TotalOpr (Permutation i) (s x)) => PermutableSequence s i x

-- | a resulting permuation.
permuteBy :: PermutableSequence s i x => p i -> (w -> w -> Ordering) -> (x -> w) -> s x -> (s x, Permutation i)

-- | orders the permutable sequence according to the given ordering an
--   delivers the resulting permutation form.
permuteByN :: PermutableSequence s N x => (w -> w -> Ordering) -> (x -> w) -> s x -> (s x, Permutation N)

-- | form of a permutation from <tt><b>i</b></tt> to <tt><b>i</b></tt>
--   which is given by <a>pmf</a>.
--   
--   <b>Property</b> Let <tt>p = <a>PermutationForm</a> jis</tt> be in
--   <tt><a>PermutationForm</a> <b>i</b></tt>, then holds:
--   <tt><a>support</a> z p <a>==</a> <a>image</a> z p</tt> for some proxy
--   <tt>z</tt> in <tt><b>z</b> <b>i</b></tt>.
--   
--   The partial sequence <tt>ijs</tt> is called the <b><i>relevant
--   part</i></b> of <tt>p</tt>.
newtype PermutationForm i
PermutationForm :: PSequence i i -> PermutationForm i

-- | the associated function <tt><b>i</b></tt> to <tt><b>i</b></tt> and is
--   given by:
--   
--   <b>Definition</b> Let <tt>p = <a>PermutationForm</a> jis</tt> be in
--   <tt><a>PermutationForm</a> <b>i</b></tt> then <tt><a>pmf</a> p i</tt>
--   is defined by: If there exists an <tt>(j,i')</tt> in <tt><a>psqxs</a>
--   jis</tt> with <tt>i' <a>==</a> i</tt> then <tt><a>pmf</a> p i = j</tt>
--   else <tt><a>pmf</a> p i = i</tt>.
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>If the partial sequence <tt>ijs</tt> is <a>valid</a>, then for all
--   <tt>i</tt> in <tt><b>i</b></tt> there exists at most one
--   <tt>(_,i')</tt> in <tt><a>psqxs</a> jis</tt> such that <tt>i'
--   <a>==</a> i</tt>. As such, the function <tt><a>pmf</a> p</tt> is well
--   defined.</li>
--   <li>If the permutation form <tt>p</tt> itself is <a>valid</a> than
--   <tt><a>pmf</a> p</tt> is a bijection and as such a permutation of
--   <tt><b>i</b></tt>.</li>
--   <li>The behavior of <a>pmf</a> differs from <a>??</a> as its
--   evaluation will not end up in a
--   <a>IndexOutOfSupport</a>-exception.</li>
--   </ol>
pmf :: Ord i => PermutationForm i -> i -> i

-- | random variable of permutations.
xPermutation :: (Entity i, Ord i) => N -> X i -> X (Permutation i)

-- | random variable of permutations within the given bounds.
xPermutationB :: (Ord i, Enum i) => i -> i -> X (Permutation i)

-- | random variable of permutations of the index set <tt>[0..prd n]</tt>.
xPermutationN :: N -> X (Permutation N)

-- | random variable for validating the <a>Multiplicative</a> structure.
xMltPermutation :: (Entity i, Ord i) => N -> X i -> XMlt (Permutation i)

-- | validity of the functionality of the module <a>Permutation</a>.
prpPermutation :: Statement

-- | validity for <a>PermutableSequence</a>.
prpPermutableSequence :: (PermutableSequence s i x, Entity x, Entity i, Show w) => N -> z i -> (w -> w -> Ordering) -> (x -> w) -> X (s x) -> Statement

-- | validity of the total right operation <a>&lt;*</a> of permutations on
--   sequences.
prpOprPermutation :: Statement
instance OAlg.Data.Number.LengthN (OAlg.Entity.Sequence.Permutation.PermutationForm i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (OAlg.Entity.Sequence.Permutation.PermutationForm i)
instance GHC.Show.Show i => GHC.Show.Show (OAlg.Entity.Sequence.Permutation.PermutationForm i)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Sequence.Permutation.Permutation i)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Definition.Entity (OAlg.Entity.Sequence.Permutation.Permutation i)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Data.Validable.Validable (OAlg.Entity.Sequence.Permutation.Permutation i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (OAlg.Entity.Sequence.Permutation.Permutation i)
instance GHC.Show.Show i => GHC.Show.Show (OAlg.Entity.Sequence.Permutation.Permutation i)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Sequence.Permutation.PermutableSequence (OAlg.Entity.Sequence.PSequence.PSequence i) i x
instance OAlg.Entity.Definition.Entity x => OAlg.Entity.Sequence.Permutation.PermutableSequence [] OAlg.Data.Number.N x
instance OAlg.Entity.Definition.Entity x => OAlg.Entity.Sequence.Permutation.PermutableSequence OAlg.Entity.Sequence.CSequence.CSequence OAlg.Data.Number.N x
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Sequence.Permutation.PermutableSequence OAlg.Entity.Sequence.Permutation.Permutation i i
instance OAlg.Data.Constructable.Exposable (OAlg.Entity.Sequence.Permutation.Permutation i)
instance GHC.Classes.Eq i => OAlg.Data.Constructable.Constructable (OAlg.Entity.Sequence.Permutation.Permutation i)
instance GHC.Classes.Ord i => OAlg.Entity.Sequence.Definition.Sequence OAlg.Entity.Sequence.Permutation.Permutation i i
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Sequence.Permutation.Permutation i)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Sequence.Permutation.Permutation i)
instance OAlg.Structure.Oriented.Definition.Total (OAlg.Entity.Sequence.Permutation.Permutation i)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Structure.Multiplicative.Definition.Invertible (OAlg.Entity.Sequence.Permutation.Permutation i)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Structure.Multiplicative.Definition.Cayleyan (OAlg.Entity.Sequence.Permutation.Permutation i)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Structure.Exponential.Exponential (OAlg.Entity.Sequence.Permutation.Permutation i)
instance GHC.Classes.Ord i => OAlg.Structure.Operational.Opr (OAlg.Entity.Sequence.Permutation.Permutation i) (OAlg.Entity.Sequence.PSequence.PSequence i x)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i, OAlg.Entity.Definition.Entity x) => OAlg.Structure.Operational.TotalOpr (OAlg.Entity.Sequence.Permutation.Permutation i) (OAlg.Entity.Sequence.PSequence.PSequence i x)
instance OAlg.Structure.Operational.Opr (OAlg.Entity.Sequence.Permutation.Permutation OAlg.Data.Number.N) [x]
instance OAlg.Entity.Definition.Entity x => OAlg.Structure.Operational.TotalOpr (OAlg.Entity.Sequence.Permutation.Permutation OAlg.Data.Number.N) [x]
instance OAlg.Entity.Definition.Entity x => OAlg.Structure.Operational.Opr (OAlg.Entity.Sequence.Permutation.Permutation OAlg.Data.Number.N) (OAlg.Entity.Sequence.CSequence.CSequence x)
instance OAlg.Entity.Definition.Entity x => OAlg.Structure.Operational.TotalOpr (OAlg.Entity.Sequence.Permutation.Permutation OAlg.Data.Number.N) (OAlg.Entity.Sequence.CSequence.CSequence x)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Structure.Operational.Opr (OAlg.Entity.Sequence.Permutation.Permutation i) (OAlg.Entity.Sequence.Permutation.Permutation i)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Structure.Operational.TotalOpr (OAlg.Entity.Sequence.Permutation.Permutation i) (OAlg.Entity.Sequence.Permutation.Permutation i)
instance GHC.Classes.Ord i => OAlg.Entity.Sequence.Definition.Sequence OAlg.Entity.Sequence.Permutation.PermutationForm i i
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Data.Validable.Validable (OAlg.Entity.Sequence.Permutation.PermutationForm i)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Definition.Entity (OAlg.Entity.Sequence.Permutation.PermutationForm i)
instance (OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Sequence.Permutation.PermutationForm i)
instance GHC.Classes.Eq i => OAlg.Data.Reducible.Reducible (OAlg.Entity.Sequence.Permutation.PermutationForm i)


-- | Sequences of indexed items in a type <tt><b>x</b></tt> with an index
--   type <tt><b>i</b></tt> and there permutations. We consider two kinds
--   of sequences:
--   
--   <ul>
--   <li><i>Complete</i> Sequences <tt>x 0,x 1,x 2,..</tt> with an integral
--   index type <tt><b>i</b></tt> where there indices don't have
--   <i>wholes</i> and start at <tt>0</tt>, e.g. <tt>[<b>x</b>]</tt> or
--   free products of symbols in <tt><b>x</b></tt> i.e.
--   <a>ProductSymbol</a>.</li>
--   <li><i>Partial</i> Sequences <tt>x i0,x i1,x i2,..</tt> with a totally
--   ordered index type <tt><b>i</b></tt> where there indices allow
--   <i>wholes</i>, e.g. <a>PSequence</a>, <a>Set</a>, <a>Graph</a>.</li>
--   </ul>
--   
--   Furthermore there are total right operations of <a>Permutation</a>
--   defined on them which permutes the corresponding indices to yield a
--   new sequence.
module OAlg.Entity.Sequence


-- | entries of matrices and viewing them as a column of rows respectively
--   as a row of columns.
module OAlg.Entity.Matrix.Entries

-- | two dimensional partial sequence.
newtype Entries i j x
Entries :: PSequence (i, j) x -> Entries i j x

-- | underlying list of indexed entries.
etsxs :: Entries i j x -> [(x, i, j)]

-- | the empty sequence of entries.
etsEmpty :: Entries i j x

-- | adding two entries.
--   
--   <b>Property</b> Let <tt>zs = <a>etsAdd</a> xs ys</tt>, then holds:
--   
--   <ul>
--   <li><i>Pre</i> For all <tt>(i,j)</tt> in <tt>(<b>i</b>,<b>j</b>)</tt>
--   where there exists an <tt>(x,i,j)</tt> in <tt>xs</tt> and a
--   <tt>(y,i,j)</tt> in <tt>ys</tt> holds: <tt><a>root</a> x <a>==</a>
--   <a>root</a> y</tt>.</li>
--   <li><i>Post</i></li>
--   </ul>
--   
--   <ol>
--   <li><tt>zs</tt> is <a>valid</a>.</li>
--   <li>For all <tt>(i,j)</tt> in <tt>(<b>i</b>,<b>j</b>)</tt>
--   holds:<ol><li>If exists a <tt>(x,i,j)</tt> in <tt>xs</tt> but not
--   exists a <tt>(y,i,j)</tt> in <tt>ys</tt> then there exists a
--   <tt>(z,i,j)</tt> in <tt>zs</tt> with <tt>z <a>==</a>
--   x</tt>.</li><li>If exists a <tt>(y,i,j)</tt> in <tt>ys</tt> but not
--   exists a <tt>(x,i,j)</tt> in <tt>xs</tt> then there exists a
--   <tt>(z,i,j)</tt> in <tt>zs</tt> with <tt>z <a>==</a>
--   y</tt>.</li><li>If exists a <tt>(x,i,j)</tt> in <tt>xs</tt> and
--   <tt>(y,i,j)</tt> in <tt>ys</tt> then there exists a <tt>(z,i,j)</tt>
--   in <tt>zs</tt> with <tt>z <a>==</a> x <a>+</a> y</tt>.</li></ol></li>
--   </ol>
etsAdd :: (Additive x, Ord i, Ord j) => Entries i j x -> Entries i j x -> Entries i j x

-- | multiplication.
etsMlt :: (Distributive x, Ord k) => Col i (Row k x) -> Row j (Col k x) -> Col i (Row j x)

-- | joining entries of entries.
--   
--   <b>Property</b> Let <tt>xs' = <a>etsJoin</a> r c xs</tt>
--   
--   <ul>
--   <li><i>Pre</i> For all <tt>(xij,i,j)</tt> in <tt>xs</tt>
--   holds:<ol><li><tt>i <a>&lt;</a> <a>lengthN</a> r</tt> and <tt>j
--   <a>&lt;</a> <a>lengthN</a> c</tt></li><li>For all <tt>(_,i',j')</tt>
--   in <tt>xij</tt> holds: <tt>i' <a>&lt;</a> ri</tt> and <tt>j'
--   <a>&lt;</a> cj</tt> where <tt>..ri.. = r</tt>, <tt>..cj.. =
--   c</tt>.</li></ol></li>
--   <li><i>Post</i> <tt>xs'</tt> is <a>valid</a>.</li>
--   </ul>
etsJoin :: (i ~ N, j ~ N) => ProductSymbol i -> ProductSymbol j -> Entries i j (Entries i j x) -> Entries i j x

-- | the underlying column of rows.
etscr :: Eq i => Entries i j x -> Col i (Row j x)

-- | the underlying row of columns.
etsrc :: (Ord i, Ord j) => Entries i j x -> Row j (Col i x)

-- | the entries given by a column of rows.
crets :: Col i (Row j x) -> Entries i j x

-- | the entries given by a row of columns.
rcets :: (Ord i, Ord j) => Row j (Col i x) -> Entries i j x

-- | elimination of <a>zero</a>s.
etsElimZeros :: Additive x => Entries i j x -> Entries i j x

-- | viewing a partial sequence as a row.
newtype Row j x
Row :: PSequence j x -> Row j x

-- | underlying list of indexed entries.
rowxs :: Row j x -> [(x, j)]

-- | the empty row.
rowEmpty :: Row j x

-- | check for being empty.
rowIsEmpty :: Row j x -> Bool

-- | head.
rowHead :: Row j x -> (x, j)

-- | tail.
rowTail :: Row j x -> Row j x

-- | filtering a row by the given predicate.
rowFilter :: (x -> Bool) -> Row j x -> Row j x

-- | mapping and shifting of a row.
rowMapShift :: Number j => j -> ((x, j) -> y) -> Row j x -> Row j y

-- | appending a row.
--   
--   <b>Property</b> Let <tt>zs = <a>rowAppend</a> xs ys</tt> where
--   <tt>..(x,l) = xs</tt> and <tt>(y,f).. = ys</tt> then holds:
--   
--   <ul>
--   <li><i>If</i> <tt>l <a>&lt;</a> f</tt></li>
--   <li><i>Then</i> <tt>zs</tt> is <a>valid</a>.</li>
--   </ul>
rowAppend :: Row j x -> Row j x -> Row j x

-- | interlacing two rows.
rowInterlace :: Ord j => (x -> y -> z) -> (x -> z) -> (y -> z) -> Row j x -> Row j y -> Row j z

-- | elimination of <a>zero</a>s.
rowElimZeros :: Additive a => Row i a -> Row i a

-- | swapping two entries of a row.
--   
--   <b>Pre</b> <tt>k &lt; l</tt>.
rowSwap :: Ord j => j -> j -> Row j x -> Row j x

-- | adding two rows.
rowAdd :: (Additive a, Ord j) => Row j a -> Row j a -> Row j a

-- | multiplies each element of the row by the given factor from the left.
rowMltl :: Distributive a => a -> Row j a -> Row j a

-- | shears two entries of a row.
--   
--   <b>Property</b> Let <tt>r' = <a>rowShear</a> (&lt;*) (+) k l s t u v
--   r</tt>, then holds:
--   
--   <ul>
--   <li><i>Pre</i> <tt>k <a>&lt;</a> l</tt>.</li>
--   </ul>
--   
--   <b>Note</b> <a>rowShear</a> is like <i>multiplying</i> the given row
--   from the right with the matrix given by <tt>k l s t u v</tt>.
rowShear :: Ord j => (Maybe x -> s -> Maybe x) -> (Maybe x -> Maybe x -> Maybe x) -> j -> j -> s -> s -> s -> s -> Row j x -> Row j x

-- | scales the entry at the given position by the given factor.
rowScale :: Ord j => (x -> s -> Maybe x) -> j -> s -> Row j x -> Row j x

-- | viewing a partial sequence as a column.
newtype Col i x
Col :: PSequence i x -> Col i x

-- | underlying list of indexed entries.
colxs :: Col i x -> [(x, i)]

-- | the empty column.
colEmpty :: Col i x

-- | check for being empty.
colIsEmpty :: Col i x -> Bool

-- | head.
colHead :: Col i x -> (x, i)

-- | tail.
colTail :: Col i x -> Col i x

-- | filtering a column by the given predicate.
colFilter :: (x -> Bool) -> Col i x -> Col i x

-- | mapping and shifting of a column.
colMapShift :: Number i => i -> ((x, i) -> y) -> Col i x -> Col i y

-- | appending a column..
--   
--   <b>Property</b> Let <tt>zs = <a>colAppend</a> xs ys</tt> where
--   <tt>..(x,l) = xs</tt> and <tt>(y,f).. = ys</tt> then holds:
--   
--   <ul>
--   <li><i>If</i> <tt>l <a>&lt;</a> f</tt></li>
--   <li><i>Then</i> <tt>zs</tt> is <a>valid</a>.</li>
--   </ul>
colAppend :: Col i x -> Col i x -> Col i x

-- | interlacing two columns.
colInterlace :: Ord i => (x -> y -> z) -> (x -> z) -> (y -> z) -> Col i x -> Col i y -> Col i z

-- | elimination of <a>zero</a>s.
colElimZeros :: Additive a => Col i a -> Col i a

-- | swapping two entries of a column.
--   
--   <b>Pre</b> <tt>k &lt; l</tt>.
colSwap :: Ord i => i -> i -> Col i x -> Col i x

-- | adding two columns.
colAdd :: (Additive a, Ord i) => Col i a -> Col i a -> Col i a

-- | multiplies each element of the column by the given factor from the
--   right.
colMltr :: Distributive a => Col i a -> a -> Col i a

-- | shears two entries of a column.
--   
--   <b>Property</b> Let <tt>c' = <a>colShear</a> (&lt;*) (+) k l s t u v
--   c</tt>, then holds:
--   
--   <ul>
--   <li><i>Pre</i> <tt>k <a>&lt;</a> l</tt>.</li>
--   </ul>
--   
--   <b>Note</b> <a>colShear</a> is like <i>multiplying</i> the given
--   column from the left with the matrix given by <tt>k l s t u v</tt>.
colShear :: Ord i => (s -> Maybe x -> Maybe x) -> (Maybe x -> Maybe x -> Maybe x) -> i -> i -> s -> s -> s -> s -> Col i x -> Col i x

-- | scales the entry at the given position by the given factor.
colScale :: Ord i => (s -> x -> Maybe x) -> i -> s -> Col i x -> Col i x

-- | get the head column at <tt>j</tt>.
--   
--   <b>Pre</b> for all <tt>j'</tt> in <tt>rws</tt> holds: <tt>j
--   <a>&lt;=</a> j'</tt>.
crHeadColAt :: Eq j => j -> Col i (Row j a) -> Col i a

-- | get the head row at <tt>i</tt>.
--   
--   <b>Pre</b> for all <tt>i'</tt> in <tt>rws</tt> holdst: <tt>i
--   <a>&lt;=</a> i'</tt>.
crHeadRowAt :: Eq i => i -> Col i (Row j a) -> Row j a

-- | to the dual of <a>Entries</a>, with inverse <a>coEntriesInv</a>.
coEntries :: (Ord i, Ord j) => Entries i j x -> Dual (Entries i j x)

-- | from the dual of <a>Entries</a>, with inverse <a>coEntries</a>.
coEntriesInv :: (Ord i, Ord j) => Dual (Entries i j x) -> Entries i j x
instance OAlg.Data.Number.LengthN (OAlg.Entity.Matrix.Entries.Row j x)
instance GHC.Base.Functor (OAlg.Entity.Matrix.Entries.Row j)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity j, GHC.Classes.Ord j) => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Entries.Row j x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity j, GHC.Classes.Ord j) => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Entries.Row j x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq j) => GHC.Classes.Eq (OAlg.Entity.Matrix.Entries.Row j x)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Matrix.Entries.Col i x)
instance GHC.Base.Functor (OAlg.Entity.Matrix.Entries.Col i)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Entries.Col i x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Entries.Col i x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq i) => GHC.Classes.Eq (OAlg.Entity.Matrix.Entries.Col i x)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Matrix.Entries.Entries i j x)
instance GHC.Base.Functor (OAlg.Entity.Matrix.Entries.Entries i j)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, OAlg.Entity.Definition.Entity j, GHC.Classes.Ord i, GHC.Classes.Ord j) => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Entries.Entries i j x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, OAlg.Entity.Definition.Entity j, GHC.Classes.Ord i, GHC.Classes.Ord j) => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Entries.Entries i j x)
instance (GHC.Classes.Ord x, GHC.Classes.Ord i, GHC.Classes.Ord j) => GHC.Classes.Ord (OAlg.Entity.Matrix.Entries.Entries i j x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq i, GHC.Classes.Eq j) => GHC.Classes.Eq (OAlg.Entity.Matrix.Entries.Entries i j x)
instance (GHC.Show.Show x, GHC.Show.Show i, GHC.Show.Show j) => GHC.Show.Show (OAlg.Entity.Matrix.Entries.Entries i j x)
instance (OAlg.Data.Dualisable.Transposable x, GHC.Classes.Ord n) => OAlg.Data.Dualisable.Transposable (OAlg.Entity.Matrix.Entries.Entries n n x)
instance (GHC.Show.Show x, GHC.Show.Show i) => GHC.Show.Show (OAlg.Entity.Matrix.Entries.Col i x)
instance GHC.Classes.Ord i => OAlg.Entity.Sequence.Definition.Sequence (OAlg.Entity.Matrix.Entries.Col i) i x
instance GHC.Classes.Ord i => OAlg.Structure.Operational.Opr (OAlg.Entity.Sequence.Permutation.Permutation i) (OAlg.Entity.Matrix.Entries.Col i x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Structure.Operational.TotalOpr (OAlg.Entity.Sequence.Permutation.Permutation i) (OAlg.Entity.Matrix.Entries.Col i x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity i, GHC.Classes.Ord i) => OAlg.Entity.Sequence.Permutation.PermutableSequence (OAlg.Entity.Matrix.Entries.Col i) i x
instance (GHC.Show.Show x, GHC.Show.Show j) => GHC.Show.Show (OAlg.Entity.Matrix.Entries.Row j x)
instance GHC.Classes.Ord j => OAlg.Entity.Sequence.Definition.Sequence (OAlg.Entity.Matrix.Entries.Row j) j x
instance GHC.Classes.Ord j => OAlg.Structure.Operational.Opr (OAlg.Entity.Sequence.Permutation.Permutation j) (OAlg.Entity.Matrix.Entries.Row j x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity j, GHC.Classes.Ord j) => OAlg.Structure.Operational.TotalOpr (OAlg.Entity.Sequence.Permutation.Permutation j) (OAlg.Entity.Matrix.Entries.Row j x)
instance (OAlg.Entity.Definition.Entity x, OAlg.Entity.Definition.Entity j, GHC.Classes.Ord j) => OAlg.Entity.Sequence.Permutation.PermutableSequence (OAlg.Entity.Matrix.Entries.Row j) j x


-- | dimension for matrices of <tt><b>x</b></tt> as a complete sequence of
--   <tt><a>Point</a> <b>x</b></tt>.
module OAlg.Entity.Matrix.Dim

-- | dimension of <tt><b>x</b></tt> as a complete sequence of
--   <tt><a>Point</a> <b>x</b></tt>.
data Dim x p
[Dim] :: CSequence (Point x) -> Dim x (Point x)

-- | abbreviation for <tt><a>Dim</a> <b>x</b> (<a>Point</a> <b>x</b>)</tt>.
type Dim' x = Dim x (Point x)

-- | the underlying product.
fromDim :: Dim x p -> ProductSymbol p

-- | constructing a dimension form a point.
dim :: (Entity p, p ~ Point x) => p -> Dim x p

-- | constructing a dimension from a list of points.
productDim :: (Entity p, p ~ Point x) => [p] -> Dim x p

-- | the indexed listing of the points.
dimxs :: p ~ Point x => Dim x p -> [(p, N)]

-- | the underlying word.
dimwrd :: (Entity p, p ~ Point x) => Dim x p -> Word N p

-- | mapping a dimension.
dimMap :: (Entity q, q ~ Point y) => (p -> q) -> Dim x p -> Dim y q
instance OAlg.Structure.Oriented.Definition.Oriented x => GHC.Classes.Eq (OAlg.Entity.Matrix.Dim.Dim x p)
instance (OAlg.Structure.Oriented.Definition.Oriented x, OAlg.Structure.Oriented.Definition.OrdPoint x) => GHC.Classes.Ord (OAlg.Entity.Matrix.Dim.Dim x p)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Matrix.Dim.Dim x p)
instance OAlg.Structure.Oriented.Definition.Oriented x => GHC.Show.Show (OAlg.Entity.Matrix.Dim.Dim x p)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Dim.Dim x p)
instance (OAlg.Structure.Oriented.Definition.Oriented x, Data.Typeable.Internal.Typeable p) => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Dim.Dim x p)
instance OAlg.Entity.Sequence.Definition.Sequence (OAlg.Entity.Matrix.Dim.Dim x) OAlg.Data.Number.N p
instance OAlg.Entity.Definition.Entity p => OAlg.Structure.Operational.Opr (OAlg.Entity.Sequence.Permutation.Permutation OAlg.Data.Number.N) (OAlg.Entity.Matrix.Dim.Dim x p)
instance (OAlg.Structure.Oriented.Definition.Oriented x, OAlg.Entity.Definition.Entity p) => OAlg.Structure.Operational.TotalOpr (OAlg.Entity.Sequence.Permutation.Permutation OAlg.Data.Number.N) (OAlg.Entity.Matrix.Dim.Dim x p)
instance (OAlg.Structure.Oriented.Definition.Oriented x, OAlg.Entity.Definition.Entity p) => OAlg.Entity.Sequence.Permutation.PermutableSequence (OAlg.Entity.Matrix.Dim.Dim x) OAlg.Data.Number.N p
instance (OAlg.Structure.Oriented.Definition.Oriented x, Data.Typeable.Internal.Typeable p) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Matrix.Dim.Dim x p)
instance (OAlg.Structure.Oriented.Definition.Oriented x, Data.Typeable.Internal.Typeable p, p GHC.Types.~ OAlg.Structure.Oriented.Definition.Point x) => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Matrix.Dim.Dim x p)
instance OAlg.Structure.Oriented.Definition.Total (OAlg.Entity.Matrix.Dim.Dim x p)
instance (OAlg.Structure.Oriented.Definition.Oriented x, Data.Typeable.Internal.Typeable p, p GHC.Types.~ OAlg.Structure.Oriented.Definition.Point x) => OAlg.Structure.Exponential.Exponential (OAlg.Entity.Matrix.Dim.Dim x p)
instance (OAlg.Structure.Oriented.Definition.Oriented x, () GHC.Types.~ OAlg.Structure.Oriented.Definition.Point x) => OAlg.Data.Validable.XStandard (OAlg.Entity.Matrix.Dim.Dim x ())


-- | definition of adjunctions between <a>Multiplicative</a> structures. We
--   relay on the terms and notation as used in <a>nLab</a>
module OAlg.Adjunction.Definition

-- | adjunction between two multiplicative structures <tt><b>d</b></tt> and
--   <tt><b>c</b></tt> according two given multiplicative homomorphisms
--   <tt>l :: <b>h</b> <b>c</b> <b>d</b></tt> and <tt>r :: <b>h</b>
--   <b>d</b> <b>c</b></tt>.
--   
--   <pre>
--         l
--     &lt;------- 
--   d          c
--     --------&gt;
--         r
--   </pre>
--   
--   <b>Property</b> Let <tt><a>Adjunction</a> l r u v</tt> be in
--   <tt><a>Adjunction</a> <b>h</b> <b>d</b> <b>c</b></tt> where
--   <tt><b>h</b></tt> is a <a>Mlt</a>-homomorphism, then holds:
--   
--   <ol>
--   <li>Naturality of the right unit <tt>u</tt>:<ol><li>For all <tt>x</tt>
--   in <tt><a>Point</a> <b>c</b></tt> holds: <tt><a>orientation</a> (u x)
--   <a>==</a> x <a>:&gt;</a> <a>pmap</a> r (<a>pmap</a> l
--   x)</tt>.</li><li>For all <tt>f</tt> in <tt><b>c</b></tt> holds: <tt>u
--   (<a>end</a> f) <a>*</a> f <a>==</a> <a>amap</a> r (<a>amap</a> l) f
--   <a>*</a> u (<a>start</a> f)</tt>.</li></ol></li>
--   <li>Naturality of the left unit <tt>v</tt>:<ol><li>For all <tt>y</tt>
--   in <tt><a>Point</a> <b>d</b></tt> holds: <tt><a>orientation</a> (v y)
--   <a>==</a> <a>pmap</a> l (<a>pmap</a> r y) <a>:&gt;</a>
--   y</tt>.</li><li>For all <tt>g</tt> in <tt><b>d</b></tt> holds: <tt>g
--   <a>*</a> v (<a>start</a> g) <a>==</a> v (<a>end</a> g) <a>*</a>
--   <a>amap</a> l (<a>amap</a> r) g</tt>.</li></ol></li>
--   <li>Triangle identities:<ol><li>For all <tt>x</tt> in <tt><a>Point</a>
--   <b>c</b></tt> holds: <tt><a>one</a> (<a>pmap</a> l x) == v
--   (<a>pmap</a> l x) <a>*</a> <a>amap</a> l (u x)</tt>.</li><li>For all
--   <tt>y</tt> in <tt><a>Point</a> <b>d</b></tt> holds: <tt><a>one</a>
--   (<a>pmap</a> r y) == <a>amap</a> r (v y) <a>*</a> u (<a>pmap</a> r
--   y)</tt>.</li></ol></li>
--   </ol>
--   
--   The following diagrams illustrate the above equations
--   
--   naturality of the right unit <tt>u</tt> (Equations 1.1 and 1.2):
--   
--   <pre>
--         u a
--     a -------&gt; pmap r (pmap l a)         
--     |                |
--   f |                | amap r (amap l f)
--     v                v
--     b -------&gt; pmap r (pmap l b)
--         u b
--   </pre>
--   
--   naturality of the left unit <tt>v</tt> (Equations 2.1 and 2.2):
--   
--   <pre>
--          v a
--     a &lt;------- pmap l (pmap r a)
--     |                |
--   g |                | amap l (ampa r g)
--     v                v
--     b &lt;------ pmap l (pmap r b)
--          v b
--   </pre>
--   
--   the left adjoint of the right unit <tt>u</tt> is <a>one</a> (Equation
--   3.1, see <a>adjl</a>):
--   
--   <pre>
--                                   pmap l x         x
--                                  /   |             |
--                                 /    |             |
--                                /     |             |
--                  amap l (u x) /      | one  ~  u x |    
--                              /       |             |
--                             /        |             |
--                            v         v             v
--   pmap l (pmap r (pmap l x)) ---&gt; pmap l x    pmap r (pmap l x)
--                          v (pmap l x)
--   </pre>
--   
--   the right adjoint of the left unit <tt>v</tt> is <a>one</a> (Equation
--   3.2, see <a>adjr</a>):
--   
--   <pre>
--                              u (pmap r y)
--   pmap l (pmap r y)     pmap r y ---&gt; pmap r (pmap l (pmap r y))
--         |                  |         /
--         |                  |        /
--         | v y    ~     one |       / amap r (v y)
--         |                  |      /
--         |                  |     /
--         v                  v    v
--         y               pmap r y
--   </pre>
data Adjunction h d c
[Adjunction] :: h c d -> h d c -> (Point c -> c) -> (Point d -> d) -> Adjunction h d c

-- | the unit on the right side.
unitr :: Adjunction h d c -> Point c -> c

-- | the unit on the left side.
unitl :: Adjunction h d c -> Point d -> d

-- | the left adjoint <tt>f'</tt> of a factor <tt>f</tt> in
--   <tt><b>c</b></tt>.
--   
--   <b>Property</b> Let <tt>y</tt> be in <tt><b>d</b></tt> and <tt>f</tt>
--   in <tt><b>c</b></tt> with <tt><a>end</a> f <a>==</a> <a>pmap</a> r
--   y</tt> then the left adjoint <tt>f'</tt> of <tt>f</tt> is given by
--   <tt>f' = v y <a>*</a> <a>amap</a> l f</tt>.
--   
--   <pre>
--                       pmap l x           x
--                        /   |             |
--                       /    |             |
--                      /     |             |
--            amap l f /      | f'   ~    f |
--                    /       |             |
--                   /        |             |
--                  v         v             v
--   pmap l (pmap r y) -----&gt; y          pmap r y
--                       v y
--   </pre>
adjl :: Hom Mlt h => Adjunction h d c -> Point d -> c -> d

-- | the right adjoint <tt>g'</tt> of a factor in <tt>g</tt> in
--   <tt><b>d</b></tt>
--   
--   <b>Property</b> Let <tt>x</tt> be in <tt><b>c</b></tt> and <tt>g</tt>
--   in <tt><b>d</b></tt> with <tt><a>start</a> g <a>==</a> <a>pmap</a> l
--   x</tt> then the right adjoint <tt>g'</tt> of <tt>g</tt> is given by
--   <tt>g' = <a>amap</a> r g <a>*</a> u x</tt>.
--   
--   <pre>
--                         u x
--   pmap l x           x -----&gt; pmap r (pmap l x)
--      |               |       /
--      |               |      /
--      |               |     /
--      | g     ~    g' |    / amap r g
--      |               |   /
--      |               |  /
--      v               v v
--      y            pmap r y
--   </pre>
adjr :: Hom Mlt h => Adjunction h d c -> Point c -> d -> c

-- | attest of being <a>Multiplicative</a> homomorphous.
adjHomMlt :: Hom Mlt h => Adjunction h d c -> Homomorphous Mlt d c

-- | the dual adjunction.
coAdjunction :: Hom Mlt h => Adjunction h d c -> Dual (Adjunction h d c)

-- | validity of an adjunction according to the properties of
--   <a>Adjunction</a>.
prpAdjunction :: Hom Mlt h => Adjunction h d c -> X (Point d) -> X d -> X (Point c) -> X c -> Statement

-- | validity of the unit on the right side.
prpAdjunctionRight :: Hom Mlt h => Adjunction h d c -> Point c -> c -> Statement

-- | validity of the unit on the left side.
prpAdjunctionLeft :: Hom Mlt h => Adjunction h d c -> Point d -> d -> Statement
instance (OAlg.Hom.Multiplicative.Definition.HomMultiplicative h, OAlg.Structure.Oriented.Definition.XStandardPoint d, OAlg.Data.Validable.XStandard d, OAlg.Structure.Oriented.Definition.XStandardPoint c, OAlg.Data.Validable.XStandard c) => OAlg.Data.Validable.Validable (OAlg.Adjunction.Definition.Adjunction h d c)


-- | definition of free <a>Sum</a>s over <a>Fibred</a> symbols.
module OAlg.Entity.Sum.Definition

-- | free sum over <a>Fibred</a> symbols in <tt><b>a</b></tt> with scalars
--   in <tt><b>r</b></tt>.
--   
--   <b>Definition</b> A <a>Sum</a> <tt>s</tt> is <a>valid</a> if and only
--   if its underlying <a>SumForm</a> <tt>s'</tt> is <a>valid</a> and
--   <tt>s'</tt> is reduced, i.e. <tt>s' <a>==</a> <a>reduce</a> s'</tt>.
data Sum r a

-- | the associated linear combination.
--   
--   <b>Note</b> The associated linear combination of a sum is sorted
--   according to the second component!
smlc :: Semiring r => Sum r a -> LinearCombination r a

-- | joining a sum of sums.
smJoin :: (Semiring r, Commutative r, Fibred a, Ord a) => Sum r (Sum r a) -> Sum r a

-- | additive homomorphism for sums over <a>N</a>.
nSum :: (Hom Fbr h, Additive x) => h a x -> Sum N a -> x

-- | additive homomorphism for sums over <a>Z</a>.
zSum :: (Hom Fbr h, Abelian x) => h a x -> Sum Z a -> x

-- | additive homomorphism to a totally defined sum.
smMap :: (Singleton (Root y), Fibred y, Ord y, Semiring r, Commutative r) => (x -> y) -> Sum r x -> Sum r y

-- | form for a free sum over <a>Fibred</a> symbols in <tt><b>a</b></tt>
--   with scalars in <tt><b>r</b></tt>.
--   
--   <b>Definition</b> Let <tt><b>r</b></tt> be a <a>Commutative</a>
--   <a>Semiring</a> and <tt><b>a</b></tt> a <a>Fibred</a> structure. A
--   <a>SumForm</a> <tt>a</tt> is <a>valid</a> if and only if all scalars
--   in <tt>a</tt> are <a>valid</a> and all symbols in <tt><b>a</b></tt>
--   are <a>valid</a> and have the same <tt><a>root</a></tt>.
data SumForm r a
Zero :: Root a -> SumForm r a
S :: a -> SumForm r a
(:!) :: r -> SumForm r a -> SumForm r a
(:+) :: SumForm r a -> SumForm r a -> SumForm r a
infixr 6 :+
infixr 9 :!

-- | the length of a sum form,
smfLength :: Number r => SumForm r a -> N

-- | transforming a sum form to its corresponding linear combination..
smflc :: Semiring r => SumForm r a -> LinearCombination r a

-- | transforming a word to its corresponding sum form.
lcsmf :: Semiring r => Root a -> LinearCombination r a -> SumForm r a

-- | mapping of sum forms.
smfMap :: Singleton (Root y) => (x -> y) -> SumForm r x -> SumForm r y

-- | joining a sum form of sum forms.
smfJoin :: SumForm r (SumForm r a) -> SumForm r a

-- | reducing a sum form to its canonical form,
smfReduce :: (Fibred a, Ord a, Semiring r, Commutative r) => SumForm r a -> SumForm r a

-- | list of symbols in <tt><b>a</b></tt> together with a scalar in
--   <tt><b>r</b></tt>.
--   
--   <b>Note</b> <a>valid</a> linear combinations must not be sorted
--   according to the second component!
newtype LinearCombination r a
LinearCombination :: [(r, a)] -> LinearCombination r a

-- | the underlying list of symbols with their scalar.
lcs :: LinearCombination r a -> [(r, a)]

-- | aggregating linear combinations with same symbols.
lcAggr :: (Eq a, Semiring r) => LinearCombination r a -> LinearCombination r a

-- | sorting a linear combination according to its symbols.
lcSort :: Ord a => LinearCombination r a -> LinearCombination r a

-- | filtering a word according to the scalars.
lcSclFilter :: (r -> Bool) -> LinearCombination r a -> LinearCombination r a
instance (OAlg.Data.Validable.Validable r, OAlg.Data.Validable.Validable a) => OAlg.Data.Validable.Validable (OAlg.Entity.Sum.Definition.LinearCombination r a)
instance (GHC.Classes.Eq r, GHC.Classes.Eq a) => GHC.Classes.Eq (OAlg.Entity.Sum.Definition.LinearCombination r a)
instance (GHC.Show.Show r, GHC.Show.Show a) => GHC.Show.Show (OAlg.Entity.Sum.Definition.LinearCombination r a)
instance (OAlg.Structure.Distributive.Definition.Distributive r, OAlg.Structure.Oriented.Definition.Total r, OAlg.Structure.Multiplicative.Definition.Commutative r, OAlg.Structure.Fibred.Definition.Fibred a) => OAlg.Data.Validable.Validable (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Structure.Fibred.Definition.OrdRoot a, GHC.Classes.Ord r, GHC.Classes.Ord a, OAlg.Entity.Definition.Entity r) => GHC.Classes.Ord (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Entity.Definition.Entity r) => GHC.Classes.Eq (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Entity.Definition.Entity r) => GHC.Show.Show (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Entity.Definition.Entity r) => GHC.Show.Show (OAlg.Entity.Sum.Definition.SumForm r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Entity.Definition.Entity r) => GHC.Classes.Eq (OAlg.Entity.Sum.Definition.SumForm r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Entity.Definition.Entity r, OAlg.Structure.Fibred.Definition.OrdRoot a, GHC.Classes.Ord r, GHC.Classes.Ord a) => GHC.Classes.Ord (OAlg.Entity.Sum.Definition.SumForm r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Entity.Definition.Entity (OAlg.Entity.Sum.Definition.Sum r a)
instance OAlg.Data.Constructable.Exposable (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, GHC.Classes.Ord a, OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Data.Constructable.Constructable (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, GHC.Classes.Ord a, OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Structure.Additive.Definition.Additive (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, GHC.Classes.Ord a, OAlg.Structure.Ring.Definition.Ring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Structure.Additive.Definition.Abelian (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, GHC.Classes.Ord a, OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Structure.Vectorial.Definition.Vectorial (OAlg.Entity.Sum.Definition.Sum r a)
instance (OAlg.Entity.Definition.Entity a, OAlg.Entity.Definition.Entity r) => OAlg.Entity.Definition.Entity (OAlg.Entity.Sum.Definition.LinearCombination r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Data.Validable.Validable (OAlg.Entity.Sum.Definition.SumForm r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Entity.Definition.Entity (OAlg.Entity.Sum.Definition.SumForm r a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Entity.Sum.Definition.SumForm r a)
instance Data.Foldable.Foldable (OAlg.Entity.Sum.Definition.SumForm OAlg.Data.Number.N)
instance OAlg.Data.Number.LengthN (OAlg.Entity.Sum.Definition.SumForm OAlg.Data.Number.N a)
instance (OAlg.Structure.Fibred.Definition.Fibred a, GHC.Classes.Ord a, OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Data.Reducible.Reducible (OAlg.Entity.Sum.Definition.SumForm r a)


-- | free sums with symbols in <tt><b>a</b></tt>.
module OAlg.Entity.Sum.SumSymbol

-- | free sum with symbols in <tt><b>a</b></tt>.
newtype SumSymbol r a
SumSymbol :: Sum r (R a) -> SumSymbol r a

-- | the underlying partial sequence.
ssypsq :: Semiring r => SumSymbol r a -> PSequence a r

-- | the underlying linear combination.
ssylc :: Semiring r => SumSymbol r a -> LinearCombination r a

-- | the induced free sum given by a list of scalars and symbols.
sumSymbol :: (Semiring r, Commutative r, Entity a, Ord a) => [(r, a)] -> SumSymbol r a

-- | the induced free sum given by the symbol.
sy :: (Semiring r, Commutative r, Entity a, Ord a) => a -> SumSymbol r a

-- | mapping of free sums
ssyMap :: (Semiring r, Commutative r, Entity y, Ord y) => (x -> y) -> SumSymbol r x -> SumSymbol r y

-- | additive homomorphism given by a mapping of a symbol in
--   <tt><b>x</b></tt> to a linear combination of <tt><b>y</b></tt>.
ssySum :: (Semiring r, Commutative r, Entity y, Ord y) => (x -> LinearCombination r y) -> SumSymbol r x -> SumSymbol r y

-- | joining a free sum of free sums to a free sum.
ssyJoin :: (Semiring r, Commutative r, Entity x, Ord x) => SumSymbol r (SumSymbol r x) -> SumSymbol r x

-- | the projectin of a free sum according to the given set of symbols.
--   
--   <b>Definition</b> Let <tt>x</tt> be in <tt><a>SumSymbol</a> <b>r</b>
--   <b>a</b></tt> and <tt>s</tt> a <a>Set</a> of symbols in
--   <tt><b>a</b></tt>, then <tt>x</tt> is called <b><i>representable
--   according to</i></b> <tt>s</tt> iff all symbols of <tt><a>ssylc</a>
--   x</tt> are elements of <tt>s</tt>.
--   
--   <b>Property</b> Let <tt>s</tt> be a set of symbols in
--   <tt><b>a</b></tt> and <tt>x</tt> be representable in
--   <tt><a>SumSymbol</a> <b>r</b> <b>a</b></tt> according to <tt>s</tt>,
--   then <tt><a>ssyprj</a> x <a>==</a> x</tt>.
--   
--   <b>Examples</b>
--   
--   <pre>
--   &gt;&gt;&gt; ssyprj (Set [A,D,E]) (3!sy D) :: SumSymbol Z Symbol
--   SumSymbol[3!D]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssyprj (Set [A,D,E]) (2!sy B) :: SumSymbol Z Symbol
--   SumSymbol[]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssyprj (Set [A,D,E]) (3!sy D + sy A - 5!sy E) :: SumSymbol Z Symbol
--   SumSymbol[A+3!D+-5!E]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ssyprj (Set [A,D,E]) (2!sy D + 7!sy B - sy E + sy F) :: SumSymbol Z Symbol
--   SumSymbol[2!D+-1!E]
--   </pre>
ssyprj :: (Semiring r, Commutative r, Ord a, Entity a) => Set a -> SumSymbol r a -> SumSymbol r a

-- | adjoining the root <tt>()</tt>.
newtype R a
R :: a -> R a
instance OAlg.Data.Validable.Validable a => OAlg.Data.Validable.Validable (OAlg.Entity.Sum.SumSymbol.R a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (OAlg.Entity.Sum.SumSymbol.R a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (OAlg.Entity.Sum.SumSymbol.R a)
instance GHC.Show.Show a => GHC.Show.Show (OAlg.Entity.Sum.SumSymbol.R a)
instance (OAlg.Structure.Distributive.Definition.Distributive r, OAlg.Structure.Oriented.Definition.Total r, OAlg.Structure.Multiplicative.Definition.Commutative r, GHC.Classes.Ord a, OAlg.Structure.Additive.Definition.Abelian r, OAlg.Entity.Definition.Entity a) => OAlg.Structure.Additive.Definition.Abelian (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance (OAlg.Structure.Distributive.Definition.Distributive r, OAlg.Structure.Oriented.Definition.Total r, OAlg.Structure.Multiplicative.Definition.Commutative r, GHC.Classes.Ord a, OAlg.Entity.Definition.Entity a) => OAlg.Structure.Additive.Definition.Additive (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance (OAlg.Structure.Distributive.Definition.Distributive r, OAlg.Structure.Oriented.Definition.Total r, OAlg.Structure.Multiplicative.Definition.Commutative r, OAlg.Entity.Definition.Entity a) => OAlg.Data.Validable.Validable (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance (OAlg.Entity.Definition.Entity a, OAlg.Entity.Definition.Entity r, GHC.Classes.Ord r, GHC.Classes.Ord a) => GHC.Classes.Ord (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance (OAlg.Entity.Definition.Entity a, OAlg.Entity.Definition.Entity r) => GHC.Classes.Eq (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance (OAlg.Structure.Ring.Definition.Semiring r, GHC.Show.Show a) => GHC.Show.Show (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r, OAlg.Entity.Definition.Entity a) => OAlg.Entity.Definition.Entity (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r, OAlg.Entity.Definition.Entity a) => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r, OAlg.Entity.Definition.Entity a, GHC.Classes.Ord a) => OAlg.Structure.Vectorial.Definition.Vectorial (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r, OAlg.Entity.Definition.Entity a, GHC.Classes.Ord a) => OAlg.Structure.Vectorial.Definition.Euclidean (OAlg.Entity.Sum.SumSymbol.SumSymbol r a)
instance OAlg.Entity.Definition.Entity a => OAlg.Entity.Definition.Entity (OAlg.Entity.Sum.SumSymbol.R a)
instance OAlg.Entity.Definition.Entity a => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Entity.Sum.SumSymbol.R a)
instance OAlg.Structure.Fibred.Definition.OrdRoot (OAlg.Entity.Sum.SumSymbol.R a)


-- | free sums.
module OAlg.Entity.Sum


-- | defintion of matrices over <a>Distributive</a> structures.
module OAlg.Entity.Matrix.Definition

-- | matrix over <a>Distributive</a> structures.
--   
--   <b>Property</b> Let <tt><a>Matrix</a> rw cl xijs</tt> be in
--   <tt><a>Matrix</a> <b>a</b></tt> for a <a>Distributive</a> structure
--   <b><tt>a</tt></b>, then holds:
--   
--   <ol>
--   <li><tt>rw</tt> and <tt>cl</tt> are <a>valid</a>.</li>
--   <li><tt>xijs</tt> is <a>valid</a>.</li>
--   <li>For all <tt>(x,i,j)</tt> in <tt>xijs</tt> holds:<ol><li><tt>x</tt>
--   is not <a>zero</a>.</li><li><tt><a>orientation</a> x <a>==</a> (cl
--   <a>?</a> j) <a>:&gt;</a> (rw <a>?</a> i)</tt>.</li></ol></li>
--   </ol>
data Matrix x
Matrix :: Dim' x -> Dim' x -> Entries N N x -> Matrix x

-- | row dimension.
rows :: Matrix x -> Dim' x

-- | column dimension.
cols :: Matrix x -> Dim' x

-- | the entries.
mtxxs :: Matrix x -> Entries N N x

-- | viewing as a row of columns.
mtxRowCol :: Matrix x -> Row N (Col N x)

-- | viewing as a column of rows.
mtxColRow :: Matrix x -> Col N (Row N x)

-- | mapping of a matrix.
mtxMap :: Hom Dst h => h x y -> Matrix x -> Matrix y

-- | groups the rows with same row dimensions into a matrix of matrices
--   with one column and n rows accordingly.
mtxGroupRow :: Distributive x => Matrix x -> Matrix (Matrix x)

-- | groups a formal product of points <tt>p 0 <a>^</a> r 0 <a>*</a> ..
--   <a>*</a> p n <a>^</a> r n</tt> into a formal product of dimensions
--   <tt>(<a>dim</a> [p 0] <a>^</a> r o) <a>*</a> .. <a>*</a> (<a>dim</a>
--   [p n] <a>^</a> r n)</tt>.
mtxGroupDim :: Distributive x => Dim' x -> Dim' (Matrix x)

-- | joining block matrices, i.e. matrices of matrices.
mtxJoin :: Oriented x => Matrix (Matrix x) -> Matrix x

-- | joining the dimension of matrices over <tt><b>x</b></tt>.
mtxJoinDim :: Oriented x => Dim' (Matrix x) -> Dim' x

-- | matrix with the given row and column number and the given entries for
--   a <a>Distributive</a> structure.
--   
--   <b>Property</b> Let <tt>m = <a>matrix</a> rw cl xis</tt> then holds
--   
--   <ul>
--   <li><i>Pre</i> For all <tt>(x,i,j)</tt> in <tt>xijs</tt> holds:
--   <tt><a>start</a> x <a>==</a> cl <a>?</a> j</tt> and <tt><a>end</a> x
--   <a>==</a> rw <a>?</a> i</tt>.</li>
--   <li><i>Post</i> <tt>m</tt> is <a>valid</a>.</li>
--   </ul>
--   
--   <b>Note</b> The given entries will be sorted, aggregated and
--   <a>zero</a>s eliminated.
matrix :: (Additive x, p ~ Point x) => Dim x p -> Dim x p -> [(x, N, N)] -> Matrix x

-- | matrix with the given row and column number and the given entries for
--   a <a>Total</a> <a>Distributive</a> structure.
--   
--   <b>Property</b> Let <tt>m = <a>matrixTtl</a> rws cls xis</tt> then
--   holds
--   
--   <ul>
--   <li><i>Pre</i> For all <tt>(_,i,j)</tt> in <tt>xijs</tt> holds: <tt>i
--   <a>&lt;</a> rws</tt> and <tt>j <a>&lt;</a> cls</tt>.</li>
--   <li><i>Post</i> <tt>m</tt> is <a>valid</a>.</li>
--   </ul>
--   
--   <b>Note</b> The given entries will be sorted, aggregated and
--   <a>zero</a>s eliminated.
matrixTtl :: (Additive x, FibredOriented x, Total x) => N -> N -> [(x, N, N)] -> Matrix x

-- | block matrices as matrix of matrices.
matrixBlc :: (Additive x, FibredOriented x) => [Dim' x] -> [Dim' x] -> [(Matrix x, N, N)] -> Matrix (Matrix x)

-- | diagonal matrix with entries starting at the index <tt>0</tt> (see
--   <a>diagonal'</a>).
diagonal :: Additive x => Dim' x -> Dim' x -> [x] -> Matrix x

-- | diagonal matrix with entries starting at the given index offset.
diagonal' :: Additive x => N -> Dim' x -> Dim' x -> [x] -> Matrix x

-- | the dual matrix, with inverse <a>coMatrixInv</a>.
coMatrix :: Entity (Point x) => Matrix x -> Dual (Matrix x)

-- | from the dual matrix, with inverse <a>coMatrix</a>.
coMatrixInv :: Entity (Point x) => Dual (Matrix x) -> Matrix x

-- | from the bidual.
mtxFromOpOp :: Entity (Point x) => Matrix (Op (Op x)) -> Matrix x

-- | the contravariant isomorphism from <tt><a>Matrix</a> <b>x</b></tt> to
--   <tt><a>Matrix</a> (<a>Op</a> <b>x</b>)</tt>.
isoCoMatrixDst :: Distributive x => IsoOpMap Matrix Dst (Op (Matrix x)) (Matrix (Op x))

-- | standard random variable for the orientations of matrices over
--   <tt><b>x</b></tt>.
class XStandardOrientationMatrix x
xStandardOrientationMatrix :: XStandardOrientationMatrix x => X (Orientation (Dim' x))

-- | random variable of matrices with the given maximal dimension and
--   density.
xMatrix :: Additive x => Q -> XOrtOrientation x -> X (Orientation (Point (Matrix x))) -> XOrtOrientation (Matrix x)

-- | random variable of matrices with the given maximal dimension and the
--   given density.
xMatrixTtl :: (Distributive x, Total x) => N -> Q -> X x -> XOrtOrientation (Matrix x)

-- | a random variable of <a>Z</a>-matrices.
xodZ :: XOrtOrientation (Matrix Z)

-- | a random variable of <a>Z</a>-bolck-matrices.
xodZZ :: XOrtOrientation (Matrix (Matrix Z))
instance OAlg.Structure.Oriented.Definition.Oriented x => GHC.Show.Show (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Structure.Oriented.Definition.Oriented x => GHC.Classes.Eq (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Oriented.Definition.Oriented x, GHC.Classes.Ord x, OAlg.Structure.Oriented.Definition.OrdPoint x) => GHC.Classes.Ord (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Entity.Matrix.Definition.XStandardOrientationMatrix OAlg.Data.Number.Z
instance (OAlg.Structure.Additive.Definition.Additive x, OAlg.Structure.Fibred.Definition.FibredOriented x, OAlg.Structure.Oriented.Definition.XStandardOrtOrientation x, OAlg.Entity.Matrix.Definition.XStandardOrientationMatrix x) => OAlg.Structure.Oriented.Definition.XStandardOrtOrientation (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Additive.Definition.Additive x, OAlg.Structure.Fibred.Definition.FibredOriented x) => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Additive.Definition.Additive x, OAlg.Structure.Fibred.Definition.FibredOriented x) => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Additive.Definition.Additive x, OAlg.Structure.Fibred.Definition.FibredOriented x) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Additive.Definition.Additive x, OAlg.Structure.Fibred.Definition.FibredOriented x) => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Additive.Definition.Additive x, OAlg.Structure.Fibred.Definition.FibredOriented x) => OAlg.Structure.Fibred.Definition.FibredOriented (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Additive.Definition.Additive x, OAlg.Structure.Fibred.Definition.FibredOriented x) => OAlg.Structure.Additive.Definition.Additive (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Additive.Definition.Abelian x, OAlg.Structure.Fibred.Definition.FibredOriented x) => OAlg.Structure.Additive.Definition.Abelian (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Vectorial.Definition.Vectorial x, OAlg.Structure.Fibred.Definition.FibredOriented x) => OAlg.Structure.Vectorial.Definition.Vectorial (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Structure.Distributive.Definition.Distributive x => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Structure.Distributive.Definition.Distributive x => OAlg.Structure.Distributive.Definition.Distributive (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Structure.Algebraic.Definition.Algebraic x => OAlg.Structure.Algebraic.Definition.Algebraic (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Distributive.Definition.Distributive x, OAlg.Structure.Distributive.Definition.TransposableDistributive x) => OAlg.Data.Dualisable.Transposable (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Distributive.Definition.Distributive x, OAlg.Structure.Distributive.Definition.TransposableDistributive x) => OAlg.Structure.Oriented.Definition.TransposableOriented (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Distributive.Definition.Distributive x, OAlg.Structure.Distributive.Definition.TransposableDistributive x) => OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative (OAlg.Entity.Matrix.Definition.Matrix x)
instance (OAlg.Structure.Distributive.Definition.Distributive x, OAlg.Structure.Distributive.Definition.TransposableDistributive x) => OAlg.Structure.Distributive.Definition.TransposableDistributive (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Hom.Distributive.HomDistributive h => OAlg.Category.Applicative.Applicative1 h OAlg.Entity.Matrix.Definition.Matrix
instance OAlg.Structure.Oriented.Definition.EntityPoint x => OAlg.Data.Dualisable.Dualisable (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Structure.Distributive.Definition.ForgetfulDst s => OAlg.Category.Applicative.Applicative (OAlg.Hom.Oriented.Definition.OpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Hom.Oriented.Definition.OpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Hom.Oriented.Definition.OpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibred (OAlg.Hom.Oriented.Definition.OpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibredOriented (OAlg.Hom.Oriented.Definition.OpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Additive.HomAdditive (OAlg.Hom.Oriented.Definition.OpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Distributive.HomDistributive (OAlg.Hom.Oriented.Definition.OpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance OAlg.Structure.Distributive.Definition.ForgetfulDst s => OAlg.Category.Applicative.Applicative (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibred (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Fibred.HomFibredOriented (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Additive.HomAdditive (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Distributive.HomDistributive (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance OAlg.Structure.Distributive.Definition.ForgetfulDst s => OAlg.Category.Definition.Functorial (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance (OAlg.Structure.Definition.TransformableOp s, OAlg.Structure.Distributive.Definition.ForgetfulDst s, OAlg.Structure.Definition.ForgetfulTyp s, Data.Typeable.Internal.Typeable s) => OAlg.Hom.Oriented.Definition.FunctorialHomOriented (OAlg.Hom.Oriented.Definition.IsoOpMap OAlg.Entity.Matrix.Definition.Matrix s)
instance OAlg.Structure.Oriented.Definition.XStandardPoint (OAlg.Entity.Matrix.Definition.Matrix OAlg.Data.Number.Z)
instance OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From (OAlg.Entity.Matrix.Definition.Matrix OAlg.Data.Number.Z)
instance OAlg.Structure.Oriented.Definition.XStandardOrtSiteFrom (OAlg.Entity.Matrix.Definition.Matrix OAlg.Data.Number.Z)
instance OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To (OAlg.Entity.Matrix.Definition.Matrix OAlg.Data.Number.Z)


-- | <a>Vector</a>s with coefficients, lying in a <a>Semiring</a>.
module OAlg.Entity.Matrix.Vector

-- | vector with coefficients lying in a <a>Semiring</a>, indexd by
--   <a>N</a>.
--   
--   <b>Definition</b> Let <tt>v = <a>Vector</a> ris</tt> be in
--   <tt><a>Vector</a> <b>r</b></tt> with <tt><b>r</b></tt> be a
--   <a>Semiring</a>, then <tt>v</tt> is <a>valid</a> iff
--   
--   <ol>
--   <li><tt>ris</tt> is <a>valid</a></li>
--   <li>For all <tt>(r,i)</tt> in <tt>ris</tt> holds: <tt>r</tt> is not
--   equal to <a>rZero</a>.</li>
--   </ol>
newtype Vector r
Vector :: PSequence N r -> Vector r

-- | the underlying partial sequence.
vecpsq :: Vector r -> PSequence N r

-- | the <tt>i</tt>-th coefficient of the given vector.
--   
--   <b>Example</b> Let <tt>v = <a>vector</a> [(-3,2),(9,4)] ::
--   <a>Vector</a> <a>Z</a></tt>
--   
--   <pre>
--   &gt;&gt;&gt; map (cf v) [0..8]
--   [0,0,-3,0,9,0,0,0,0]
--   </pre>
cf :: Semiring r => Vector r -> N -> r

-- | the associated free sum of symbols according to the given set of
--   symbols and coefficients.
--   
--   <b>Property</b> Let <tt>s = s 0 <a>&lt;</a> s 1 <a>&lt;</a> ..</tt> be
--   in <tt><a>Set</a> <b>a</b></tt> and <tt>r</tt> be in <tt><a>Vector</a>
--   <b>r</b></tt> then holds: <tt><a>cfsssy</a> s r <a>==</a> <a>cf</a> r
--   0 <a>!</a> <a>sy</a> (s 0) <a>+</a> <a>cf</a> r 1 <a>!</a> <a>sy</a>
--   (s 1) <a>+</a> ..</tt>.
cfsssy :: (Semiring r, Commutative r, Entity a, Ord a) => Set a -> Vector r -> SumSymbol r a

-- | the associated coefficients of a free sum of symbols according to the
--   given set of symbols.
--   
--   <b>Property</b> Let <tt>s = s 0 <a>&lt;</a> s 1 <a>&lt;</a> ..</tt> be
--   in <tt><a>Set</a> <b>a</b></tt> and <tt>x</tt> in <tt><a>SumSymbol</a>
--   <b>r</b> <b>a</b></tt> then holds: <tt><a>ssyprj</a> s x <a>==</a>
--   <a>cf</a> r 0 <a>!</a> <a>sy</a> (s 0) <a>+</a> <a>cf</a> r 1 <a>!</a>
--   <a>sy</a> (s 1) <a>+</a> ..</tt> where <tt>r = <a>ssycfs</a> s x</tt>,
ssycfs :: (Semiring r, Ord a) => Set a -> SumSymbol r a -> Vector r

-- | a vector as a row with one column at <tt>0</tt>.
vecrc :: Vector r -> Row N (Col N r)

-- | applying a matrix from the left.
vecAppl :: Semiring r => Matrix r -> Vector r -> Vector r
data HomSymbol r x y
[HomSymbol] :: (Entity x, Ord x, Entity y, Ord y) => PSequence x (LinearCombination r y) -> HomSymbol r (SumSymbol r x) (SumSymbol r y)
[Cfs] :: (Entity x, Ord x) => Set x -> HomSymbol r (SumSymbol r x) (Vector r)
[Ssy] :: (Entity x, Ord x) => Set x -> HomSymbol r (Vector r) (SumSymbol r x)
[HomMatrix] :: Matrix r -> HomSymbol r (Vector r) (Vector r)

-- | the associated <tt><b>r</b></tt>-linear homomorphism.
mtxHomSymbol :: Matrix r -> HomSymbol r (SumSymbol r N) (SumSymbol r N)

-- | the associated representation matrix of the given
--   <tt><b>r</b></tt>-homomorphism and the two symbol set.
--   
--   <b>Property</b> Let <tt>p = <a>Representable</a> h xs ys</tt> be in
--   <tt><a>Representable</a> <b>r</b> <b>h</b> <b>x</b> <b>y</b></tt> for
--   a <a>Commutative</a> <a>Semiring</a> <tt><b>r</b></tt>, then holds:
--   For all <tt>v</tt> in <tt><a>Vector</a> <b>r</b></tt> holds: Let
--   <tt>h' = <a>HomMatrix</a> (<a>repMatrix</a> p)</tt> in
--   
--   <ol>
--   <li>For all <tt>(_,i)</tt> in <tt>h' <a>$</a> v</tt> holds: <tt>i
--   <a>&lt;</a> <a>lengthN</a> ys</tt>.</li>
--   <li><tt>(<a>Ssy</a> ys <a>$</a> h' <a>$</a> v) <a>==</a> (h <a>$</a>
--   <a>Ssy</a> xs <a>$</a> v)</tt>.</li>
--   </ol>
repMatrix :: Representable r h x y -> Matrix r

-- | Predicate for a <tt><b>r</b></tt>-linear homomorphisms between the
--   free sums <tt><a>SumSymbol</a> <b>r</b> <b>x</b></tt> and
--   <tt><a>SumSymbol</a> <b>r</b> <b>y</b></tt> being <i>representable</i>
--   for the given symbol sets.
--   
--   <b>Definition</b> Let <tt>l</tt> be in <tt><a>LinearCombination</a>
--   <b>r</b> <b>x</b></tt> and <tt>xs</tt> be a <a>Set</a> of symbols of
--   <tt><b>x</b></tt>, then <tt>l</tt> is called <b><i>representable
--   in</i></b> <tt>xs</tt> iff all symbols of <tt><a>lcs</a> l</tt> are
--   elements of <tt>xs</tt>.
--   
--   <b>Property</b> Let <tt>h</tt> be a <tt><b>r</b></tt>-linear
--   homomorphism between the free sums <tt><a>SumSymbol</a> <b>r</b>
--   <b>x</b></tt> and <tt><a>SumSymbol</a> <b>r</b> <b>y</b></tt>,
--   <tt>xs</tt> a <a>Set</a> of symbols in <tt><b>x</b></tt> and
--   <tt>ys</tt> a <a>Set</a> of symbols in <tt><b>y</b></tt>, then holds:
--   If for each symbol <tt>x</tt> in <tt>xs</tt> the associated
--   <a>LinearCombination</a> of <tt>h <a>$</a> x</tt> is representable in
--   <tt>ys</tt>, then <tt><a>Representable</a> h xs ys</tt> is
--   <a>valid</a>.
data Representable r h x y
[Representable] :: (Hom (Vec r) h, Entity x, Ord x, Entity y, Ord y) => h (SumSymbol r x) (SumSymbol r y) -> Set x -> Set y -> Representable r h (SumSymbol r x) (SumSymbol r y)

-- | the associated representation of a matrix.
mtxRepresentable :: (Semiring r, Commutative r) => Matrix r -> Representable r (HomSymbol r) (SumSymbol r N) (SumSymbol r N)

-- | validity of <a>repMatrix</a> for the given vector.
prpRepMatrix :: (Semiring r, Commutative r) => Representable r h x y -> Vector r -> Statement

-- | validity of <a>repMatrix</a> for <a>Z</a>-matrices with the given row
--   and column numbers.
prpRepMatrixZ :: N -> N -> Statement

-- | random variable of <tt><a>Vector</a> <b>r</b></tt> where all indices
--   are strict smaller then the given bound.
--   
--   <b>Property</b> Let <tt>n</tt> be in <a>N</a> and <tt>xr</tt> be in
--   <tt><a>X</a> <b>r</b></tt> then holds: For all <tt>(_,i)</tt> in the
--   range of <tt><a>xVecN</a> n xr</tt> holds: <tt>i <a>&lt;</a> n</tt>.
xVecN :: Semiring r => N -> X r -> X (Vector r)
instance GHC.Classes.Ord r => GHC.Classes.Ord (OAlg.Entity.Matrix.Vector.Vector r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (OAlg.Entity.Matrix.Vector.Vector r)
instance GHC.Show.Show r => GHC.Show.Show (OAlg.Entity.Matrix.Vector.Vector r)
instance OAlg.Structure.Ring.Definition.Semiring r => GHC.Show.Show (OAlg.Entity.Matrix.Vector.HomSymbol r x y)
instance OAlg.Structure.Ring.Definition.Semiring r => GHC.Classes.Eq (OAlg.Entity.Matrix.Vector.HomSymbol r x y)
instance GHC.Show.Show (OAlg.Entity.Matrix.Vector.Representable r h x y)
instance OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Vector.Representable r h x y)
instance OAlg.Structure.Ring.Definition.Semiring r => OAlg.Data.Show.Show2 (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance OAlg.Structure.Ring.Definition.Semiring r => OAlg.Data.Equal.Eq2 (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance OAlg.Structure.Ring.Definition.Semiring r => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Vector.HomSymbol r x y)
instance OAlg.Structure.Ring.Definition.Semiring r => OAlg.Data.Validable.Validable2 (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance (OAlg.Structure.Ring.Definition.Semiring r, Data.Typeable.Internal.Typeable x, Data.Typeable.Internal.Typeable y) => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Vector.HomSymbol r x y)
instance OAlg.Structure.Ring.Definition.Semiring r => OAlg.Entity.Definition.Entity2 (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Category.Applicative.Applicative (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Category.Definition.Morphism (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Matrix.Vector.HomSymbol r) OAlg.Structure.Fibred.Definition.Fbr
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Matrix.Vector.HomSymbol r) OAlg.Structure.Definition.Typ
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Hom.Fibred.HomFibred (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Matrix.Vector.HomSymbol r) OAlg.Structure.Additive.Definition.Add
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Hom.Additive.HomAdditive (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Matrix.Vector.HomSymbol r) (OAlg.Structure.Vectorial.Definition.Vec r)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Hom.Vectorial.HomVectorial r (OAlg.Entity.Matrix.Vector.HomSymbol r)
instance OAlg.Structure.Ring.Definition.Semiring r => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Vector.Vector r)
instance OAlg.Structure.Ring.Definition.Semiring r => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Vector.Vector r)
instance OAlg.Structure.Ring.Definition.Semiring r => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Entity.Matrix.Vector.Vector r)
instance OAlg.Structure.Ring.Definition.Semiring r => OAlg.Structure.Additive.Definition.Additive (OAlg.Entity.Matrix.Vector.Vector r)
instance OAlg.Structure.Ring.Definition.Ring r => OAlg.Structure.Additive.Definition.Abelian (OAlg.Entity.Matrix.Vector.Vector r)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Structure.Vectorial.Definition.Vectorial (OAlg.Entity.Matrix.Vector.Vector r)
instance (OAlg.Structure.Ring.Definition.Semiring r, OAlg.Structure.Multiplicative.Definition.Commutative r) => OAlg.Structure.Vectorial.Definition.Euclidean (OAlg.Entity.Matrix.Vector.Vector r)


-- | general linear group <a>GL</a> and elementary transformations over a
--   <a>Galoisian</a> structure.
module OAlg.Entity.Matrix.GeneralLinearGroup

-- | elementary linear transformation over a <a>Distributive</a> structure
--   <tt><b>x</b></tt>.
--   
--   <b>Property</b> Let <tt>f</tt> be in <tt><a>Transformation</a>
--   <b>x</b></tt> then holds:
--   
--   <ol>
--   <li>If <tt>f</tt> matches <tt><a>Permute</a> r c p</tt> then
--   holds:<ol><li><tt>h <a>&lt;=</a> <a>It</a> n</tt> where <tt>(_,h) =
--   <a>span</a> <a>nProxy</a> p</tt> and <tt>n = <a>lengthN</a>
--   c</tt>.</li><li><tt>r <a>==</a> c <a>&lt;*</a> p</tt>.</li></ol></li>
--   <li>If <tt>f</tt> matches <tt><a>Scale</a> d k s</tt> then
--   holds:<ol><li><tt>k <a>&lt;</a> <a>lengthN</a>
--   d</tt>.</li><li><tt>s</tt> is an endo at <tt>d <a>?</a>
--   k</tt>.</li><li><tt>s</tt> is <a>valid</a>.</li></ol></li>
--   <li>If <tt>f</tt> matches <tt><a>Shear</a> d k l g</tt> then
--   holds:<ol><li><tt>k <a>&lt;</a> <a>lengthN</a> d</tt> and <tt>l
--   <a>&lt;</a> <a>lengthN</a> d</tt>.</li><li><tt>k <a>&lt;</a>
--   l</tt>.</li><li><tt>g</tt> is <a>valid</a>.</li></ol></li>
--   </ol>
--   
--   <b>Note</b> <tt><a>Shear</a> d k l (<a>GL2</a> s t u v)</tt>
--   represents the square matrix <tt>m</tt> of dimension <tt>d</tt> where
--   <tt>m k k <a>==</a> s</tt>, <tt>m k l <a>==</a> t</tt>, <tt>m l k
--   <a>==</a> u</tt>, <tt>m l l <a>==</a> v</tt> and for all <tt>i, j</tt>
--   not in <tt>[k,l]</tt> holds: If <tt>i <a>/=</a> j</tt> then <tt>m i
--   j</tt> is <a>zero</a> else <tt>m i i</tt> is <a>one</a>.
data Transformation x
[Permute] :: Distributive x => Dim x (Point x) -> Dim x (Point x) -> Permutation N -> Transformation x
[Scale] :: Distributive x => Dim x (Point x) -> N -> Inv x -> Transformation x
[Shear] :: Galoisian x => Dim x (Point x) -> N -> N -> GL2 x -> Transformation x

-- | general linear groupoid of matrices.
type GL x = Inv (Matrix x)

-- | the general linear group of <tt>2x2</tt> matrices for a
--   <a>Galoisian</a> structure <tt><b>x</b></tt>.
--   
--   <b>Property</b> Let <tt><a>GL2</a> s t u v</tt> be in <tt><a>GL2</a>
--   <b>x</b></tt> for a <a>Galoisian</a> structure <tt><b>x</b></tt>, then
--   holds: <tt>s<a>*</a>v <a>-</a> u<a>*</a>t</tt> is invertible.
--   
--   <b>Example</b> Let <tt>g = <a>GL2</a> 3 5 4 7 :: <a>GL2</a>
--   <a>Z</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; invert g
--    GL2 7 -5 -4 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; g * invert g
--   GL2 1 0 0 1
--   </pre>
--   
--   which is the <a>one</a> in <tt><a>GL2</a> <a>Z</a></tt>.
--   
--   <b>Note</b>
--   
--   <tt><a>GL2</a> (s t u v)</tt> represents the <tt>2x2</tt>-matrix
--   
--   <pre>
--   [s t]
--   [u v]
--   </pre>
--   
--   and is obtained by <a>GL2GL</a>.
data GL2 x
GL2 :: x -> x -> x -> x -> GL2 x

-- | quotient groupoid of the free groupoid of <a>Transformation</a> (see
--   <a>FTGLT</a>) given by the relations:
--   
--   <ul>
--   <li><tt><a>permuteFT</a> d c p <a>*</a> <a>permuteFT</a> b a q ~
--   <a>permuteFT</a> d a (q<a>*</a>p)</tt> where <tt>b <a>==</a> c</tt>
--   and <tt><a>Permute</a> d c p</tt>, <tt><a>Permute</a> b a q</tt> are
--   <a>valid</a> (Note: the permutations <tt>p</tt> and <tt>q</tt> are
--   switched on the right side of the equation).</li>
--   <li>...</li>
--   </ul>
--   
--   <b>Property</b> Let <tt>g</tt> be in <a>GLT</a>, then holds:
--   
--   <ol>
--   <li>For all exponents <tt>z</tt> in <tt><a>form</a> g</tt> holds:
--   <tt>0 <a>&lt;</a> z</tt>.</li>
--   </ol>
--   
--   <b>Example</b> Let <tt>d = <a>dim</a> [()] <a>^</a> 10 :: <a>Dim'</a>
--   <a>Z</a></tt>, <tt>a = <a>permuteFT</a> d d (<a>swap</a> 2 8)</tt>,
--   <tt>b = <a>permuteFT</a> d d (<a>swap</a> 2 3)</tt> and <tt>c =
--   <a>permuteFT</a> d d (<a>swap</a> 2 3 * <a>swap</a> 2 8)</tt> then:
--   
--   <pre>
--   &gt;&gt;&gt; a * b == c
--   False
--   </pre>
--   
--   but in <a>GLT</a> holds: let <tt>a' = <a>amap</a> <a>FTGLT</a> a</tt>,
--   <tt>b' = <a>amap</a> <a>FTGLT</a> b</tt> and <tt>c' = <a>amap</a>
--   <a>FTGLT</a> c</tt> in
--   
--   <pre>
--   &gt;&gt;&gt; a' * b' == c'
--   True
--   </pre>
--   
--   and
--   
--   <pre>
--   &gt;&gt;&gt; amap GLTGL (a' * b') == amap GLTGL a' * amap GLTGL b'
--   True
--   </pre>
--   
--   <b>Note</b>: As a consequence of the property (1.), <a>GLT</a> can be
--   canonically embedded via <tt><a>prj</a> <a>.</a> <a>form</a></tt> - in
--   to <tt><a>ProductForm</a> <a>N</a> (<a>Transformation</a> x)</tt>.
data GLT x

-- | permutation of the given dimensions.
--   
--   <b>Property</b> Let <tt>r</tt>, <tt>c</tt> be in <tt><a>Dim'</a>
--   <b>x</b></tt> and <tt>p</tt> in <tt><a>Permutation</a> <a>N</a></tt>
--   for a <a>Distributive</a> structure <tt><b>x</b></tt>, then holds: If
--   <tt><a>Permute</a> r c p</tt> is <a>valid</a> then <tt><a>permute</a>
--   r c p</tt> is <a>valid</a>.
--   
--   <b>Example</b> Let <tt>t = <a>permute</a> r c p</tt> with
--   <tt><a>Permute</a> r c p</tt> is <a>valid</a> then its associated
--   matrix (see <a>GLTGL</a>) has the orientation <tt>c <a>:&gt;</a>
--   r</tt> and the form
--   
--   <pre>
--            k         l
--   [1                          ]
--   [  .                        ]
--   [    .                      ]
--   [     1                     ]
--   [                 1         ] k
--   [         1                 ]
--   [           .               ]
--   [             .             ]
--   [               1           ]
--   [       1                   ] l
--   [                    1      ]
--   [                      .    ]
--   [                        .  ]
--   [                          1]
--   </pre>
--   
--   <b>Note</b> <tt>r</tt> dose not have to be equal to <tt>c</tt>, but
--   from <tt>r <a>==</a> c <a>&lt;*</a> p</tt> follows that both have the
--   same length.
permute :: Distributive x => Dim' x -> Dim' x -> Permutation N -> GLT x

-- | the induce element in the free groupoid of transformations.
permuteFT :: Distributive x => Dim' x -> Dim' x -> Permutation N -> FT x

-- | scaling.
--   
--   <b>Property</b> Let <tt>d</tt> be in <tt><a>Dim'</a> <b>x</b></tt>,
--   <tt>k</tt> in <a>N</a> and <tt>s</tt> in <tt><a>Inv</a> <b>x</b></tt>,
--   then holds: If <tt><a>Scale</a> d k s</tt> is <a>valid</a> then
--   <tt><a>scale</a> d k s</tt> is <a>valid</a>.
--   
--   <b>Example</b> Let <tt>t = <a>scale</a> d k s</tt> with
--   <tt><a>Scale</a> d k s</tt> is <a>valid</a> then its associated matrix
--   (see <a>GLTGL</a>) is an endo with dimension <tt>d</tt> and has the
--   form
--   
--   <pre>
--           k         
--   [1               ]
--   [  .             ]
--   [    .           ]
--   [     1          ]
--   [      s'        ] k
--   [         1      ]
--   [           .    ]
--   [             .  ]
--   [               1]
--   </pre>
--   
--   where <tt>s' = (<a>inj</a> :: <a>Inv</a> <b>x</b> -&gt; <b>x</b>)
--   s</tt>.
scale :: Distributive x => Dim' x -> N -> Inv x -> GLT x

-- | shearing.
--   
--   <b>Property</b> Let <tt>d</tt> be in <tt><a>Dim'</a> <b>x</b></tt>,
--   <tt>k</tt>, <tt>l</tt> in <a>N</a> and <tt>g</tt> in <tt><a>GL2</a>
--   <b>x</b></tt> then holds: If <tt><a>Shear</a> d k l g</tt> is
--   <a>valid</a> then <tt><a>shear</a> d k l g</tt> is <a>valid</a>.
--   
--   <b>Example</b> Let <tt>t = <a>shear</a> d k l g</tt> where
--   <tt><a>Shear</a> d k l g</tt> is <a>valid</a> then its associated
--   matrix (see <a>GLTGL</a>) is an endo with dimension <tt>d</tt> and has
--   the form
--   
--   <pre>
--            k         l
--   [1                          ]
--   [  .                        ]
--   [    .                      ]
--   [     1                     ]
--   [       s         t         ] k
--   [         1                 ]
--   [           .               ]
--   [             .             ]
--   [               1           ]
--   [       u         v         ] l
--   [                    1      ]
--   [                      .    ]
--   [                        .  ]
--   [                          1]
--   </pre>
shear :: Galoisian x => Dim' x -> N -> N -> GL2 x -> GLT x

-- | reduces a <tt><a>GLTForm</a> <b>x</b></tt> to its normal form.
--   
--   <b>Property</b> Let <tt>f</tt> be in <tt><a>GLTForm</a> <b>x</b></tt>
--   for a <a>Oriented</a> structure <tt><b>x</b></tt>, then holds:
--   
--   <ol>
--   <li><tt><a>rdcGLTForm</a> (<a>rdcGLTForm</a> f) <a>==</a>
--   <a>rdcGLTForm</a> f</tt>.</li>
--   <li>For all exponents <tt>z</tt> in <tt><a>rdcGLTForm</a> f</tt>
--   holds: <tt>0 <a>&lt;</a> z</tt>.</li>
--   </ol>
rdcGLTForm :: Oriented x => GLTForm x -> GLTForm x

-- | form of <a>GLT</a>.
type GLTForm x = ProductForm Z (Transformation x)

-- | transposition of a product of elementary transformation.
gltfTrsp :: TransposableDistributive r => GLTForm r -> GLTForm r

-- | the free groupoid of <a>Transformation</a>s.
type FT x = Product Z (Transformation x)

-- | <a>Oriented</a> homomorphisms.
data TrApp x y
[TrFT] :: Oriented x => TrApp (Transformation x) (FT x)
[TrGL] :: Distributive x => TrApp (Transformation x) (GL x)
[TrGLT] :: Oriented x => TrApp (Transformation x) (GLT x)

-- | the induced element of the groupoid <a>GLT</a>.
trGLT :: Oriented x => Transformation x -> GLT x

-- | <a>Multiplicative</a> homomorphisms.
data GLApp x y
[FTGL] :: Distributive x => GLApp (FT x) (GL x)
[FTGLT] :: Oriented x => GLApp (FT x) (GLT x)
[GLTGL] :: Distributive x => GLApp (GLT x) (GL x)
[GL2GL] :: Galoisian x => GLApp (GL2 x) (GL x)
instance GHC.Classes.Ord x => GHC.Classes.Ord (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance GHC.Classes.Eq x => GHC.Classes.Eq (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance GHC.Show.Show x => GHC.Show.Show (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Structure.Oriented.Definition.Oriented x => GHC.Show.Show (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Structure.Oriented.Definition.Oriented x => GHC.Classes.Eq (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance GHC.Classes.Eq (OAlg.Entity.Matrix.GeneralLinearGroup.Transformation x)
instance GHC.Show.Show (OAlg.Entity.Matrix.GeneralLinearGroup.Transformation x)
instance GHC.Show.Show (OAlg.Entity.Matrix.GeneralLinearGroup.TrApp x y)
instance GHC.Classes.Eq (OAlg.Entity.Matrix.GeneralLinearGroup.TrApp x y)
instance GHC.Show.Show (OAlg.Entity.Matrix.GeneralLinearGroup.GLApp x y)
instance GHC.Classes.Eq (OAlg.Entity.Matrix.GeneralLinearGroup.GLApp x y)
instance OAlg.Data.Show.Show2 OAlg.Entity.Matrix.GeneralLinearGroup.GLApp
instance OAlg.Data.Equal.Eq2 OAlg.Entity.Matrix.GeneralLinearGroup.GLApp
instance OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.GeneralLinearGroup.GLApp x y)
instance OAlg.Data.Validable.Validable2 OAlg.Entity.Matrix.GeneralLinearGroup.GLApp
instance (Data.Typeable.Internal.Typeable x, Data.Typeable.Internal.Typeable y) => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.GeneralLinearGroup.GLApp x y)
instance OAlg.Entity.Definition.Entity2 OAlg.Entity.Matrix.GeneralLinearGroup.GLApp
instance OAlg.Category.Definition.Morphism OAlg.Entity.Matrix.GeneralLinearGroup.GLApp
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.Entity.Matrix.GeneralLinearGroup.GLApp OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.Entity.Matrix.GeneralLinearGroup.GLApp OAlg.Structure.Definition.Typ
instance OAlg.Category.Definition.EmbeddableMorphismTyp OAlg.Entity.Matrix.GeneralLinearGroup.GLApp
instance OAlg.Category.Applicative.Applicative OAlg.Entity.Matrix.GeneralLinearGroup.GLApp
instance OAlg.Hom.Oriented.Definition.HomOriented OAlg.Entity.Matrix.GeneralLinearGroup.GLApp
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.Entity.Matrix.GeneralLinearGroup.GLApp OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Hom.Multiplicative.Definition.HomMultiplicative OAlg.Entity.Matrix.GeneralLinearGroup.GLApp
instance OAlg.Data.Show.Show2 OAlg.Entity.Matrix.GeneralLinearGroup.TrApp
instance OAlg.Data.Equal.Eq2 OAlg.Entity.Matrix.GeneralLinearGroup.TrApp
instance OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.GeneralLinearGroup.TrApp x y)
instance OAlg.Data.Validable.Validable2 OAlg.Entity.Matrix.GeneralLinearGroup.TrApp
instance (Data.Typeable.Internal.Typeable x, Data.Typeable.Internal.Typeable y) => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.GeneralLinearGroup.TrApp x y)
instance OAlg.Entity.Definition.Entity2 OAlg.Entity.Matrix.GeneralLinearGroup.TrApp
instance OAlg.Category.Definition.Morphism OAlg.Entity.Matrix.GeneralLinearGroup.TrApp
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.Entity.Matrix.GeneralLinearGroup.TrApp OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Category.Definition.EmbeddableMorphism OAlg.Entity.Matrix.GeneralLinearGroup.TrApp OAlg.Structure.Definition.Typ
instance OAlg.Category.Definition.EmbeddableMorphismTyp OAlg.Entity.Matrix.GeneralLinearGroup.TrApp
instance OAlg.Category.Applicative.Applicative OAlg.Entity.Matrix.GeneralLinearGroup.TrApp
instance OAlg.Hom.Oriented.Definition.HomOriented OAlg.Entity.Matrix.GeneralLinearGroup.TrApp
instance OAlg.Data.Constructable.Exposable (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Data.Constructable.Constructable (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Data.Canonical.Embeddable (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x) (OAlg.Entity.Product.Definition.ProductForm OAlg.Data.Number.N (OAlg.Entity.Matrix.GeneralLinearGroup.Transformation x))
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Multiplicative.Definition.Invertible (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Exponential.Exponential (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Multiplicative.Definition.Cayleyan (OAlg.Entity.Matrix.GeneralLinearGroup.GLT x)
instance OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.GeneralLinearGroup.Transformation x)
instance Data.Typeable.Internal.Typeable x => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.GeneralLinearGroup.Transformation x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Matrix.GeneralLinearGroup.Transformation x)
instance OAlg.Structure.Ring.Definition.Galoisian x => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance OAlg.Structure.Ring.Definition.Galoisian x => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance OAlg.Structure.Ring.Definition.Galoisian x => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance OAlg.Structure.Ring.Definition.Galoisian x => OAlg.Structure.Oriented.Definition.Total (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance OAlg.Structure.Ring.Definition.Galoisian x => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance OAlg.Structure.Ring.Definition.Galoisian x => OAlg.Structure.Multiplicative.Definition.Invertible (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance OAlg.Structure.Ring.Definition.Galoisian x => OAlg.Structure.Multiplicative.Definition.Cayleyan (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance OAlg.Structure.Ring.Definition.Galoisian x => OAlg.Structure.Exponential.Exponential (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance (OAlg.Structure.Ring.Definition.Galoisian x, OAlg.Structure.Distributive.Definition.TransposableDistributive x) => OAlg.Data.Dualisable.Transposable (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance (OAlg.Structure.Ring.Definition.Galoisian x, OAlg.Structure.Distributive.Definition.TransposableDistributive x) => OAlg.Structure.Oriented.Definition.TransposableOriented (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)
instance (OAlg.Structure.Ring.Definition.Galoisian x, OAlg.Structure.Distributive.Definition.TransposableDistributive x) => OAlg.Structure.Multiplicative.Definition.TransposableMultiplicative (OAlg.Entity.Matrix.GeneralLinearGroup.GL2 x)


-- | elementary matrix transformations, i.e. operations of <a>GLT</a> on
--   <a>Matrix</a>.
module OAlg.Entity.Matrix.Transformation

-- | <a>GLT</a> as row transformations.
newtype RowTrafo a
RowTrafo :: GLT a -> RowTrafo a

-- | applying a transformation as a row transformation on a column of rows.
crTrafoRows :: Transformation x -> Col N (Row N x) -> Col N (Row N x)

-- | <a>GLT</a> as a column transformation.
newtype ColTrafo x
ColTrafo :: GLT x -> ColTrafo x

-- | applying a transformation as a column transformation on a column of
--   rows.
crTrafoCols :: Col N (Row N x) -> Transformation x -> Col N (Row N x)

-- | the result of transforming a matrix into a diagonal form.
--   
--   <b>Property</b> Let <tt><a>DiagonalForm</a> ds rt ct</tt> be in
--   <tt><a>DiagonalForm</a> <b>k</b></tt>, then holds:
--   
--   <ol>
--   <li><tt>n <a>&lt;=</a> <a>lengthN</a> (<a>start</a> rt)</tt> and <tt>n
--   <a>&lt;=</a> <a>lengthN</a> (<a>end</a> ct)</tt> where <tt>n =
--   <a>lengthN</a> ds</tt>.</li>
--   <li>For all <tt>d</tt> in <tt>ds</tt> holds: <tt><a>not</a>
--   (<a>isZero</a> d)</tt>.</li>
--   </ol>
data DiagonalForm k
DiagonalForm :: [k] -> RowTrafo k -> ColTrafo k -> DiagonalForm k

-- | the resulting matrix by applying on the diagonal matrix the inverse of
--   the given transformations.
dgfMatrix :: Distributive k => DiagonalForm k -> Matrix k

-- | predicate for diagonal forms with strict positive entries.
--   
--   <b>Property</b> Let <tt><a>DiagonalFormStrictPositive</a>
--   (<a>DiagonalForm</a> ds _ _)</tt> be in <tt><a>DiagonalForm</a>
--   <b>k</b></tt>, then holds: <tt>0 <a>&lt;</a> d</tt> for all <tt>d</tt>
--   in <tt>ds</tt>.
newtype DiagonalFormStrictPositive k
DiagonalFormStrictPositive :: DiagonalForm k -> DiagonalFormStrictPositive k
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Multiplicative.Definition.Cayleyan (OAlg.Entity.Matrix.Transformation.ColTrafo x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Multiplicative.Definition.Invertible (OAlg.Entity.Matrix.Transformation.ColTrafo x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Matrix.Transformation.ColTrafo x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Transformation.ColTrafo x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Transformation.ColTrafo x)
instance OAlg.Structure.Oriented.Definition.Oriented x => GHC.Show.Show (OAlg.Entity.Matrix.Transformation.ColTrafo x)
instance OAlg.Structure.Oriented.Definition.Oriented x => GHC.Classes.Eq (OAlg.Entity.Matrix.Transformation.ColTrafo x)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Structure.Multiplicative.Definition.Cayleyan (OAlg.Entity.Matrix.Transformation.RowTrafo a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Structure.Multiplicative.Definition.Invertible (OAlg.Entity.Matrix.Transformation.RowTrafo a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Matrix.Transformation.RowTrafo a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Transformation.RowTrafo a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Transformation.RowTrafo a)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Show.Show (OAlg.Entity.Matrix.Transformation.RowTrafo a)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Classes.Eq (OAlg.Entity.Matrix.Transformation.RowTrafo a)
instance OAlg.Structure.Oriented.Definition.Oriented k => GHC.Show.Show (OAlg.Entity.Matrix.Transformation.DiagonalForm k)
instance OAlg.Structure.Oriented.Definition.Oriented k => GHC.Classes.Eq (OAlg.Entity.Matrix.Transformation.DiagonalForm k)
instance OAlg.Structure.Oriented.Definition.Oriented k => GHC.Classes.Eq (OAlg.Entity.Matrix.Transformation.DiagonalFormStrictPositive k)
instance OAlg.Structure.Oriented.Definition.Oriented k => GHC.Show.Show (OAlg.Entity.Matrix.Transformation.DiagonalFormStrictPositive k)
instance OAlg.Structure.Number.Definition.Number k => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Transformation.DiagonalFormStrictPositive k)
instance OAlg.Structure.Number.Definition.Number k => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Transformation.DiagonalFormStrictPositive k)
instance OAlg.Structure.Distributive.Definition.Distributive k => OAlg.Data.Validable.Validable (OAlg.Entity.Matrix.Transformation.DiagonalForm k)
instance OAlg.Structure.Distributive.Definition.Distributive k => OAlg.Entity.Definition.Entity (OAlg.Entity.Matrix.Transformation.DiagonalForm k)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Matrix.Transformation.RowTrafo a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Structure.Exponential.Exponential (OAlg.Entity.Matrix.Transformation.RowTrafo a)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Operational.Opl (OAlg.Entity.Matrix.Transformation.RowTrafo x) (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Structure.Distributive.Definition.Distributive x => OAlg.Structure.Operational.OrientedOpl (OAlg.Entity.Matrix.Transformation.RowTrafo x) (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Matrix.Transformation.ColTrafo x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Exponential.Exponential (OAlg.Entity.Matrix.Transformation.ColTrafo x)
instance OAlg.Structure.Oriented.Definition.Oriented x => OAlg.Structure.Operational.Opr (OAlg.Entity.Matrix.Transformation.ColTrafo x) (OAlg.Entity.Matrix.Definition.Matrix x)
instance OAlg.Structure.Distributive.Definition.Distributive x => OAlg.Structure.Operational.OrientedOpr (OAlg.Entity.Matrix.Transformation.ColTrafo x) (OAlg.Entity.Matrix.Definition.Matrix x)


-- | natural transformations between <a>Diagram</a>s.
module OAlg.Entity.Diagram.Transformation

-- | natural transformations between two <a>Diagram</a>s.
--   
--   <b>Property</b> Let <tt><a>Transformation</a> a b t</tt> be in
--   <tt><a>Transformation</a> <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> for
--   a <a>Multiplicative</a> structure <b><tt>a</tt></b>, then holds
--   
--   <ol>
--   <li><tt><a>dgQuiver</a> a <a>==</a> <a>dgQuiver</a> b</tt>.</li>
--   <li>For all <tt>0 <a>&lt;=</a> i <a>&lt;</a> n</tt> holds:
--   <tt><a>orientation</a> (t i) <a>==</a> p i <a>:&gt;</a> q i</tt> where
--   <tt>p = <a>dgPoints</a> a</tt> and <tt>q = <a>dgPoints</a>
--   b</tt>.</li>
--   <li>For all <tt>0 <a>&lt;=</a> j <a>&lt;</a> m</tt> holds: <tt>t (e j)
--   <a>*</a> f j <a>==</a> g j <a>*</a> t (s j)</tt> where <tt>f =
--   <a>dgArrows</a> a</tt>, <tt>g = <a>dgArrows</a> b</tt>, <tt>s j</tt>
--   is the index of the start point of the <tt>j</tt>-th arrow and <tt>e
--   j</tt> is the index of the end point.</li>
--   </ol>
--   
--   <pre>
--                    t (s j)
--    s j     p (s j) --------&gt; q (s j)
--     |         |                 |
--   j |     f j |                 | g j
--     |         |                 |
--     v         v                 v
--    e j     p (e j) --------&gt; q (e j)
--                    t (e j)
--   </pre>
data Transformation t n m a
Transformation :: Diagram t n m a -> Diagram t n m a -> FinList n a -> Transformation t n m a

-- | the underlying list of factors.
trfs :: Transformation t n m a -> FinList n a

-- | the dual transformation.
coTransformation :: Transformation t n m a -> Dual (Transformation t n m a)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Classes.Eq (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Show.Show (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance OAlg.Structure.Multiplicative.Definition.Multiplicative a => OAlg.Data.Validable.Validable (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Entity.Definition.Entity (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Fibred.Definition.Fibred (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Fibred.Definition.FibredOriented (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Additive.Definition.Additive (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Distributive.Definition.Distributive (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, OAlg.Structure.Additive.Definition.Abelian a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Additive.Definition.Abelian (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, OAlg.Structure.Vectorial.Definition.Vectorial a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Vectorial.Definition.Vectorial (OAlg.Entity.Diagram.Transformation.Transformation t n m a)
instance (OAlg.Structure.Algebraic.Definition.Algebraic a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Algebraic.Definition.Algebraic (OAlg.Entity.Diagram.Transformation.Transformation t n m a)


-- | diagrams over <a>Oriented</a> structures.
module OAlg.Entity.Diagram


-- | definition of <a>Cone</a>s over <a>Diagram</a>s.
module OAlg.Limes.Cone.Definition

-- | cone over a diagram.
--   
--   <b>Properties</b> Let <tt>c</tt> be in <tt><a>Cone</a> <b>s</b>
--   <b>p</b> <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> then holds:
--   
--   <ol>
--   <li>If <tt>c</tt> matches <tt><a>ConeProjective</a> d t cs</tt> for a
--   <a>Multiplicative</a> structure <b><tt>a</tt></b> then
--   holds:<ol><li>For all <tt>ci</tt> in <tt>cs</tt> holds:
--   <tt><a>start</a> ci <a>==</a> t</tt> and <tt><a>end</a> ci <a>==</a>
--   pi</tt> where <tt>pi</tt> in <tt><a>dgPoints</a> d</tt>.</li><li>For
--   all <tt>aij</tt> in <tt><a>dgArrows</a> d</tt> holds: <tt>aij <a>*</a>
--   ci <a>==</a> cj</tt> where <tt>ci</tt>, <tt>cj</tt> in
--   <tt>cs</tt>.</li></ol></li>
--   <li>If <tt>c</tt> matches <tt><a>ConeInjective</a> d t cs</tt> for a
--   <a>Multiplicative</a> structure <b><tt>a</tt></b> then
--   holds:<ol><li>For all <tt>ci</tt> in <tt>cs</tt> holds: <tt><a>end</a>
--   ci <a>==</a> t</tt> and <tt><a>start</a> ci <a>==</a> pi</tt> where
--   <tt>pi</tt> in <tt><a>dgPoints</a> d</tt>.</li><li>For all
--   <tt>aij</tt> in <tt><a>dgArrows</a> d</tt> holds: <tt>cj <a>*</a> aij
--   <a>==</a> ci</tt> where <tt>ci</tt>, <tt>cj</tt> in
--   <tt>cs</tt>.</li></ol></li>
--   <li>If <tt>c</tt> matches <tt><a>ConeKernel</a> p k</tt> for a
--   <a>Distributive</a> structure <b><tt>a</tt></b> then
--   holds:<ol><li><tt><a>end</a> k <a>==</a> p0</tt> where <tt>p0</tt> in
--   <tt><a>dgPoints</a> p</tt></li><li>For all <tt>a</tt> in
--   <tt><a>dgArrows</a> p</tt> holds: <tt>a <a>*</a> k <a>==</a>
--   <a>zero</a> (t <a>:&gt;</a> p1)</tt> where <tt>t = <a>start</a> k</tt>
--   and <tt>p0</tt>, <tt>p1</tt> in <tt><a>dgPoints</a>
--   p</tt>.</li></ol></li>
--   <li>If <tt>c</tt> matches <tt><a>ConeCokernel</a> p k</tt> for a
--   <a>Distributive</a> structure <b><tt>a</tt></b> then
--   holds:<ol><li><tt><a>start</a> k <a>==</a> p0</tt> where <tt>p0</tt>
--   in <tt><a>cnPoints</a> c</tt></li><li>For all <tt>a</tt> in
--   <tt><a>dgArrows</a> p</tt> holds: <tt>k <a>*</a> a <a>==</a>
--   <a>zero</a> (p1 <a>:&gt;</a> t)</tt> where <tt>t = <a>end</a> k</tt>
--   and <tt>p0</tt>, <tt>p1</tt> in <tt><a>dgPoints</a>
--   p</tt>.</li></ol></li>
--   </ol>
data Cone s p t n m a
[ConeProjective] :: Multiplicative a => Diagram t n m a -> Point a -> FinList n a -> Cone Mlt Projective t n m a
[ConeInjective] :: Multiplicative a => Diagram t n m a -> Point a -> FinList n a -> Cone Mlt Injective t n m a
[ConeKernel] :: Distributive a => Diagram (Parallel LeftToRight) N2 m a -> a -> Cone Dst Projective (Parallel LeftToRight) N2 m a
[ConeCokernel] :: Distributive a => Diagram (Parallel RightToLeft) N2 m a -> a -> Cone Dst Injective (Parallel RightToLeft) N2 m a

-- | concept of <a>Projective</a> and <a>Injective</a>.
data Perspective
Projective :: Perspective
Injective :: Perspective

-- | the underlying diagram.
cnDiagram :: Cone s p t n m a -> Diagram t n m a

-- | reflexivity of the underlying diagram type.
cnDiagramTypeRefl :: Cone s p t n m a -> Dual (Dual t) :~: t

-- | the tip of a cone.
--   
--   <b>Property</b> Let <tt>c</tt> be in <tt><a>Cone</a> <b>s</b> <b>p</b>
--   <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> for a <a>Oriented</a>
--   structure then holds:
--   
--   <ol>
--   <li>If <b><tt>p</tt></b> is equal to <b><a>Projective</a></b> then
--   holds: <tt><a>start</a> ci <a>==</a> <a>tip</a> c</tt> for all
--   <tt>ci</tt> in <tt><a>shell</a> c</tt>.</li>
--   <li>If <b><tt>p</tt></b> is equal to <b><a>Injective</a></b> then
--   holds: <tt><a>end</a> ci <a>==</a> <a>tip</a> c</tt> for all
--   <tt>ci</tt> in <tt><a>shell</a> c</tt>.</li>
--   </ol>
tip :: Cone s p t n m a -> Point a

-- | the shell of a cone.
--   
--   <b>Property</b> Let <tt>c</tt> be in <tt><a>Cone</a> <b>s</b> <b>p</b>
--   <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> for a <a>Oriented</a>
--   structure then holds:
--   
--   <ol>
--   <li>If <b><tt>p</tt></b> is equal to <b><a>Projective</a></b> then
--   holds: <tt><a>fmap</a> <a>end</a> (<a>shell</a> c) <a>==</a>
--   <a>cnPoints</a> c</tt>.</li>
--   <li>If <b><tt>p</tt></b> is equal to <b><a>Injective</a></b> then
--   holds: <tt><a>fmap</a> <a>start</a> (<a>shell</a> c) <a>==</a>
--   <a>cnPoints</a> c</tt>.</li>
--   </ol>
shell :: Cone s p t n m a -> FinList n a

-- | the arrows of the underlying diagram, i.e. <tt><a>dgArrows</a>
--   <a>.</a> <a>cnDiagram</a></tt>.
cnArrows :: Cone s p t n m a -> FinList m a

-- | the points of the underlying diagram, i.e. <tt><a>dgPoints</a>
--   <a>.</a> <a>cnDiagram</a></tt>.
cnPoints :: Oriented a => Cone s p t n m a -> FinList n (Point a)

-- | mapping of a cone.
cnMap :: Hom s h => h a b -> Cone s p t n m a -> Cone s p t n m b

-- | mapping of a cone under a <a>Multiplicative</a> homomorphism.
cnMapMlt :: Hom Mlt h => h a b -> Cone Mlt p t n m a -> Cone Mlt p t n m b

-- | mapping of a cone under a <a>Distributive</a> homomorphism.
cnMapDst :: Hom Dst h => h a b -> Cone Dst p t n m a -> Cone Dst p t n m b

-- | embedding of a cone in a distributive structure to its multiplicative
--   cone.
cnZeroHead :: Cone Dst p t n m a -> ConeZeroHead Mlt p t n (m + 1) a

-- | the kernel cone of a zero headed parallel cone, i.e. the inverse of
--   <a>cnZeroHead</a>.
cnKernel :: (Distributive a, p ~ Projective, t ~ Parallel LeftToRight) => ConeZeroHead Mlt p t n (m + 1) a -> Cone Dst p t n m a

-- | the cokernel cone of a zero headed parallel cone, i.e. the inverse of
--   <a>cnZeroHead</a>.
cnCokernel :: (Distributive a, p ~ Injective, t ~ Parallel RightToLeft) => ConeZeroHead Mlt p t n (m + 1) a -> Cone Dst p t n m a

-- | subtracts to every arrow of the underlying parallel diagram the first
--   arrow and adapts the shell accordingly.
cnDiffHead :: (Distributive a, Abelian a) => Cone Mlt p (Parallel d) n (m + 1) a -> ConeZeroHead Mlt p (Parallel d) n (m + 1) a

-- | predicate for cones where the first arrow of its underlying diagram is
--   equal to <a>zero</a>.
newtype ConeZeroHead s p t n m a
ConeZeroHead :: Cone s p t n m a -> ConeZeroHead s p t n m a

-- | to the dual, with its inverse <a>coConeZeroHead</a>.
coConeZeroHead :: ConeZeroHead s p t n m a -> Dual (ConeZeroHead s p t n m a)

-- | from the bidual.
czFromOpOp :: ConeStruct s a -> ConeZeroHead s p t n m (Op (Op a)) -> ConeZeroHead s p t n m a

-- | from the dual, with its inverse <a>coConeZeroHead</a>.
coConeZeroHeadInv :: ConeStruct s a -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> Dual (ConeZeroHead s p t n m a) -> ConeZeroHead s p t n m a

-- | to <tt><b>g</b> (<a>Op</a> <b>a</b>)</tt>.
cnToOp :: ConeDuality s f g a -> f a -> g (Op a)

-- | from <tt><b>g</b> (<a>Op</a> <b>a</b>)</tt>.
cnFromOp :: ConeDuality s f g a -> g (Op a) -> f a

-- | <a>Op</a>-duality between cone types.
data ConeDuality s f g a
[ConeDuality] :: ConeStruct s a -> (f a :~: Cone s p t n m a) -> (g (Op a) :~: Dual (Cone s p t n m a)) -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> ConeDuality s f g a

-- | to the dual cone, with its inverse <a>coConeInv</a>.
coCone :: Cone s p t n m a -> Dual (Cone s p t n m a)

-- | from the dual cone, with its inverse <a>coCone</a>.
coConeInv :: ConeStruct s a -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> Dual (Cone s p t n m a) -> Cone s p t n m a

-- | from <tt><a>Op</a> <a>.</a> <a>Op</a></tt>.
cnFromOpOp :: ConeStruct s a -> Cone s p t n m (Op (Op a)) -> Cone s p t n m a

-- | cone structures.
data ConeStruct s a
[ConeStructMlt] :: Multiplicative a => ConeStruct Mlt a
[ConeStructDst] :: Distributive a => ConeStruct Dst a

-- | the opposite cone structure.
cnStructOp :: ConeStruct s a -> ConeStruct s (Op a)

-- | the <a>Multiplicative</a> structure of a cone structure.
cnStructMlt :: ConeStruct s a -> Struct Mlt a

-- | the associated structure of a cone structure.
cnStruct :: ConeStruct s a -> Struct s a

-- | the projective cone on <a>Orientation</a> with the underlying given
--   diagram and tip with the given point.
cnPrjOrnt :: Entity p => p -> Diagram t n m (Orientation p) -> Cone Mlt Projective t n m (Orientation p)

-- | the injective cone on <a>Orientation</a> with the underlying given
--   diagram and tip with the given point.
cnInjOrnt :: Entity p => p -> Diagram t n m (Orientation p) -> Cone Mlt Injective t n m (Orientation p)

-- | the induced <a>Projective</a> cone with ending factor given by the
--   given <a>FactorChain</a>.
--   
--   <b>Property</b> Let <tt>h = <a>FactorChain</a> f d</tt> be in
--   <tt><a>FactorChain</a> <a>To</a> <b>n</b> <b>a</b></tt> for a
--   <a>Multiplicative</a> structure <tt><b>a</b></tt> and
--   <tt><a>ConeProjective</a> d' _
--   (_<a>:|</a>..<a>:|</a>c<a>:|</a><a>Nil</a>) = <a>cnPrjChainTo</a>
--   h</tt> then holds: <tt>d' <a>==</a> d</tt> and <tt>c <a>==</a> f</tt>.
cnPrjChainTo :: Multiplicative a => FactorChain To n a -> Cone Mlt Projective (Chain To) (n + 1) n a

-- | the underlying factor chain of a projective chain to cone, i.e the
--   inverse of <a>cnPrjChainToInv</a>.
cnPrjChainToInv :: Cone Mlt Projective (Chain To) (n + 1) n a -> FactorChain To n a

-- | the induced <a>Projective</a> cone with starting factor given by the
--   given <a>FactorChain</a>.
--   
--   <b>Property</b> Let <tt>h = <a>FactorChain</a> f d</tt> be in
--   <tt><a>FactorChain</a> <a>From</a> <b>n</b> <b>a</b></tt> for a
--   <a>Multiplicative</a> structure <tt><b>a</b></tt> and
--   <tt><a>ConeProjective</a> d' _ (c<a>:|</a>_) = <a>cnPrjChainFrom</a>
--   h</tt> then holds: <tt>d' <a>==</a> d</tt> and <tt>c <a>==</a> f</tt>.
cnPrjChainFrom :: Multiplicative a => FactorChain From n a -> Cone Mlt Projective (Chain From) (n + 1) n a

-- | the underlying factor chain of a projective chain from cone, i.e. the
--   inverse of <a>cnPrjChainFrom</a>.
cnPrjChainFromInv :: Cone Mlt Projective (Chain From) (n + 1) n a -> FactorChain From n a

-- | predicate for a factor with <a>end</a> point at the starting point of
--   the given chain.
--   
--   <b>Property</b>
--   
--   <ol>
--   <li>Let <tt><a>FactorChain</a> f d</tt> be in <tt><a>FactorChain</a>
--   <a>To</a> <b>n</b> <b>a</b></tt> for a <a>Multiplicative</a> structure
--   <tt><b>a</b></tt> then holds: <tt><a>end</a> f <a>==</a>
--   <a>chnToStart</a> d</tt>.</li>
--   <li>Let <tt><a>FactorChain</a> f d</tt> be in <tt><a>FactorChain</a>
--   <a>From</a> <b>n</b> <b>a</b></tt> for a <a>Multiplicative</a>
--   structure <tt><b>a</b></tt> then holds: <tt><a>end</a> f <a>==</a>
--   <a>chnFromStart</a> d</tt>.</li>
--   </ol>
data FactorChain s n a
FactorChain :: a -> Diagram (Chain s) (n + 1) n a -> FactorChain s n a
instance GHC.Classes.Eq (OAlg.Limes.Cone.Definition.ConeZeroHead s p t n m a)
instance GHC.Show.Show (OAlg.Limes.Cone.Definition.ConeZeroHead s p t n m a)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Classes.Eq (OAlg.Limes.Cone.Definition.FactorChain s n a)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Show.Show (OAlg.Limes.Cone.Definition.FactorChain s n a)
instance GHC.Show.Show (OAlg.Limes.Cone.Definition.ConeStruct s a)
instance GHC.Classes.Eq (OAlg.Limes.Cone.Definition.ConeStruct s a)
instance GHC.Show.Show (OAlg.Limes.Cone.Definition.Cone s p t n m a)
instance GHC.Classes.Eq (OAlg.Limes.Cone.Definition.Cone s p t n m a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Data.Validable.Validable (OAlg.Limes.Cone.Definition.FactorChain 'OAlg.Data.Dualisable.To n a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Data.Validable.Validable (OAlg.Limes.Cone.Definition.FactorChain 'OAlg.Data.Dualisable.From n a)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative a, Data.Typeable.Internal.Typeable n) => OAlg.Entity.Definition.Entity (OAlg.Limes.Cone.Definition.FactorChain 'OAlg.Data.Dualisable.To n a)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative a, Data.Typeable.Internal.Typeable n) => OAlg.Entity.Definition.Entity (OAlg.Limes.Cone.Definition.FactorChain 'OAlg.Data.Dualisable.From n a)
instance OAlg.Structure.Distributive.Definition.Distributive a => OAlg.Data.Validable.Validable (OAlg.Limes.Cone.Definition.ConeZeroHead s p d n ('OAlg.Entity.Natural.S m) a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable p, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Entity.Definition.Entity (OAlg.Limes.Cone.Definition.ConeZeroHead s p t n ('OAlg.Entity.Natural.S m) a)
instance OAlg.Hom.Multiplicative.Definition.HomMultiplicative h => OAlg.Category.Applicative.Applicative1 h (OAlg.Limes.Cone.Definition.Cone OAlg.Structure.Multiplicative.Definition.Mlt p t n m)
instance OAlg.Hom.Distributive.HomDistributive h => OAlg.Category.Applicative.Applicative1 h (OAlg.Limes.Cone.Definition.Cone OAlg.Structure.Distributive.Definition.Dst p t n m)
instance OAlg.Data.Validable.Validable (OAlg.Limes.Cone.Definition.Cone s p t n m a)
instance (Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable p, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m, Data.Typeable.Internal.Typeable a) => OAlg.Entity.Definition.Entity (OAlg.Limes.Cone.Definition.Cone s p t n m a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable p, Data.Typeable.Internal.Typeable d, Data.Typeable.Internal.Typeable m) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Limes.Cone.Definition.Cone s p ('OAlg.Entity.Diagram.Definition.Parallel d) OAlg.Entity.Natural.N2 m a)
instance (OAlg.Entity.Definition.Entity p, OAlg.Data.Validable.XStandard p, OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram t n m (OAlg.Structure.Oriented.Definition.Orientation p))) => OAlg.Data.Validable.XStandard (OAlg.Limes.Cone.Definition.Cone OAlg.Structure.Multiplicative.Definition.Mlt 'OAlg.Limes.Perspective.Projective t n m (OAlg.Structure.Oriented.Definition.Orientation p))
instance (OAlg.Entity.Definition.Entity p, t GHC.Types.~ 'OAlg.Entity.Diagram.Definition.Parallel 'OAlg.Data.Dualisable.LeftToRight, n GHC.Types.~ OAlg.Entity.Natural.N2, OAlg.Data.Validable.XStandard p, OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram t n m (OAlg.Structure.Oriented.Definition.Orientation p))) => OAlg.Data.Validable.XStandard (OAlg.Limes.Cone.Definition.Cone OAlg.Structure.Distributive.Definition.Dst 'OAlg.Limes.Perspective.Projective t n m (OAlg.Structure.Oriented.Definition.Orientation p))
instance (OAlg.Entity.Definition.Entity p, OAlg.Data.Validable.XStandard p, OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram t n m (OAlg.Structure.Oriented.Definition.Orientation p))) => OAlg.Data.Validable.XStandard (OAlg.Limes.Cone.Definition.Cone OAlg.Structure.Multiplicative.Definition.Mlt 'OAlg.Limes.Perspective.Injective t n m (OAlg.Structure.Oriented.Definition.Orientation p))
instance (OAlg.Entity.Definition.Entity p, t GHC.Types.~ 'OAlg.Entity.Diagram.Definition.Parallel 'OAlg.Data.Dualisable.RightToLeft, n GHC.Types.~ OAlg.Entity.Natural.N2, OAlg.Data.Validable.XStandard p, OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram t n m (OAlg.Structure.Oriented.Definition.Orientation p))) => OAlg.Data.Validable.XStandard (OAlg.Limes.Cone.Definition.Cone OAlg.Structure.Distributive.Definition.Dst 'OAlg.Limes.Perspective.Injective t n m (OAlg.Structure.Oriented.Definition.Orientation p))


-- | eligible factors between <a>Cone</a>s.
module OAlg.Limes.Cone.EligibleFactor

-- | eligibility of a factor between two cones.
--   
--   <b>Property</b> Let <tt>x</tt> be in <b><tt>a</tt></b> and <tt>f</tt>,
--   <tt>t</tt> in <tt><a>Cone</a> <b>s</b> <b>p</b> <b>t</b> <b>n</b>
--   <b>m</b> <b>a</b></tt> with <tt><a>cnDiagram</a> f <a>==</a>
--   <a>cnDiagram</a> t</tt>, then holds:
--   
--   <ol>
--   <li>If <b><tt>p</tt></b> is equal to <b><a>Projective</a></b> then
--   holds: <tt><a>cnEligibleFactor</a> x f t</tt> is <a>True</a> if and
--   only if<ol><li><tt><a>orientation</a> x <a>==</a> <a>tip</a> f
--   <a>:&gt;</a> <a>tip</a> t</tt>.</li><li><tt>ti <a>*</a> x <a>==</a>
--   fi</tt> for all <tt>ti</tt> in <tt><a>shell</a> t</tt> and <tt>fi</tt>
--   in <tt><a>shell</a> f</tt>.</li></ol></li>
--   <li>If <b><tt>p</tt></b> is equal to <b><a>Injective</a></b> then
--   holds: <tt><a>cnEligibleFactor</a> x f t</tt> is <a>True</a> if and
--   only if<ol><li><tt><a>orientation</a> x <a>==</a> <a>tip</a> f
--   <a>:&gt;</a> <a>tip</a> t</tt>.</li><li><tt>x <a>*</a> ti <a>==</a>
--   fi</tt> for all <tt>ti</tt> in <tt><a>shell</a> t</tt> and <tt>fi</tt>
--   in <tt><a>shell</a> f</tt>.</li></ol></li>
--   </ol>
cnEligibleFactor :: a -> Cone s p t n m a -> Cone s p t n m a -> Bool

-- | predicate for eligible factors between cones.
--   
--   <b>Property</b> Let <tt>e</tt> be in <tt><a>EligibleFactor</a>
--   <b>s</b> <b>p</b> <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> for a
--   <a>Multiplicative</a> structure <b><tt>a</tt></b>, then holds:
--   
--   <ol>
--   <li>If <tt>e</tt> matches <tt><a>EligibleFactorTo</a> l x c</tt> then
--   holds: <tt><a>cnDiagram</a> l <a>==</a> <a>cnDiagram</a> c</tt> and
--   <tt><a>cnEligibleFactor</a> x c l</tt>.</li>
--   <li>If <tt>e</tt> matches <tt><a>EligibleFactorFrom</a> l x c</tt>
--   then holds: <tt><a>cnDiagram</a> l <a>==</a> <a>cnDiagram</a> c</tt>
--   and <tt><a>cnEligibleFactor</a> x l c</tt>.</li>
--   </ol>
data EligibleFactor s p t n m a
[EligibleFactorTo] :: Cone s Projective t n m a -> a -> Cone s Projective t n m a -> EligibleFactor s Projective t n m a
[EligibleFactorFrom] :: Cone s Injective t n m a -> a -> Cone s Injective t n m a -> EligibleFactor s Injective t n m a

-- | the underlying factor together with its cone.
elfFactorCone :: EligibleFactor s p t n m a -> (a, Cone s p t n m a)

-- | mapping of a eligible factor.
elfMap :: Hom s h => h a b -> EligibleFactor s p t n m a -> EligibleFactor s p t n m b

-- | to the dual, with its inverse <a>coEligibleFactorInv</a>.
coEligibleFactor :: EligibleFactor s p t n m a -> Dual (EligibleFactor s p t n m a)

-- | from the dual, with its inverse <a>coEligibleFactor</a>.
coEligibleFactorInv :: ConeStruct s a -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> Dual (EligibleFactor s p t n m a) -> EligibleFactor s p t n m a

-- | from the bidual.
elfFromOpOp :: ConeStruct s a -> EligibleFactor s p t n m (Op (Op a)) -> EligibleFactor s p t n m a

-- | the induced random variable of eligible factors.
xopEligibleFactor :: ConeStruct s a -> XOrtPerspective p a -> Cone s p t n m a -> X (EligibleFactor s p t n m a)

-- | random variable given by a <a>XOrtSite</a>.
data XOrtPerspective p a
[XOrtProjective] :: XOrtSite To a -> XOrtPerspective Projective a
[XOrtInjective] :: XOrtSite From a -> XOrtPerspective Injective a

-- | standard random variable for <a>XOrtPerspective</a>.
class XStandardOrtPerspective p a
xStandardOrtPerspective :: XStandardOrtPerspective p a => XOrtPerspective p a

-- | the induced random variable of eligible factors.
xosEligibleFactorPrj :: XOrtSite To a -> Cone s Projective t n m a -> X (EligibleFactor s Projective t n m a)

-- | the induced random variable of eligible factors.
xosEligibleFactorInj :: ConeStruct s a -> (Dual (Dual t) :~: t) -> XOrtSite From a -> Cone s Injective t n m a -> X (EligibleFactor s Injective t n m a)
instance GHC.Show.Show a => GHC.Show.Show (OAlg.Limes.Cone.EligibleFactor.EligibleFactor s p t n m a)
instance OAlg.Structure.Oriented.Definition.XStandardOrtSiteTo a => OAlg.Limes.Cone.EligibleFactor.XStandardOrtPerspective 'OAlg.Limes.Perspective.Projective a
instance OAlg.Structure.Oriented.Definition.XStandardOrtSiteFrom a => OAlg.Limes.Cone.EligibleFactor.XStandardOrtPerspective 'OAlg.Limes.Perspective.Injective a
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Data.Validable.Validable (OAlg.Limes.Cone.EligibleFactor.EligibleFactor s p t n m a)


-- | cones over diagrams.
module OAlg.Limes.Cone


-- | definition of a <a>Limes</a> of a <a>Diagram</a>.
module OAlg.Limes.Definition

-- | limes of a diagram, i.e. a distinguished cone over a given diagram
--   having the following <i>universal</i> property
--   
--   <b>Property</b> Let <b><tt>a</tt></b> be a <a>Multiplicative</a>
--   structure and <tt>u</tt> in <tt><a>Limes</a> <b>s</b> <b>p</b>
--   <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> then holds: Let <tt>l =
--   <a>universalCone</a> u</tt> in
--   
--   <ol>
--   <li><tt>l</tt> is <a>valid</a>.</li>
--   <li><tt><a>eligibleCone</a> u l</tt>.</li>
--   <li><tt><a>eligibleFactor</a> u l (<a>one</a> (<a>tip</a>
--   l))</tt>.</li>
--   <li>For all <tt>c</tt> in <tt><a>Cone</a> <b>s</b> <b>p</b> <b>t</b>
--   <b>n</b> <b>m</b> <b>a</b></tt> with <tt><a>eligibleCone</a> u c</tt>
--   holds: Let <tt>f = <a>universalFactor</a> u c</tt>
--   in<ol><li><tt>f</tt> is
--   <a>valid</a>.</li><li><tt><a>eligibleFactor</a> u c
--   f</tt>.</li><li>For all <tt>x</tt> in <b><tt>a</tt></b> with
--   <tt><a>eligibleFactor</a> u c x</tt> holds: <tt>x <a>==</a>
--   f</tt>.</li></ol></li>
--   </ol>
--   
--   <b>Note</b>
--   
--   <ol>
--   <li>As the function <tt><a>universalFactor</a> l</tt> for a given
--   limes <tt>l</tt> is uniquely determined by the underlying cone of
--   <tt>l</tt>, it is permissible to test equality of two limits just by
--   there underling cones. In every computation equal limits can be safely
--   replaced by each other.</li>
--   <li>It is not required that the evaluation of universal factor on a
--   non eligible cone yield an exception! The implementation of the
--   general algorithms for limits do not check for eligibility.</li>
--   </ol>
data Limes s p t n m a
[LimesProjective] :: Cone s Projective t n m a -> (Cone s Projective t n m a -> a) -> Limes s Projective t n m a
[LimesInjective] :: Cone s Injective t n m a -> (Cone s Injective t n m a -> a) -> Limes s Injective t n m a

-- | the universal point of a limes, i.e. the tip of the universal cone.
universalPoint :: Limes s p t n m a -> Point a

-- | the underlying universal cone of a limes.
universalCone :: Limes s p t n m a -> Cone s p t n m a

-- | the shell of the universal cone.
universalShell :: Limes s p t n m a -> FinList n a

-- | the universal factor of a <a>Limes</a> <tt>l</tt> to a given eligible
--   cone.
--   
--   <b>Property</b> Let <tt>l</tt> be in <tt><a>Limes</a> <b>s</b>
--   <b>p</b> <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> then holds: For all
--   <tt>c</tt> in <tt><a>Cone</a> <b>s</b> <b>p</b> <b>t</b> <b>n</b>
--   <b>m</b> <b>a</b></tt> with <tt><a>eligibleCone</a> l c</tt> holds:
--   <tt><a>eligibleFactor</a> l c (<a>universalFactor</a> l c)</tt>.
universalFactor :: Limes s p t n m a -> Cone s p t n m a -> a

-- | the underlying diagram of a limes.
diagram :: Limes s p t n m a -> Diagram t n m a

-- | reflexivity of the underlying diagram type.
lmDiagramTypeRefl :: Limes s p t n m a -> Dual (Dual t) :~: t

-- | eligibility of a cone with respect to a limes.
--   
--   <b>Property</b> Let <tt>u</tt> be in <tt><a>Limes</a> <b>s</b>
--   <b>p</b> <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> and <tt>c</tt> in
--   <tt><a>Cone</a> <b>s</b> <b>p</b> <b>t</b> <b>n</b> <b>m</b>
--   <b>a</b></tt> then holds: <tt><a>eligibleCone</a> u c</tt> is true if
--   and only if <tt><a>diagram</a> u <a>==</a> <a>cnDiagram</a> c</tt> is
--   true.
eligibleCone :: Oriented a => Limes s p t n m a -> Cone s p t n m a -> Bool

-- | eligibility of a factor with respect to a limes and a cone.
--   
--   <b>Property</b> Let <tt>u</tt> be in <tt><a>Limes</a> <b>s</b>
--   <b>p</b> <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt>, <tt>c</tt> in
--   <tt><a>Cone</a> <b>s</b> <b>p</b> <b>t</b> <b>n</b> <b>m</b>
--   <b>a</b></tt> with <tt><a>eligibleCone</a> u c</tt> and <tt>x</tt> in
--   <b><tt>a</tt></b> then holds:
--   
--   <ol>
--   <li>If <tt>u</tt> matches <tt><a>LimesProjective</a> l _</tt> then
--   holds: <tt><a>eligibleFactor</a> u c x</tt> is true if and only if
--   <tt><a>cnEligibleFactor</a> x c l</tt> is true.</li>
--   <li>If <tt>u</tt> matches <tt><a>LimesInjective</a> l _</tt> then
--   holds: <tt><a>eligibleFactor</a> u c x</tt> is true if and only if
--   <tt><a>cnEligibleFactor</a> x l c</tt> is true.</li>
--   </ol>
eligibleFactor :: Limes s p t n m a -> Cone s p t n m a -> a -> Bool

-- | mapping between limits.
lmMap :: IsoOrt s h => h a b -> Limes s p t n m a -> Limes s p t n m b

-- | to <tt><b>g</b> (<a>Op</a> <b>a</b>)</tt>.
lmToOp :: LimesDuality s f g a -> f a -> g (Op a)

-- | from <tt><b>g</b> (<a>Op</a> <b>a</b>)</tt>.
lmFromOp :: LimesDuality s f g a -> g (Op a) -> f a

-- | <a>Op</a>-duality between limes types.
data LimesDuality s f g a
[LimesDuality] :: ConeStruct s a -> (f a :~: Limes s p t n m a) -> (g (Op a) :~: Dual (Limes s p t n m a)) -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> LimesDuality s f g a

-- | the co limes with its inverse <a>coLimesInv</a>.
coLimes :: ConeStruct s a -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> Limes s p t n m a -> Dual (Limes s p t n m a)

-- | the inverse of <a>coLimes</a>.
coLimesInv :: ConeStruct s a -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> Dual (Limes s p t n m a) -> Limes s p t n m a

-- | from <tt><a>Op</a> <a>.</a> <a>Op</a></tt>.
lmFromOpOp :: ConeStruct s a -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> Limes s p t n m (Op (Op a)) -> Limes s p t n m a

-- | projective limes on oriented structures.
lmToPrjOrnt :: (Entity p, a ~ Orientation p) => p -> Diagram t n m a -> Limes Mlt Projective t n m a

-- | injective limes on oriented structures.
lmFromInjOrnt :: (Entity p, a ~ Orientation p) => p -> Diagram t n m a -> Limes Mlt Injective t n m a

-- | validity of a <a>Limes</a>.
relLimes :: ConeStruct s a -> XOrtPerspective p a -> Limes s p t n m a -> Statement

-- | limes exceptions which are sub exceptions from
--   <a>SomeOAlgException</a>.
data LimesException
ConeNotEligible :: String -> LimesException
instance GHC.Show.Show OAlg.Limes.Definition.LimesException
instance GHC.Classes.Eq OAlg.Limes.Definition.LimesException
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Show.Show (OAlg.Limes.Definition.Limes s p t n m a)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Classes.Eq (OAlg.Limes.Definition.Limes s p t n m a)
instance OAlg.Hom.Multiplicative.Definition.IsoMultiplicative h => OAlg.Category.Applicative.Applicative1 h (OAlg.Limes.Definition.Limes OAlg.Structure.Multiplicative.Definition.Mlt p t n m)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative a, OAlg.Limes.Cone.EligibleFactor.XStandardOrtPerspective p a) => OAlg.Data.Validable.Validable (OAlg.Limes.Definition.Limes OAlg.Structure.Multiplicative.Definition.Mlt p t n m a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, OAlg.Limes.Cone.EligibleFactor.XStandardOrtPerspective p a, Data.Typeable.Internal.Typeable p, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Data.Validable.Validable (OAlg.Limes.Definition.Limes OAlg.Structure.Distributive.Definition.Dst p t n m a)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative a, OAlg.Limes.Cone.EligibleFactor.XStandardOrtPerspective p a, Data.Typeable.Internal.Typeable p, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Entity.Definition.Entity (OAlg.Limes.Definition.Limes OAlg.Structure.Multiplicative.Definition.Mlt p t n m a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, OAlg.Limes.Cone.EligibleFactor.XStandardOrtPerspective p a, Data.Typeable.Internal.Typeable p, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Entity.Definition.Entity (OAlg.Limes.Definition.Limes OAlg.Structure.Distributive.Definition.Dst p t n m a)
instance GHC.Exception.Type.Exception OAlg.Limes.Definition.LimesException


-- | <a>Limits</a> of <a>Diagram</a>s, i.e. assigning to each diagram a
--   <a>Limes</a> over the given diagram.
module OAlg.Limes.Limits

-- | limes of a diagram, i.e. assigning to each diagram a limes over the
--   given diagram.
--   
--   <b>Property</b> Let <tt>lms</tt> be in <tt><a>Limits</a> <b>s</b>
--   <b>p</b> <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> and <tt>d</tt> in
--   <tt><a>Diagram</a> <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> then
--   holds: <tt><a>diagram</a> (<a>limes</a> lms d) <a>==</a> d</tt>.
newtype Limits s p t n m a
Limits :: (Diagram t n m a -> Limes s p t n m a) -> Limits s p t n m a

-- | the limes over the given diagram.
limes :: Limits s p t n m a -> Diagram t n m a -> Limes s p t n m a

-- | mapping of limits.
lmsMap :: IsoOrt s h => h a b -> Limits s p t n m a -> Limits s p t n m b

-- | to <tt><b>g</b> (<a>Op</a> <b>a</b>)</tt>.
lmsToOp :: LimitsDuality s f g a -> f a -> g (Op a)

-- | from <tt><b>g</b> (<a>Op</a> <b>a</b>)</tt>.
lmsFromOp :: LimitsDuality s f g a -> g (Op a) -> f a

-- | <a>Op</a>-duality between limits types.
data LimitsDuality s f g a
[LimitsDuality] :: ConeStruct s a -> (f a :~: Limits s p t n m a) -> (g (Op a) :~: Dual (Limits s p t n m a)) -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> LimitsDuality s f g a

-- | the co limits wit its inverse <a>coLimitsInv</a>.
coLimits :: ConeStruct s a -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> Limits s p t n m a -> Dual (Limits s p t n m a)

-- | from the co limits, with its inverse of <a>coLimits</a>.
coLimitsInv :: ConeStruct s a -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> Dual (Limits s p t n m a) -> Limits s p t n m a

-- | from the bidual.
lmsFromOpOp :: ConeStruct s a -> (Dual (Dual p) :~: p) -> (Dual (Dual t) :~: t) -> Limits s p t n m (Op (Op a)) -> Limits s p t n m a

-- | projective limits for <tt><a>Orientation</a> <b>p</b></tt>.
lmsToPrjOrnt :: Entity p => p -> Limits Mlt Projective t n m (Orientation p)

-- | injective limits for <tt><a>Orientation</a> <b>p</b></tt>.
lmsFromInjOrnt :: Entity p => p -> Limits Mlt Injective t n m (Orientation p)

-- | validity according to <a>Limits</a>, relative to the given random
--   variable for <a>Diagram</a>s.
prpLimits :: ConeStruct s a -> Limits s p t n m a -> X (Diagram t n m a) -> XOrtPerspective p a -> Statement

-- | validity according to <a>Limits</a>.
prpLimitsDiagram :: ConeStruct s a -> XOrtPerspective p a -> Limits s p t n m a -> Diagram t n m a -> Statement
instance OAlg.Hom.Multiplicative.Definition.IsoMultiplicative h => OAlg.Category.Applicative.Applicative1 h (OAlg.Limes.Limits.Limits OAlg.Structure.Multiplicative.Definition.Mlt p t n m)
instance OAlg.Hom.Distributive.IsoDistributive h => OAlg.Category.Applicative.Applicative1 h (OAlg.Limes.Limits.Limits OAlg.Structure.Distributive.Definition.Dst p t n m)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative a, OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram t n m a), OAlg.Limes.Cone.EligibleFactor.XStandardOrtPerspective p a) => OAlg.Data.Validable.Validable (OAlg.Limes.Limits.Limits OAlg.Structure.Multiplicative.Definition.Mlt p t n m a)
instance (OAlg.Structure.Distributive.Definition.Distributive a, OAlg.Data.Validable.XStandard (OAlg.Entity.Diagram.Definition.Diagram t n m a), OAlg.Limes.Cone.EligibleFactor.XStandardOrtPerspective p a) => OAlg.Data.Validable.Validable (OAlg.Limes.Limits.Limits OAlg.Structure.Distributive.Definition.Dst p t n m a)


-- | terminal and initial point within a <a>Multiplicative</a> structure,
--   i.e. limits of <tt><a>Diagram</a> <a>Empty</a></tt>.
module OAlg.Limes.TerminalAndInitialPoint

-- | terminal point within a <a>Multiplicative</a> structure.
type Terminals = Limits Mlt Projective 'Empty N0 N0

-- | terminal point as <a>Limes</a>.
type TerminalPoint = Limes Mlt Projective 'Empty N0 N0

-- | <a>Cone</a> for a terminal point.
type TerminalCone = Cone Mlt Projective 'Empty N0 N0

-- | <a>Diagram</a> for a terminal point.
type TerminalDiagram = Diagram 'Empty N0 N0

-- | the terminal diagram.
trmDiagram :: TerminalDiagram a

-- | the terminal cone of a given point.
trmCone :: Multiplicative a => Point a -> TerminalCone a

-- | the terminal limes of a given point <tt>p</tt>.
terminalPointOrnt :: Entity p => p -> TerminalPoint (Orientation p)

-- | terminals for <a>Orientation</a>.
trmsOrnt :: Entity p => p -> Terminals (Orientation p)

-- | initial point within a <a>Multiplicative</a> structure.
type Initials = Limits Mlt Injective 'Empty N0 N0

-- | initial point as <a>Limes</a>.
type InitialPoint = Limes Mlt Injective 'Empty N0 N0

-- | <a>Cone</a> for a initial point.
type InitialCone = Cone Mlt Injective 'Empty N0 N0

-- | <a>Diagram</a> for a initial point.
type InitialDiagram = Diagram 'Empty N0 N0

-- | the initial diagram.
intDiagram :: InitialDiagram a

-- | the initial cone of a given point.
intCone :: Multiplicative a => Point a -> InitialCone a

-- | initial point for <a>Orientation</a>.
initialPointOrnt :: Entity p => p -> InitialPoint (Orientation p)

-- | initials.
intsOrnt :: Entity p => p -> Initials (Orientation p)

-- | terminal <a>Diagram</a> duality.
trmDiagramDuality :: Oriented a => DiagramDuality TerminalDiagram InitialDiagram a

-- | terminal <a>Cone</a> duality.
trmConeDuality :: Multiplicative a => ConeDuality Mlt TerminalCone InitialCone a

-- | terminal <a>Limes</a> duality.
trmLimesDuality :: Multiplicative a => LimesDuality Mlt TerminalPoint InitialPoint a

-- | terminal <a>Limits</a> duality.
trmLimitsDuality :: Multiplicative a => LimitsDuality Mlt Terminals Initials a

-- | initial <a>Diagram</a> duality.
intDiagramDuality :: Oriented a => DiagramDuality InitialDiagram TerminalDiagram a

-- | initial <a>Cone</a> duality.
intConeDuality :: Multiplicative a => ConeDuality Mlt InitialCone TerminalCone a

-- | initial <a>Limes</a> duality.
intLimesDuality :: Multiplicative a => LimesDuality Mlt InitialPoint TerminalPoint a

-- | initial <a>Limits</a> duality.
intLimitsDuality :: Multiplicative a => LimitsDuality Mlt Initials Terminals a


-- | minima and maxima within a <a>Multiplicative</a> structure, i.e.
--   limits of <tt><a>Diagram</a> (<a>Chain</a> <b>t</b>)</tt>.
module OAlg.Limes.MinimaAndMaxima

-- | minima for a <a>Multiplicative</a> structure.
type Minima t n = Limits Mlt Projective (Chain t) (n + 1) n

-- | minimum as <a>Limes</a>.
type Minimum t n = Limes Mlt Projective (Chain t) (n + 1) n

-- | <a>Cone</a> for a minimum.
type MinimumCone t n = Cone Mlt Projective (Chain t) (n + 1) n

-- | <a>Diagram</a> for a minimum.
type MinimumDiagram t n = Diagram (Chain t) (n + 1) n

-- | minima according to <tt><a>Chain</a> <a>To</a></tt>.
minimaTo :: Multiplicative a => Minima To n a

-- | minima according to <tt><a>Chain</a> <a>From</a></tt>.
minimaFrom :: Multiplicative a => Minima From n a

-- | maxima for a <a>Multiplicative</a> structure.
type Maxima t n = Limits Mlt Injective (Chain t) (n + 1) n

-- | maximum as a <a>Limes</a>.
type Maximum t n = Limes Mlt Injective (Chain t) (n + 1) n

-- | <a>Cone</a> for a maximum.
type MaximumCone t n = Cone Mlt Injective (Chain t) (n + 1) n

-- | <a>Diagram</a> for a maximum.
type MaximumDiagram t n = Diagram (Chain t) (n + 1) n

-- | maxima according to <tt><a>Chain</a> <a>To</a></tt>.
maximaTo :: Multiplicative a => Maxima To n a

-- | maxima according to <tt><a>Chain</a> <a>To</a></tt> given by two proxy
--   types.
maximaTo' :: Multiplicative a => p n -> f a -> Maxima To n a

-- | maxima according to <tt><a>Chain</a> <a>From</a></tt>.
maximaFrom :: Multiplicative a => Maxima From n a

-- | maxima according to <tt><a>Chain</a> <a>From</a></tt> given by two
--   proxy types.
maximaFrom' :: Multiplicative a => p n -> f a -> Maxima From n a

-- | duality between <tt><a>Maxima</a> <a>To</a></tt> and <tt><a>Minima</a>
--   <a>From</a></tt>.
maxLimitsDualityTo :: Multiplicative a => LimitsDuality Mlt (Maxima To n) (Minima From n) a

-- | duality between <tt><a>Maxima</a> <a>From</a></tt> and
--   <tt><a>Minima</a> <a>To</a></tt>.
maxLimitsDualityFrom :: Multiplicative a => LimitsDuality Mlt (Maxima From n) (Minima To n) a


-- | products and sums, i.e. limits of <tt><a>Diagram</a>
--   <a>Discrete</a></tt>.
module OAlg.Limes.ProductsAndSums

-- | products for a <a>Multiplicative</a> structure.
type Products n = Limits Mlt Projective Discrete n N0

-- | product as a <a>Limes</a>.
type Product n = Limes Mlt Projective Discrete n N0

-- | <a>Cone</a> for a product.
type ProductCone n = Cone Mlt Projective Discrete n N0

-- | <a>Diagram</a> for a product.
type ProductDiagram n = Diagram Discrete n N0

-- | the underlying product diagram.
prdDiagram :: Oriented a => Diagram (Star From) (n + 1) n a -> ProductDiagram n a

-- | the product cone.
prdCone :: Multiplicative a => Diagram (Star From) (n + 1) n a -> ProductCone n a

-- | products of <tt>n</tt> points given by products of zero and two
--   points.
products :: Multiplicative a => Products N0 a -> Products N2 a -> Products n a

-- | products of zero points given by a terminal point.
products0 :: Multiplicative a => TerminalPoint a -> Products N0 a

-- | products of one point, i.e. <a>Minima</a>.
products1 :: Multiplicative a => Products N1 a

-- | products of at least two points given by products of two points.
products2 :: Multiplicative a => Products N2 a -> Products (n + 2) a

-- | product cone for <a>Orientation</a>.
prdConeOrnt :: Entity p => p -> FinList n p -> ProductCone n (Orientation p)

-- | product for <a>Orientation</a>.
productOrnt :: Entity p => p -> FinList n p -> Product n (Orientation p)

-- | products for <a>Orientation</a>.
productsOrnt :: Entity p => p -> Products n (Orientation p)

-- | sums for a <a>Multiplicative</a> structure.
type Sums n = Limits Mlt Injective Discrete n N0

-- | sum as a 'Limes.
type Sum n = Limes Mlt Injective Discrete n N0

-- | <a>Cone</a> for a sum.
type SumCone n = Cone Mlt Injective Discrete n N0

-- | <a>Diagram</a> for a sum.
type SumDiagram n = Diagram Discrete n N0

-- | duality between sums and products.
sumLimitsDuality :: Multiplicative a => LimitsDuality Mlt (Sums n) (Products n) a

-- | the underlying sum diagram given by a sink diagram.
sumDiagram :: Oriented a => Diagram (Star To) (n + 1) n a -> SumDiagram n a

-- | the sum cone given by a sink diagram.
sumCone :: Multiplicative a => Diagram (Star To) (n + 1) n a -> SumCone n a

-- | sums of <tt>n</tt> points given by sums of zero and two points.
sums :: Multiplicative a => Sums N0 a -> Sums N2 a -> Sums n a

-- | sums given by a proxy type for <tt>n</tt>.
sums' :: Multiplicative a => p n -> Sums N0 a -> Sums N2 a -> Sums n a

-- | sums of zero points given by a initial point.
sums0 :: Multiplicative a => InitialPoint a -> Sums N0 a

-- | sums of one point, i.e. <a>Maxima</a>.
sums1 :: Multiplicative a => Sums N1 a

-- | sums of at least two points given by sums of two points.
sums2 :: Multiplicative a => Sums N2 a -> Sums (n + 2) a

-- | sum cone for <a>Orientation</a>.
sumConeOrnt :: Entity p => p -> FinList n p -> SumCone n (Orientation p)

-- | sum for <a>Orientation</a>.
sumOrnt :: Entity p => p -> FinList n p -> Sum n (Orientation p)

-- | sums for <a>Orientation</a>.
sumsOrnt :: Entity p => p -> Sums n (Orientation p)


-- | equalizers and coequalizers, i.e. limits of <tt><a>Diagram</a>
--   (<a>Parallel</a> <b>d</b>)</tt>.
module OAlg.Limes.EqualizersAndCoequalizers

-- | equalizers for a <a>Multiplicative</a> structures.
type Equalizers n = Limits Mlt Projective (Parallel LeftToRight) N2 n

-- | equalizer as <a>Limes</a>.
type Equalizer n = Limes Mlt Projective (Parallel LeftToRight) N2 n

-- | <a>Cone</a> for a equalizer.
type EqualizerCone n = Cone Mlt Projective (Parallel LeftToRight) N2 n

-- | <a>Diagram</a> for a equalizer.
type EqualizerDiagram n = Diagram (Parallel LeftToRight) N2 n

-- | equalizers of <tt>n</tt> arrows given by products of two points and
--   equalizers of two arrows.
equalizers :: Multiplicative a => Products N2 a -> Equalizers N2 a -> Equalizers n a

-- | the induced equalizers of zero parallel arrows.
equalizers0 :: Multiplicative a => Products N2 a -> Equalizers N0 a

-- | equalizers of one parallel arrow, i.e. <a>Minima</a>.
equalizers1 :: Multiplicative a => Equalizers N1 a

-- | promoting equalizers.
--   
equalizers2 :: Multiplicative a => Equalizers N2 a -> Equalizers (n + 2) a

-- | equalizers for <a>Orientation</a>
equalizersOrnt :: Entity p => p -> Equalizers n (Orientation p)

-- | coequalizers for a <a>Multiplicative</a> structure.
type Coequalizers n = Limits Mlt Injective (Parallel RightToLeft) N2 n

-- | coequalizer as 'Limes.
type Coequalizer n = Limes Mlt Injective (Parallel RightToLeft) N2 n

-- | <a>Cone</a> for a coequalizer.
type CoequalizerCone n = Cone Mlt Injective (Parallel RightToLeft) N2 n

-- | <a>Diagram</a> for a coequalizer.
type CoequalizerDiagram n = Diagram (Parallel RightToLeft) N2 n

-- | coequalizers of <tt>n</tt> arrows given by sums of two points and
--   coequalizers of two arrows.
coequalizers :: Multiplicative a => Sums N2 a -> Coequalizers N2 a -> Coequalizers n a

-- | <a>coequalizers</a> given by a proxy for <tt>n</tt>.
coequalizers' :: Multiplicative a => p n -> Sums N2 a -> Coequalizers N2 a -> Coequalizers n a

-- | coequalizers for <a>Orientation</a>.
coequalizersOrnt :: Entity p => p -> Coequalizers n (Orientation p)

-- | duality between coequalizers and equalizers.
coeqlLimitsDuality :: Multiplicative a => LimitsDuality Mlt (Coequalizers n) (Equalizers n) a


-- | pullbacks and pushouts, i.e. limits of <tt><a>Diagram</a> (<a>Star</a>
--   <b>d</b>)</tt>.
module OAlg.Limes.PullbacksAndPushouts

-- | pullbacks for <a>Multiplicative</a> structures.
type Pullbacks n = Limits Mlt Projective (Star To) (n + 1) n

-- | pullback as <a>Limes</a>.
type Pullback n = Limes Mlt Projective (Star To) (n + 1) n

-- | <a>Cone</a> for a pullback.
type PullbackCone n = Cone Mlt Projective (Star To) (n + 1) n

-- | <a>Diagram</a> for a pullback.
type PullbackDiagram n = Diagram (Star To) (n + 1) n

-- | promotion of pullbacks.
--   
pullbacks :: Multiplicative a => Pullbacks N2 a -> Pullbacks n a

-- | pullbacks for zero arrows as <a>Minima</a>.
pullbacks0 :: Multiplicative a => Pullbacks N0 a

-- | pullbacks of one arrow, i.e. <a>Minima</a>.
pullbacks1 :: Multiplicative a => Pullbacks N1 a

-- | pullbacks given by products and equalizers.
plbPrdEql2 :: Multiplicative a => Products N2 a -> Equalizers N2 a -> Pullbacks N2 a

-- | pullbacks for <a>Orientation</a>.
pullbacksOrnt :: Entity p => p -> Pullbacks n (Orientation p)

-- | pushouts for a <a>Multiplicative</a> structures.
type Pushouts n = Limits Mlt Injective (Star From) (n + 1) n

-- | pushout as <a>Limes</a>.
type Pushout n = Limes Mlt Injective (Star From) (n + 1) n

-- | <a>Cone</a> for a pushout.
type PushoutCone n = Cone Mlt Injective (Star From) (n + 1) n

-- | <a>Diagram</a> for a pushout.
type PushoutDiagram n = Diagram (Star From) (n + 1) n

-- | promotion of pushouts.
pushouts :: Multiplicative a => Pushouts N2 a -> Pushouts n a

-- | <a>pushouts</a> given by a proxy for <tt>n</tt>.
pushouts' :: Multiplicative a => p n -> Pushouts N2 a -> Pushouts n a

-- | pushouts given by sums and coequalizers.
pshSumCoeql2 :: Multiplicative a => Sums N2 a -> Coequalizers N2 a -> Pushouts N2 a

-- | pushouts for <a>Orientation</a>.
pushoutsOrnt :: Entity p => p -> Pushouts n (Orientation p)

-- | duality between pushouts and pullbacks.
pshLimitsDuality :: Multiplicative a => LimitsDuality Mlt (Pushouts n) (Pullbacks n) a


-- | kernels and cokernels, i.e. limits in a <a>Distributive</a> structure
--   of <tt><a>Diagram</a> (<a>Parallel</a> <b>d</b>)</tt> making all
--   arrows <a>zero</a>.
module OAlg.Limes.KernelsAndCokernels

-- | kernels for <a>Distributive</a> structures.
type Kernels n = Limits Dst Projective (Parallel LeftToRight) N2 n

-- | kernel as a <a>Limes</a>.
type Kernel n = Limes Dst Projective (Parallel LeftToRight) N2 n

-- | <a>Cone</a> for a kernel.
type KernelCone n = Cone Dst Projective (Parallel LeftToRight) N2 n

-- | <a>Diagram</a> for a kernel.
type KernelDiagram n = Diagram (Parallel LeftToRight) N2 n

-- | the factor of its shell.
kernelFactor :: KernelCone N1 c -> c

-- | the kernel diagram of a given factor.
kernelDiagram :: Oriented c => c -> KernelDiagram N1 c

-- | promoting kernels.
kernels :: Distributive a => Kernels N1 a -> Kernels n a

-- | kernels for zero arrows.
kernels0 :: Distributive a => Kernels N0 a

-- | promoting kernels.
kernels1 :: Distributive a => Kernels N1 a -> Kernels (n + 1) a

-- | the induced equalizers where its first arrow is <a>zero</a>.
krnEqls :: (Distributive a, Abelian a) => Kernels n a -> Equalizers (n + 1) a

-- | the induced kernels given by adjoining a <a>zero</a> arrow as first
--   arrow.
eqlKrns :: Distributive a => Equalizers (n + 1) a -> Kernels n a

-- | the kernel of the <a>zero</a> factor given by the orientation, i.e.
--   <a>one</a>
kernelZero :: Distributive c => p c -> Orientation (Point c) -> Kernel N1 c

-- | kernels for <a>Orientation</a>.
kernelsOrnt :: Entity p => p -> Kernels n (Orientation p)

-- | cokernels for <a>Distributive</a> structures.
type Cokernels n = Limits Dst Injective (Parallel RightToLeft) N2 n

-- | cokernel as <a>Limes</a>.
type Cokernel n = Limes Dst Injective (Parallel RightToLeft) N2 n

-- | <a>Cone</a> for a cokernel.
type CokernelCone n = Cone Dst Injective (Parallel RightToLeft) N2 n

-- | <a>Diagram</a> for a cokernel.
type CokernelDiagram n = Diagram (Parallel RightToLeft) N2 n

-- | the factor of its shell.
cokernelFactor :: CokernelCone N1 c -> c

-- | the cokernel diagram of a given factor.
cokernelDiagram :: Oriented c => c -> CokernelDiagram N1 c

-- | promoting cokernels.
cokernels :: Distributive a => Cokernels N1 a -> Cokernels n a

-- | <a>cokernels</a> given by an additional proxy for <tt>n</tt>.
cokernels' :: Distributive a => p n -> Cokernels N1 a -> Cokernels n a

-- | cokernels for <a>Orientation</a>.
cokernelsOrnt :: Entity p => p -> Cokernels n (Orientation p)

-- | duality from <a>Kernel</a> to <a>Cokernel</a>.
krnLimesDuality :: Distributive a => LimesDuality Dst (Kernel n) (Cokernel n) a

-- | duality between <a>Cokernel</a> to <a>Kernel</a>.
cokrnLimesDuality :: Distributive a => LimesDuality Dst (Cokernel n) (Kernel n) a

-- | checks if the arrows of the kernel diagram are equal to the given ones
--   and if its shell is equal to the given arrow.
--   
--   <b>Property</b> Let <tt><a>LimesProjective</a> ('ConeKerenl d k') _ =
--   ker</tt> be in <tt><a>Kernel</a> <b>n</b> <b>a</b></tt>, <tt>fs</tt>
--   in <tt><a>FinList</a> <b>n</b> <b>a</b></tt> and <tt>k</tt> be in
--   <tt><b>a</b></tt>, then the statement <tt><a>prpIsKernel</a> ker fs
--   k</tt> holds if and only if
--   
--   <ol>
--   <li><tt>fs <a>==</a> <a>dgArrows</a> d</tt>.</li>
--   <li><tt>k <a>==</a> k'</tt>.</li>
--   </ol>
prpIsKernel :: Distributive a => Kernel n a -> FinList n a -> a -> Statement

-- | checks if the arrows of the cokernel diagram are equal to the given
--   ones and if its shell is equal to the given arrow.
--   
--   <b>Property</b> Let <tt><a>LimesInjective</a> ('ConeCokerenl d k') _ =
--   coker</tt> be in <tt><a>Cokernel</a> <b>n</b> <b>a</b></tt>,
--   <tt>fs</tt> in <tt><a>FinList</a> <b>n</b> <b>a</b></tt> and
--   <tt>k</tt> be in <tt><b>a</b></tt>, then the statement
--   <tt><a>prpIsCokernel</a> coker fs k</tt> holds if and only if
--   
--   <ol>
--   <li><tt>fs <a>==</a> <a>dgArrows</a> d</tt>.</li>
--   <li><tt>k <a>==</a> k'</tt>.</li>
--   </ol>
prpIsCokernel :: Distributive a => Cokernel n a -> FinList n a -> a -> Statement


-- | propositions on <a>Limits</a>.
module OAlg.Limes.Proposition

-- | validity of <a>Limits</a> for <tt><a>Orientation</a>
--   <a>Symbol</a></tt>.
prpLimitsOrntSymbol :: Statement


-- | definition of slicing a <a>Multiplicative</a> structures according a
--   given indexed <a>Point</a>.
module OAlg.Entity.Slice.Definition

-- | slice over <b><tt>c</tt></b> by a given <a>Site</a> and indexed by
--   <tt><b>i</b></tt>.
data Slice s i c
[SliceFrom] :: i c -> c -> Slice From i c
[SliceTo] :: i c -> c -> Slice To i c

-- | the underlying slice.
slice :: Slice s i c -> c

-- | factor between two slices.
--   
--   <b>Property</b> Let <tt>SliceFactor a b f</tt> be in
--   <tt><a>SliceFactor</a> <b>s</b> <b>i</b> <b>c</b></tt> for a
--   <a>Multiplicative</a> structure <b><tt>c</tt></b> constrained by
--   <tt><a>Sliced</a> <b>i</b> <b>c</b></tt> then holds:
--   
--   <ol>
--   <li>If <tt>a</tt> matches <tt><a>SliceFrom</a> _ a'</tt> then holds:
--   Let <tt><a>SliceFrom</a> _ b' = b</tt>
--   in<ol><li><tt><a>orientation</a> f <a>==</a> <a>end</a> a'
--   <a>:&gt;</a> <a>end</a> b'</tt>.</li><li><tt>b' <a>==</a> f <a>*</a>
--   a'</tt>.</li></ol></li>
--   <li>If <tt>a</tt> matches <tt><a>SliceTo</a> _ a'</tt> then holds: Let
--   <tt><a>SliceTo</a> _ b' = b</tt> in<ol><li><tt><a>orientation</a> f
--   <a>==</a> <a>start</a> a' <a>:&gt;</a> <a>start</a>
--   b'</tt>.</li><li><tt>a' <a>==</a> b' <a>*</a> f</tt> .</li></ol></li>
--   </ol>
data SliceFactor s i c
SliceFactor :: Slice s i c -> Slice s i c -> c -> SliceFactor s i c

-- | the underlying factor.
slfDrop :: SliceFactor s i c -> c

-- | Slicing a <a>Multiplicative</a> structures at the <a>Point</a> given
--   by the type of the index <b><tt>i</tt></b>.
--   
--   <b>Note</b> The constraint <tt><a>Singleton1</a> <b>i</b></tt> ensures
--   that the distinguished point depends only on the type <b><tt>i
--   c</tt></b>.
class (Entity1 i, Singleton1 i) => Sliced i c

-- | the distingueished point of the given index type <tt><b>i</b></tt>.
slicePoint :: Sliced i c => i c -> Point c

-- | dropping a slice factor.
data SliceFactorDrop s x y
[SliceFactorFromDrop] :: (Multiplicative c, Sliced i c) => SliceFactorDrop From (SliceFactor From i c) c
[SliceFactorToDrop] :: (Multiplicative c, Sliced i c) => SliceFactorDrop To (SliceFactor To i c) c

-- | predicate for a <tt><a>Star</a> <b>t</b></tt> diagram with center
--   <a>Point</a> given by the index type <tt><b>i</b> <b>c</b></tt>.
--   
--   <b>Property</b> Let <tt><a>DiagramSlicedCenter</a> i d</tt> be in
--   <tt><a>DiagramSlicedCenter</a> <b>i</b> <b>t</b> <b>n</b> <b>m</b>
--   <b>c</b></tt> then holds: <tt><a>slicePoint</a> i <a>==</a>
--   <a>dgCenter</a> d</tt>.
data DiagramSlicedCenter i t n m c
[DiagramSlicedCenter] :: Sliced i c => i c -> Diagram (Star t) n m c -> DiagramSlicedCenter i t n m c

-- | predicate for a limes with a sliced tip of the universal cone.
--   
--   <b>Property</b> Let <tt><a>LimesSlicedTip</a> i l</tt> be in
--   <tt><a>LimesSlicedTip</a> <b>i</b> <b>s</b> <b>p</b> <b>t</b> <b>n</b>
--   <b>m</b> <b>c</b></tt> then holds: <tt><a>tip</a>
--   (<a>universalCone</a> l) <a>==</a> <a>slicePoint</a> i</tt>.
data LimesSlicedTip i s p t n m c
[LimesSlicedTip] :: Sliced i c => i c -> Limes s p t n m c -> LimesSlicedTip i s p t n m c

-- | the underlying limes.
lstLimes :: LimesSlicedTip i s p t n m c -> Limes s p t n m c

-- | terminal point for factors sliced to a <a>Point</a>.
slfTerminalPoint :: (Multiplicative c, Sliced i c) => TerminalPoint (SliceFactor To i c)

-- | the induced pullback.
slfPullback :: Multiplicative c => Products n (SliceFactor To i c) -> DiagramSlicedCenter i To (n + 1) n c -> Pullback n c

-- | the induced <a>Injective</a> <a>Limits</a>.
slfLimitsInjective :: (Multiplicative c, Sliced i c) => Limits Mlt Injective t n m c -> Limits Mlt Injective t n m (SliceFactor To i c)

-- | the induced random variable.
xSliceTo :: Sliced i c => XOrtSite To c -> i c -> X (Slice To i c)

-- | the induced random variable.
xSliceFrom :: Sliced i c => XOrtSite From c -> i c -> X (Slice From i c)

-- | the induced random variable.
xosXOrtSiteToSliceFactorTo :: (Multiplicative c, Sliced i c) => XOrtSite To c -> i c -> XOrtSite To (SliceFactor To i c)

-- | the induced random variable.
xosXOrtSiteFromSliceFactorFrom :: (Multiplicative c, Sliced i c) => XOrtSite From c -> i c -> XOrtSite From (SliceFactor From i c)
instance (OAlg.Data.Equal.Eq1 i, GHC.Classes.Eq c) => GHC.Classes.Eq (OAlg.Entity.Slice.Definition.SliceFactor s i c)
instance (OAlg.Data.Show.Show1 i, GHC.Show.Show c) => GHC.Show.Show (OAlg.Entity.Slice.Definition.SliceFactor s i c)
instance GHC.Show.Show (OAlg.Entity.Slice.Definition.SliceFactorDrop s x y)
instance GHC.Classes.Eq (OAlg.Entity.Slice.Definition.SliceFactorDrop s x y)
instance OAlg.Data.Show.Show2 (OAlg.Entity.Slice.Definition.SliceFactorDrop s)
instance OAlg.Data.Equal.Eq2 (OAlg.Entity.Slice.Definition.SliceFactorDrop s)
instance OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Definition.SliceFactorDrop s x y)
instance OAlg.Data.Validable.Validable2 (OAlg.Entity.Slice.Definition.SliceFactorDrop s)
instance (Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable x, Data.Typeable.Internal.Typeable y) => OAlg.Entity.Definition.Entity (OAlg.Entity.Slice.Definition.SliceFactorDrop s x y)
instance Data.Typeable.Internal.Typeable s => OAlg.Entity.Definition.Entity2 (OAlg.Entity.Slice.Definition.SliceFactorDrop s)
instance OAlg.Category.Definition.Morphism (OAlg.Entity.Slice.Definition.SliceFactorDrop s)
instance OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Slice.Definition.SliceFactorDrop s) OAlg.Structure.Definition.Typ
instance OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Entity.Slice.Definition.SliceFactorDrop s)
instance OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Slice.Definition.SliceFactorDrop s) OAlg.Structure.Oriented.Definition.Ort
instance OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Slice.Definition.SliceFactorDrop s) OAlg.Structure.Multiplicative.Definition.Mlt
instance OAlg.Category.Applicative.Applicative (OAlg.Entity.Slice.Definition.SliceFactorDrop s)
instance Data.Typeable.Internal.Typeable s => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Entity.Slice.Definition.SliceFactorDrop s)
instance Data.Typeable.Internal.Typeable s => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Entity.Slice.Definition.SliceFactorDrop s)
instance OAlg.Structure.Oriented.Definition.Oriented c => GHC.Show.Show (OAlg.Entity.Slice.Definition.LimesSlicedTip i s p t n m c)
instance (OAlg.Structure.Oriented.Definition.Oriented c, OAlg.Data.Validable.Validable (OAlg.Limes.Definition.Limes s p t n m c)) => OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Definition.LimesSlicedTip i s p t n m c)
instance OAlg.Structure.Oriented.Definition.Oriented c => GHC.Show.Show (OAlg.Entity.Slice.Definition.DiagramSlicedCenter i t n m c)
instance OAlg.Structure.Oriented.Definition.Oriented c => OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Definition.DiagramSlicedCenter i t n m c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c) => OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Definition.SliceFactor s i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, Data.Typeable.Internal.Typeable s) => OAlg.Entity.Definition.Entity (OAlg.Entity.Slice.Definition.SliceFactor s i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, Data.Typeable.Internal.Typeable s) => OAlg.Structure.Oriented.Definition.Oriented (OAlg.Entity.Slice.Definition.SliceFactor s i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, Data.Typeable.Internal.Typeable s) => OAlg.Structure.Multiplicative.Definition.Multiplicative (OAlg.Entity.Slice.Definition.SliceFactor s i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From c) => OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.From i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From c) => OAlg.Structure.Oriented.Definition.XStandardOrtSiteFrom (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.From i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From c) => OAlg.Data.Validable.XStandard (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.From i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From c) => OAlg.Data.Validable.XStandard (OAlg.Entity.Slice.Definition.Slice 'OAlg.Data.Dualisable.From i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From c) => OAlg.Structure.Oriented.Definition.XStandardPoint (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.From i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To c) => OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.To i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To c) => OAlg.Structure.Oriented.Definition.XStandardOrtSiteTo (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.To i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To c) => OAlg.Data.Validable.XStandard (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.To i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To c) => OAlg.Data.Validable.XStandard (OAlg.Entity.Slice.Definition.Slice 'OAlg.Data.Dualisable.To i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.To c) => OAlg.Structure.Oriented.Definition.XStandardPoint (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.To i c)
instance OAlg.Structure.Oriented.Definition.XStandardOrtSite 'OAlg.Data.Dualisable.From (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.To Data.Proxy.Proxy OAlg.Structure.Oriented.Definition.OS)
instance OAlg.Structure.Oriented.Definition.XStandardOrtSiteFrom (OAlg.Entity.Slice.Definition.SliceFactor 'OAlg.Data.Dualisable.To Data.Proxy.Proxy OAlg.Structure.Oriented.Definition.OS)
instance (OAlg.Data.Show.Show1 i, GHC.Show.Show c) => GHC.Show.Show (OAlg.Entity.Slice.Definition.Slice s i c)
instance (OAlg.Data.Equal.Eq1 i, GHC.Classes.Eq c) => GHC.Classes.Eq (OAlg.Entity.Slice.Definition.Slice s i c)
instance (OAlg.Structure.Oriented.Definition.Oriented c, OAlg.Entity.Slice.Definition.Sliced i c) => OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Definition.Slice s i c)
instance (OAlg.Structure.Oriented.Definition.Oriented c, OAlg.Entity.Slice.Definition.Sliced i c, Data.Typeable.Internal.Typeable s) => OAlg.Entity.Definition.Entity (OAlg.Entity.Slice.Definition.Slice s i c)
instance OAlg.Entity.Slice.Definition.Sliced i c => OAlg.Entity.Slice.Definition.Sliced i (OAlg.Data.Opposite.Op c)
instance OAlg.Entity.Slice.Definition.Sliced Data.Proxy.Proxy OAlg.Structure.Oriented.Definition.OS


-- | sliced structures with an assigned <i>free</i> <a>Point</a> of some
--   given <i>dimension</i>.
module OAlg.Entity.Slice.Free

-- | index for free points within a <a>Multiplicative</a> structure
--   <tt><b>c</b></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; lengthN (Free attest :: Free N3 c)
--   3
--   </pre>
newtype Free k c
Free :: Any k -> Free k c

-- | the underlying natural number.
freeN :: Free k c -> N

-- | casting between <a>Free</a> types.
castFree :: Free k x -> Free k y

-- | check for being a free point, i.e. if it is equal to
--   <a>slicePoint</a>.
--   
--   <b>Definition</b> Let <tt>n</tt> be in <tt><a>Free</a> <b>n</b>
--   <b>c</b></tt> and <tt>p</tt> in <tt><a>Point</a> <b>c</b></tt> then we
--   call <tt>p</tt> of <b><i>order</i></b> <tt>n</tt> if and only if
--   <tt><a>slicePoint</a> i <a>==</a> p</tt>.
isFree :: (Eq (Point c), Sliced (Free k) c) => Free k c -> Point c -> Bool

-- | some free attest.
data SomeFree c
[SomeFree] :: (Attestable k, Sliced (Free k) c) => Free k c -> SomeFree c

-- | some free point within a <a>Multiplicative</a> structure
--   <tt><b>c</b></tt>.
data SomeFreeSlice s c
[SomeFreeSlice] :: (Attestable k, Sliced (Free k) c) => Slice s (Free k) c -> SomeFreeSlice s c

-- | predicate for a limes with a <i>free</i> tip of its universal cone.
--   
--   <b>Property</b> Let <tt>'LimesFree k l</tt> be in <tt><a>LimesFree</a>
--   <b>s</b> <b>p</b> <b>t</b> <b>n</b> <b>m</b> <b>a</b></tt> and then
--   holds: <tt><a>slicePoint</a> k <a>==</a> t</tt> where <tt>t =
--   <a>tip</a> (<a>universalCone</a> l)</tt>.
data LimesFree s p t n m a
[LimesFree] :: (Attestable k, Sliced (Free k) a) => Free k a -> Limes s p t n m a -> LimesFree s p t n m a

-- | the underlying free limes.
limesFree :: LimesFree s p t n m a -> Limes s p t n m a

-- | predicate for diagrams with free points.
data DiagramFree t n m a
DiagramFree :: FinList n (SomeFree a) -> Diagram t n m a -> DiagramFree t n m a

-- | the underlying diagram.
dgfDiagram :: DiagramFree t n m a -> Diagram t n m a

-- | predicate for a kernel with a start point of its diagram given by the
--   slice index and a free universal tip.
--   
--   <b>Property</b> Let <tt><a>KernelSliceFromSomeFreeTip</a> k' i
--   ker</tt> be in <tt><a>KernelSliceFromSomeFreeTip</a> <b>n</b>
--   <b>c</b></tt>, then holds:
--   
--   <ol>
--   <li><tt><a>slicePoint</a> i <a>==</a> s</tt> where
--   <tt><a>DiagramParallelLR</a> s _ _ = <a>diagram</a> ker</tt>.</li>
--   <li><tt><a>slicePoint</a> k' <a>==</a> <a>tip</a>
--   (<a>universalCone</a> ker)</tt>.</li>
--   </ol>
data KernelSliceFromSomeFreeTip n i c
[KernelSliceFromSomeFreeTip] :: (Attestable k', Sliced (Free k') c) => Free k' c -> i c -> Kernel n c -> KernelSliceFromSomeFreeTip n i c

-- | the underlying kernel.
ksfKernel :: KernelSliceFromSomeFreeTip n i c -> Kernel n c

-- | kernel of a diagram with free points.
type KernelFree = LimesFree Dst Projective (Parallel LeftToRight) N2

-- | kerne diagram with free points.
type KernelDiagramFree = DiagramFree (Parallel LeftToRight) N2

-- | cokernel diagrams with free points.
type CokernelDiagramFree = DiagramFree (Parallel RightToLeft) N2

-- | pullback of a diagram with free points.
type PullbackFree n c = LimesFree Mlt Projective (Star To) (n + 1) n c

-- | pullback diagram with free points.
type PullbackDiagramFree n c = DiagramFree (Star To) (n + 1) n c
instance (Data.Typeable.Internal.Typeable c, Data.Typeable.Internal.Typeable k) => OAlg.Entity.Definition.Entity (OAlg.Entity.Slice.Free.Free k c)
instance OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Free.Free k c)
instance GHC.Classes.Eq (OAlg.Entity.Slice.Free.Free k c)
instance GHC.Show.Show (OAlg.Entity.Slice.Free.Free k c)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Show.Show (OAlg.Entity.Slice.Free.DiagramFree t n m a)
instance GHC.Show.Show (OAlg.Entity.Slice.Free.SomeFree c)
instance GHC.Show.Show c => GHC.Show.Show (OAlg.Entity.Slice.Free.SomeFreeSlice s c)
instance OAlg.Structure.Oriented.Definition.Oriented a => GHC.Show.Show (OAlg.Entity.Slice.Free.LimesFree s p t n m a)
instance OAlg.Structure.Oriented.Definition.Oriented a => OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Free.DiagramFree t n m a)
instance (OAlg.Structure.Oriented.Definition.Oriented c, OAlg.Entity.Slice.Definition.Sliced i c) => GHC.Show.Show (OAlg.Entity.Slice.Free.KernelSliceFromSomeFreeTip n i c)
instance (OAlg.Structure.Distributive.Definition.Distributive c, OAlg.Entity.Slice.Definition.Sliced i c, OAlg.Structure.Oriented.Definition.XStandardOrtSiteTo c, Data.Typeable.Internal.Typeable n) => OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Free.KernelSliceFromSomeFreeTip n i c)
instance (OAlg.Structure.Distributive.Definition.Distributive a, OAlg.Limes.Cone.EligibleFactor.XStandardOrtPerspective p a, Data.Typeable.Internal.Typeable p, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable n, Data.Typeable.Internal.Typeable m) => OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Free.LimesFree OAlg.Structure.Distributive.Definition.Dst p t n m a)
instance OAlg.Structure.Oriented.Definition.Oriented c => OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Free.SomeFreeSlice s c)
instance OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Free.SomeFree c)
instance OAlg.Entity.Natural.Attestable k => OAlg.Data.Singleton.Singleton1 (OAlg.Entity.Slice.Free.Free k)
instance OAlg.Data.Show.Show1 (OAlg.Entity.Slice.Free.Free k)
instance OAlg.Data.Equal.Eq1 (OAlg.Entity.Slice.Free.Free k)
instance OAlg.Data.Validable.Validable1 (OAlg.Entity.Slice.Free.Free k)
instance Data.Typeable.Internal.Typeable k => OAlg.Entity.Definition.Entity1 (OAlg.Entity.Slice.Free.Free k)


-- | <a>Products</a> and <a>Sums</a> for matrices.
module OAlg.Entity.Matrix.ProductsAndSums

-- | products for matrices.
mtxProducts :: Distributive x => Products n (Matrix x)

-- | sums for matrices.
mtxSums :: Distributive x => Sums n (Matrix x)


-- | propositions on matrices.
module OAlg.Entity.Matrix.Proposition

-- | validity of the algebraic structure of matrices.
prpMatrix :: Distributive x => XOrtOrientation (Matrix x) -> XOrtSite From (Matrix x) -> XOrtSite To (Matrix x) -> Statement

-- | validity of the algebraic structure of block matrices of <a>Z</a>.
prpMatrixZ :: Statement


-- | matrices over <a>Distributive</a> structures
module OAlg.Entity.Matrix


-- | validation of this package.
module OAlg.Proposition

-- | Validation of the basic entities of the package oalg-base.
prpOAlgBase :: Statement


-- | mapping of <a>Limits</a> under <a>Adjunction</a>s.
module OAlg.Adjunction.Limes

-- | mapping a projective limes under an adjunction.
lmPrjMap :: Hom Mlt h => Adjunction h d c -> Limes Mlt Projective t n m d -> Limes Mlt Projective t n m c

-- | mapping a injective limes under an adjunction.
lmInjMap :: Hom Mlt h => Adjunction h d c -> Limes Mlt Injective t n m c -> Limes Mlt Injective t n m d

-- | mapping a projective limes under an adjunction.
lmPrjMapDst :: Hom Dst h => Adjunction h d c -> Limes Dst Projective t n m d -> Limes Dst Projective t n m c

-- | mapping a injective limes under an adjunction.
lmInjMapDst :: Hom Dst h => Adjunction h d c -> Limes Dst Injective t n m c -> Limes Dst Injective t n m d


-- | <a>Adjunction</a> between <a>Multiplicative</a> structures and the
--   <a>Limes</a> preserving property of adjoint structures.
module OAlg.Adjunction


-- | <a>Cokernel</a>-<a>Kernel</a> <a>Adjunction</a> for <a>Slice</a>d
--   structures.
module OAlg.Entity.Slice.Adjunction

-- | the cokernel-kenrel adjunction.
slcAdjunction :: (SliceCokernelTo i c, SliceKernelFrom i c) => i c -> Adjunction (SliceCokernelKernel i c) (SliceFactor From i c) (SliceFactor To i c)

-- | the left and right homomorphisms for the cokernel-kernel adjunction
--   <a>slcAdjunction</a>.
data SliceCokernelKernel i c x y
[SliceCokernel] :: SliceCokernelKernel i c (SliceFactor To i c) (SliceFactor From i c)
[SliceKernel] :: SliceCokernelKernel i c (SliceFactor From i c) (SliceFactor To i c)

-- | <a>Distributive</a> structures <tt><b>c</b></tt> having to each
--   <tt><a>Slice</a> <a>To</a> <b>i</b> <b>c</b></tt> a <a>Cokernel</a>.
--   
--   <b>Property</b> Let <tt>h = <a>SliceTo</a> _ h'</tt> be in
--   <tt><a>Slice</a> <a>To</a> <b>i</b> <b>c</b></tt> for a
--   <tt><b>i</b></tt> sliced, <a>Distributive</a> structure
--   <tt><b>c</b></tt>, then holds:
--   
--   <tt><a>diagram</a> (<a>universalCone</a> coker) <a>==</a>
--   <a>cokernelDiagram</a> h'</tt> where <tt>coker =
--   <a>sliceCokernelTo</a> h</tt>.
class (Distributive c, Sliced i c) => SliceCokernelTo i c
sliceCokernelTo :: SliceCokernelTo i c => Slice To i c -> Cokernel N1 c

-- | <a>Distributive</a> structures <tt><b>c</b></tt> having to each
--   <tt><a>Slice</a> <a>From</a> <b>i</b> <b>c</b></tt> a <a>Kernel</a>.
--   
--   <b>Property</b> Let <tt>h = <a>SliceFrom</a> _ h'</tt> be in
--   <tt><a>Slice</a> <a>From</a> <b>i</b> <b>c</b></tt> for a
--   <tt><b>i</b></tt> sliced, <a>Distributive</a> structure
--   <tt><b>c</b></tt>, then holds:
--   
--   <tt><a>diagram</a> (<a>universalCone</a> ker) <a>==</a>
--   <a>kernelDiagram</a> h'</tt> where <tt>coker = <a>sliceKernelFrom</a>
--   h</tt>.
class (Distributive c, Sliced i c) => SliceKernelFrom i c
sliceKernelFrom :: SliceKernelFrom i c => Slice From i c -> Kernel N1 c

-- | the right unit of the cokernel-kernel adjunction <a>slcAdjunction</a>.
slcCokerKer :: (SliceCokernelTo i c, SliceKernelFrom i c) => Slice To i c -> SliceFactor To i c

-- | the left unit of the cokernel-kenrel adjunction <a>slcAdjunction</a>.
slcKerCoker :: (SliceCokernelTo i c, SliceKernelFrom i c) => Slice From i c -> SliceFactor From i c

-- | random variable for <tt><a>SliceFactor</a> <a>To</a> <b>i</b>
--   <b>c</b></tt>.
xSliceFactorTo :: (Multiplicative c, Sliced i c) => XOrtSite To c -> i c -> X (SliceFactor To i c)

-- | random variable for <tt><a>SliceFactor</a> <a>From</a> <b>i</b>
--   <b>c</b></tt>.
xSliceFactorFrom :: (Multiplicative c, Sliced i c) => XOrtSite From c -> i c -> X (SliceFactor From i c)

-- | validity for the values of <a>SliceCokernelKernel</a> to be
--   <a>HomMultiplicative</a>.
prpHomMltSliceCokernelKernel :: (SliceCokernelTo i c, SliceKernelFrom i c) => XOrtSite To c -> XOrtSite From c -> i c -> Statement
instance GHC.Show.Show (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c x y)
instance GHC.Classes.Eq (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c x y)
instance (OAlg.Structure.Distributive.Definition.Distributive c, OAlg.Entity.Slice.Adjunction.SliceCokernelTo i c, OAlg.Entity.Slice.Adjunction.SliceKernelFrom i c) => OAlg.Category.Applicative.Applicative (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c)
instance (OAlg.Structure.Distributive.Definition.Distributive c, OAlg.Entity.Slice.Adjunction.SliceCokernelTo i c, OAlg.Entity.Slice.Adjunction.SliceKernelFrom i c) => OAlg.Hom.Oriented.Definition.HomOriented (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c)
instance (OAlg.Structure.Distributive.Definition.Distributive c, OAlg.Entity.Slice.Adjunction.SliceCokernelTo i c, OAlg.Entity.Slice.Adjunction.SliceKernelFrom i c) => OAlg.Hom.Multiplicative.Definition.HomMultiplicative (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c)
instance OAlg.Data.Show.Show2 (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c)
instance OAlg.Data.Equal.Eq2 (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c)
instance OAlg.Data.Validable.Validable (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c x y)
instance OAlg.Data.Validable.Validable2 (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c)
instance (Data.Typeable.Internal.Typeable i, Data.Typeable.Internal.Typeable c, Data.Typeable.Internal.Typeable x, Data.Typeable.Internal.Typeable y) => OAlg.Entity.Definition.Entity (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c x y)
instance (Data.Typeable.Internal.Typeable i, Data.Typeable.Internal.Typeable c) => OAlg.Entity.Definition.Entity2 (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c) => OAlg.Category.Definition.Morphism (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c) => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c) OAlg.Structure.Definition.Typ
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c) => OAlg.Category.Definition.EmbeddableMorphismTyp (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c)
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c) => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c) OAlg.Structure.Oriented.Definition.Ort
instance (OAlg.Structure.Multiplicative.Definition.Multiplicative c, OAlg.Entity.Slice.Definition.Sliced i c) => OAlg.Category.Definition.EmbeddableMorphism (OAlg.Entity.Slice.Adjunction.SliceCokernelKernel i c) OAlg.Structure.Multiplicative.Definition.Mlt


-- | slicing a <a>Multiplicative</a> structures by a given indexed
--   <a>Point</a>.
--   
--   <b>Note</b> Unfortunately for Haskell it is in general not possible to
--   lift a value to the type level, as such we need to circumvent somehow
--   this restriction by using an <i>index</i> type where the associated
--   point depends only of that type (see <a>Sliced</a>).
module OAlg.Entity.Slice


-- | <a>Generator</a> for finitely generated <a>Point</a>s within a
--   <a>Distributive</a> structure.
module OAlg.Data.Generator

-- | generator for finitely generated <a>Point</a>s within a
--   <a>Distributive</a> structure.
--   
--   <b>Property</b> Let <tt><a>Generator</a> d k' k'' coker ker lft</tt>
--   be in <a>Generator</a> and let <tt><a>DiagramChainTo</a> g
--   (p<a>:|</a>p'<a>:|</a><a>Nil</a>) = d</tt>
--   
--   <pre>
--          p           p'
--   g &lt;&lt;------- g' &lt;------&lt; g''
--   </pre>
--   
--   then holds:
--   
--   <ol>
--   <li><tt>coker</tt> is the cokernel of <tt>p'</tt> with <tt>p</tt> as
--   the shell of its universal cone.</li>
--   <li><tt>ker</tt> is the kernel of <tt>p</tt> with <tt>p'</tt> as the
--   shell of its universal cone.</li>
--   <li><tt>'KenrelSliceFromSomeFreeTip k'' k' ker</tt> is
--   <a>valid</a>.</li>
--   <li>For all <tt>h = <a>SliceFrom</a> _ h'</tt> in <tt><a>Slice</a>
--   <a>From</a> (<a>Free</a> <b>k</b>) a</tt> with <tt><a>end</a> h'
--   <a>==</a> g</tt> holds:<ol><li><tt>lft h</tt> is
--   <a>valid</a>.</li><li><tt><a>orientation</a> (lft h) <a>==</a>
--   <a>start</a> h <a>:&gt;</a> <a>start</a> p</tt>.</li><li><tt>p
--   <a>*</a> lft h <a>==</a> h'</tt>.</li></ol></li>
--   </ol>
--   
--   <pre>
--             g'
--            ^ |
--           /  |
--   lft h  /   | p
--         /    |
--        /     v
--       * ---&gt; g
--          h'
--   </pre>
data Generator s a
[GeneratorTo] :: (Attestable k', Sliced (Free k') a, Attestable k'', Sliced (Free k'') a) => Diagram (Chain To) N3 N2 a -> Free k' a -> Free k'' a -> Cokernel N1 a -> Kernel N1 a -> (forall (k :: N'). Slice From (Free k) a -> a) -> Generator To a

-- | random variable of factors in <tt><b>a</b></tt> having a free
--   <a>start</a> and as <a>end</a>-point the given one.
newtype XSomeFreeSliceFromLiftable a
XSomeFreeSliceFromLiftable :: (Point a -> X (SomeFreeSlice From a)) -> XSomeFreeSliceFromLiftable a

-- | the underlying random variable for some free slice.
xsfsfl :: XSomeFreeSliceFromLiftable a -> Point a -> X (SomeFreeSlice From a)

-- | random variable of lift-able free slice froms.
--   
--   <b>Property</b> Let <tt><b>a</b></tt> be in instance of
--   <a>XStandardSomeFreeSliceFromLiftable</a> then holds: For all
--   <tt>p</tt> in <tt><a>Point</a> <b>a</b></tt> and
--   <tt><a>SomeFreeSlice</a> (<a>SliceFrom</a> _ h)</tt> in the range of
--   <tt><a>xStandardSomeFreeSliceFromLiftable</a> p</tt> holds:
--   <tt><a>end</a> h <a>==</a> p</tt>.
class XStandardSomeFreeSliceFromLiftable a
xStandardSomeFreeSliceFromLiftable :: XStandardSomeFreeSliceFromLiftable a => XSomeFreeSliceFromLiftable a
instance (OAlg.Structure.Distributive.Definition.Distributive a, OAlg.Structure.Oriented.Definition.XStandardOrtSiteFrom a, OAlg.Structure.Oriented.Definition.XStandardOrtSiteTo a, OAlg.Data.Generator.XStandardSomeFreeSliceFromLiftable a) => OAlg.Data.Validable.Validable (OAlg.Data.Generator.Generator 'OAlg.Data.Dualisable.To a)
instance (OAlg.Structure.Oriented.Definition.Oriented a, OAlg.Structure.Oriented.Definition.XStandardPoint a) => OAlg.Data.Validable.Validable (OAlg.Data.Generator.XSomeFreeSliceFromLiftable a)
